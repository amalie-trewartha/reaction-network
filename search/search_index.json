{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Reaction Network ( rxn_network ) is a Python package for predicting likely inorganic chemical reaction pathways using combinatorial and graph theoretical methods. Installation directions We recommend installing using pip: pip install reaction-network The package will then be installed under the name rxn_network . As of version 7.0, the reaction-network package no longer uses graph-tool . All network functionality is now implemented using rustworkx . This means it is no longer required to complete any extra installations. Tutorial notebooks The examples folder contains two (2) demonstration notebooks: 1_enumerators.ipynb : how to enumerate reactions from a set of entries; running enumerators using jobflow 2_network.ipynb : how to build reaction networks from a list of enumerators and entries; how to perform pathfinding to recommend balanced reaction pathways; running reaction network analysis using jobflow Citation If you use this code or Python package in your work, please consider citing the following paper: McDermott, M. J., Dwaraknath, S. S., and Persson, K. A. (2021). A graph-based network for predicting chemical reaction pathways in solid-state materials synthesis. Nature Communications, 12(1). https://doi.org/10.1038/s41467-021-23339-x Acknowledgements This work was supported as part of GENESIS: A Next Generation Synthesis Center, an Energy Frontier Research Center funded by the U.S. Department of Energy, Office of Science, Basic Energy Sciences under Award Number DE-SC0019212. Learn more about the GENESIS EFRC here: https://www.stonybrook.edu/genesis/","title":"Home"},{"location":"#_1","text":"Reaction Network ( rxn_network ) is a Python package for predicting likely inorganic chemical reaction pathways using combinatorial and graph theoretical methods.","title":""},{"location":"#installation-directions","text":"We recommend installing using pip: pip install reaction-network The package will then be installed under the name rxn_network . As of version 7.0, the reaction-network package no longer uses graph-tool . All network functionality is now implemented using rustworkx . This means it is no longer required to complete any extra installations.","title":"Installation directions"},{"location":"#tutorial-notebooks","text":"The examples folder contains two (2) demonstration notebooks: 1_enumerators.ipynb : how to enumerate reactions from a set of entries; running enumerators using jobflow 2_network.ipynb : how to build reaction networks from a list of enumerators and entries; how to perform pathfinding to recommend balanced reaction pathways; running reaction network analysis using jobflow","title":"Tutorial notebooks"},{"location":"#citation","text":"If you use this code or Python package in your work, please consider citing the following paper: McDermott, M. J., Dwaraknath, S. S., and Persson, K. A. (2021). A graph-based network for predicting chemical reaction pathways in solid-state materials synthesis. Nature Communications, 12(1). https://doi.org/10.1038/s41467-021-23339-x","title":"Citation"},{"location":"#acknowledgements","text":"This work was supported as part of GENESIS: A Next Generation Synthesis Center, an Energy Frontier Research Center funded by the U.S. Department of Energy, Office of Science, Basic Energy Sciences under Award Number DE-SC0019212. Learn more about the GENESIS EFRC here: https://www.stonybrook.edu/genesis/","title":"Acknowledgements"},{"location":"CHANGELOG/","text":"Changelog v7.0.0 (2022-10-27) Full Changelog Implemented enhancements: graph-tool is a slow/cumbersome to install dependency #84 Closed issues: ray cannot parallelise the job among mutiple CPUs on HPC cluster #132 Merged pull requests: Test github actions #176 ( mattmcdermott ) Swap graph-tool for rustworkx #175 ( mattmcdermott ) v6.1.1 (2022-10-25) Full Changelog Merged pull requests: fix broken docs github workflow #174 ( mattmcdermott ) v6.1.0 (2022-10-25) Full Changelog Merged pull requests: hopefully fix broken release workflow #173 ( mattmcdermott ) v6.0.1 (2022-10-25) Full Changelog v6.0.2 (2022-10-25) Full Changelog Merged pull requests: trigger new version release #172 ( mattmcdermott ) v6.0.0 (2022-10-25) Full Changelog Closed issues: Expand the entry_set for new molecules #162 Missing tests for much of the firetasks, fireworks, network, and pathways modules #67 Merged pull requests: Release new version to PyPI #171 ( mattmcdermott ) Update README with better description, new patch release 6.0.1 #170 ( mattmcdermott ) Major update of reaction-network #169 ( mattmcdermott ) Add pbar option to expand_pd() #163 ( janosh ) v5.1.0 (2022-05-26) Full Changelog Implemented enhancements: Reaction enumerators can be sped up with multiprocessing #101 Fixed bugs: Oversight: calculate_e_above_hulls function in GibbsEntrySet only works when entries cover whole phase diagram #103 Closed issues: ReactionsToDb often encounters MongoDB doc limit #104 Merged pull requests: Add carbonate correction, ability to turn off enumeration parallelization, minor bug fixes, new numba #133 ( mattmcdermott ) v5.0.0 (2022-03-31) Full Changelog Fixed bugs: ChemicalPotentialDiagram.metastable_domains occasionally does not work for some systems, particularly with large # elements #91 Closed issues: Setup Issue (setuptools-scm was unable to detect version for) #105 Merged pull requests: Add support for multiprocessing via ray, add builders and pydantic models, bug fixes #106 ( mattmcdermott ) Fix broken metastable_domains in chemical potential diagram #102 ( mattmcdermott ) v4.3.0 (2022-03-02) Full Changelog Fixed bugs: NISTReferenceEntry is sometimes incorrect for phases with multiple entries having different formulas #89 Minimize enumerators slow when exclusive precursors specified #87 get_computed_rxn behaving very slow #86 Merged pull requests: Update Github action for release #100 ( mattmcdermott ) Fix for broken NIST data and small speedups for e_above_hull calculations #90 ( mattmcdermott ) v4.2.0 (2022-02-11) Full Changelog Closed issues: Unnecessary computations in Enumerators with exclusive_precursors=True #77 Merged pull requests: Address several performance issues, add FREED data, support for metastable CPDs #88 ( mattmcdermott ) v4.1.0 (2022-02-01) Full Changelog Closed issues: Unnecessary calculations occurring when exclusive_precursors=True #76 Merged pull requests: Speed up enumerators and tests #85 ( mattmcdermott ) v4.0.2 (2022-01-22) Full Changelog v4.0.1 (2022-01-22) Full Changelog Merged pull requests: Fix github workflows #75 ( mattmcdermott ) v4.0.0 (2022-01-22) Full Changelog Merged pull requests: New NetworkFW, competitiveness scores, updates to enumerators, and bug fixes + speed-ups #59 ( mattmcdermott ) v3.0.0 (2021-10-01) Full Changelog Merged pull requests: [WIP] Add much-needed tests #45 ( mattmcdermott ) v2.0.3 (2021-08-05) Full Changelog Merged pull requests: Update README and trigger release #34 ( shyamd ) v2.0.2 (2021-08-05) Full Changelog Merged pull requests: Bug fix for interdependent reactions #33 ( mattmcdermott ) v2.0.1 (2021-08-05) Full Changelog Merged pull requests: Fix and deploy docs #32 ( shyamd ) v2.0.0 (2021-08-05) Full Changelog Merged pull requests: Major refactor of entire reaction-network package #23 ( mattmcdermott ) paper (2021-04-15) Full Changelog Merged pull requests: Merging of major revision reaction-network code #5 ( mattmcdermott ) Repo Cleanup #4 ( shyamd ) v1.0 (2020-07-21) Full Changelog Merged pull requests: Added pathway balancing, NIST gas data, StructuralComplexity cost metric, and more. #3 ( mattmcdermott ) Implemented Gibbs Free Energy SISSO descriptor #2 ( mattmcdermott ) Added refactoring and documentation #1 ( mattmcdermott ) * This Changelog was automatically generated by github_changelog_generator","title":"CHANGELOG"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v700-2022-10-27","text":"Full Changelog Implemented enhancements: graph-tool is a slow/cumbersome to install dependency #84 Closed issues: ray cannot parallelise the job among mutiple CPUs on HPC cluster #132 Merged pull requests: Test github actions #176 ( mattmcdermott ) Swap graph-tool for rustworkx #175 ( mattmcdermott )","title":"v7.0.0 (2022-10-27)"},{"location":"CHANGELOG/#v611-2022-10-25","text":"Full Changelog Merged pull requests: fix broken docs github workflow #174 ( mattmcdermott )","title":"v6.1.1 (2022-10-25)"},{"location":"CHANGELOG/#v610-2022-10-25","text":"Full Changelog Merged pull requests: hopefully fix broken release workflow #173 ( mattmcdermott )","title":"v6.1.0 (2022-10-25)"},{"location":"CHANGELOG/#v601-2022-10-25","text":"Full Changelog","title":"v6.0.1 (2022-10-25)"},{"location":"CHANGELOG/#v602-2022-10-25","text":"Full Changelog Merged pull requests: trigger new version release #172 ( mattmcdermott )","title":"v6.0.2 (2022-10-25)"},{"location":"CHANGELOG/#v600-2022-10-25","text":"Full Changelog Closed issues: Expand the entry_set for new molecules #162 Missing tests for much of the firetasks, fireworks, network, and pathways modules #67 Merged pull requests: Release new version to PyPI #171 ( mattmcdermott ) Update README with better description, new patch release 6.0.1 #170 ( mattmcdermott ) Major update of reaction-network #169 ( mattmcdermott ) Add pbar option to expand_pd() #163 ( janosh )","title":"v6.0.0 (2022-10-25)"},{"location":"CHANGELOG/#v510-2022-05-26","text":"Full Changelog Implemented enhancements: Reaction enumerators can be sped up with multiprocessing #101 Fixed bugs: Oversight: calculate_e_above_hulls function in GibbsEntrySet only works when entries cover whole phase diagram #103 Closed issues: ReactionsToDb often encounters MongoDB doc limit #104 Merged pull requests: Add carbonate correction, ability to turn off enumeration parallelization, minor bug fixes, new numba #133 ( mattmcdermott )","title":"v5.1.0 (2022-05-26)"},{"location":"CHANGELOG/#v500-2022-03-31","text":"Full Changelog Fixed bugs: ChemicalPotentialDiagram.metastable_domains occasionally does not work for some systems, particularly with large # elements #91 Closed issues: Setup Issue (setuptools-scm was unable to detect version for) #105 Merged pull requests: Add support for multiprocessing via ray, add builders and pydantic models, bug fixes #106 ( mattmcdermott ) Fix broken metastable_domains in chemical potential diagram #102 ( mattmcdermott )","title":"v5.0.0 (2022-03-31)"},{"location":"CHANGELOG/#v430-2022-03-02","text":"Full Changelog Fixed bugs: NISTReferenceEntry is sometimes incorrect for phases with multiple entries having different formulas #89 Minimize enumerators slow when exclusive precursors specified #87 get_computed_rxn behaving very slow #86 Merged pull requests: Update Github action for release #100 ( mattmcdermott ) Fix for broken NIST data and small speedups for e_above_hull calculations #90 ( mattmcdermott )","title":"v4.3.0 (2022-03-02)"},{"location":"CHANGELOG/#v420-2022-02-11","text":"Full Changelog Closed issues: Unnecessary computations in Enumerators with exclusive_precursors=True #77 Merged pull requests: Address several performance issues, add FREED data, support for metastable CPDs #88 ( mattmcdermott )","title":"v4.2.0 (2022-02-11)"},{"location":"CHANGELOG/#v410-2022-02-01","text":"Full Changelog Closed issues: Unnecessary calculations occurring when exclusive_precursors=True #76 Merged pull requests: Speed up enumerators and tests #85 ( mattmcdermott )","title":"v4.1.0 (2022-02-01)"},{"location":"CHANGELOG/#v402-2022-01-22","text":"Full Changelog","title":"v4.0.2 (2022-01-22)"},{"location":"CHANGELOG/#v401-2022-01-22","text":"Full Changelog Merged pull requests: Fix github workflows #75 ( mattmcdermott )","title":"v4.0.1 (2022-01-22)"},{"location":"CHANGELOG/#v400-2022-01-22","text":"Full Changelog Merged pull requests: New NetworkFW, competitiveness scores, updates to enumerators, and bug fixes + speed-ups #59 ( mattmcdermott )","title":"v4.0.0 (2022-01-22)"},{"location":"CHANGELOG/#v300-2021-10-01","text":"Full Changelog Merged pull requests: [WIP] Add much-needed tests #45 ( mattmcdermott )","title":"v3.0.0 (2021-10-01)"},{"location":"CHANGELOG/#v203-2021-08-05","text":"Full Changelog Merged pull requests: Update README and trigger release #34 ( shyamd )","title":"v2.0.3 (2021-08-05)"},{"location":"CHANGELOG/#v202-2021-08-05","text":"Full Changelog Merged pull requests: Bug fix for interdependent reactions #33 ( mattmcdermott )","title":"v2.0.2 (2021-08-05)"},{"location":"CHANGELOG/#v201-2021-08-05","text":"Full Changelog Merged pull requests: Fix and deploy docs #32 ( shyamd )","title":"v2.0.1 (2021-08-05)"},{"location":"CHANGELOG/#v200-2021-08-05","text":"Full Changelog Merged pull requests: Major refactor of entire reaction-network package #23 ( mattmcdermott )","title":"v2.0.0 (2021-08-05)"},{"location":"CHANGELOG/#paper-2021-04-15","text":"Full Changelog Merged pull requests: Merging of major revision reaction-network code #5 ( mattmcdermott ) Repo Cleanup #4 ( shyamd )","title":"paper (2021-04-15)"},{"location":"CHANGELOG/#v10-2020-07-21","text":"Full Changelog Merged pull requests: Added pathway balancing, NIST gas data, StructuralComplexity cost metric, and more. #3 ( mattmcdermott ) Implemented Gibbs Free Energy SISSO descriptor #2 ( mattmcdermott ) Added refactoring and documentation #1 ( mattmcdermott ) * This Changelog was automatically generated by github_changelog_generator","title":"v1.0 (2020-07-21)"},{"location":"reference/core/calculator/","text":"Basic interface for a reaction cost Calculator Calculator Bases: MSONable Base definition for a property calculator Source code in rxn_network/core/calculator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Calculator ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a property calculator \"\"\" @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\" def decorate ( self , rxn : Reaction ) -> Reaction : \"\"\" Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" new_rxn = deepcopy ( rxn ) if not getattr ( new_rxn , \"data\" ): new_rxn . data = {} new_rxn . data [ self . name ] = self . calculate ( new_rxn ) return new_rxn def calculate_many ( self , rxns : List [ Reaction ]) -> List [ float ]: \"\"\" Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Args: rxns: the list of ComputedReaction objects to be evaluated Returns: The list of competitiveness scores \"\"\" results = [] for rxn in rxns : results . append ( self . calculate ( rxn )) return results def decorate_many ( self , rxns : List [ Reaction ]) -> List [ Reaction ]: \"\"\" Decorates a list of reactions with the calculated properties. Args: rxns: the list of ComputedReaction objects to be decorated Returns: The list of decorated ComputedReaction objects \"\"\" new_rxns = [] for rxn in rxns : new_rxns . append ( self . decorate ( rxn )) return new_rxns @property @abstractmethod def name ( self ): \"\"\" The name of the calculator; used to store the value within the reaction's data dictionary \"\"\" calculate ( rxn ) abstractmethod Evaluates the specified property of a reaction Source code in rxn_network/core/calculator.py 18 19 20 21 22 @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\" calculate_many ( rxns ) Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Parameters: Name Type Description Default rxns List [ Reaction ] the list of ComputedReaction objects to be evaluated required Returns: Type Description List [ float ] The list of competitiveness scores Source code in rxn_network/core/calculator.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_many ( self , rxns : List [ Reaction ]) -> List [ float ]: \"\"\" Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Args: rxns: the list of ComputedReaction objects to be evaluated Returns: The list of competitiveness scores \"\"\" results = [] for rxn in rxns : results . append ( self . calculate ( rxn )) return results decorate ( rxn ) Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Parameters: Name Type Description Default rxn Reaction The reaction object. required Returns: Type Description Reaction The reaction object, modified in place Source code in rxn_network/core/calculator.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def decorate ( self , rxn : Reaction ) -> Reaction : \"\"\" Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" new_rxn = deepcopy ( rxn ) if not getattr ( new_rxn , \"data\" ): new_rxn . data = {} new_rxn . data [ self . name ] = self . calculate ( new_rxn ) return new_rxn decorate_many ( rxns ) Decorates a list of reactions with the calculated properties. Parameters: Name Type Description Default rxns List [ Reaction ] the list of ComputedReaction objects to be decorated required Returns: Type Description List [ Reaction ] The list of decorated ComputedReaction objects Source code in rxn_network/core/calculator.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def decorate_many ( self , rxns : List [ Reaction ]) -> List [ Reaction ]: \"\"\" Decorates a list of reactions with the calculated properties. Args: rxns: the list of ComputedReaction objects to be decorated Returns: The list of decorated ComputedReaction objects \"\"\" new_rxns = [] for rxn in rxns : new_rxns . append ( self . decorate ( rxn )) return new_rxns name () abstractmethod property The name of the calculator; used to store the value within the reaction's data dictionary Source code in rxn_network/core/calculator.py 77 78 79 80 81 82 83 @property @abstractmethod def name ( self ): \"\"\" The name of the calculator; used to store the value within the reaction's data dictionary \"\"\"","title":"Calculator"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator","text":"Bases: MSONable Base definition for a property calculator Source code in rxn_network/core/calculator.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 class Calculator ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a property calculator \"\"\" @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\" def decorate ( self , rxn : Reaction ) -> Reaction : \"\"\" Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" new_rxn = deepcopy ( rxn ) if not getattr ( new_rxn , \"data\" ): new_rxn . data = {} new_rxn . data [ self . name ] = self . calculate ( new_rxn ) return new_rxn def calculate_many ( self , rxns : List [ Reaction ]) -> List [ float ]: \"\"\" Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Args: rxns: the list of ComputedReaction objects to be evaluated Returns: The list of competitiveness scores \"\"\" results = [] for rxn in rxns : results . append ( self . calculate ( rxn )) return results def decorate_many ( self , rxns : List [ Reaction ]) -> List [ Reaction ]: \"\"\" Decorates a list of reactions with the calculated properties. Args: rxns: the list of ComputedReaction objects to be decorated Returns: The list of decorated ComputedReaction objects \"\"\" new_rxns = [] for rxn in rxns : new_rxns . append ( self . decorate ( rxn )) return new_rxns @property @abstractmethod def name ( self ): \"\"\" The name of the calculator; used to store the value within the reaction's data dictionary \"\"\"","title":"Calculator"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.calculate","text":"Evaluates the specified property of a reaction Source code in rxn_network/core/calculator.py 18 19 20 21 22 @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\"","title":"calculate()"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.calculate_many","text":"Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Parameters: Name Type Description Default rxns List [ Reaction ] the list of ComputedReaction objects to be evaluated required Returns: Type Description List [ float ] The list of competitiveness scores Source code in rxn_network/core/calculator.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 def calculate_many ( self , rxns : List [ Reaction ]) -> List [ float ]: \"\"\" Calculates the competitiveness score for a list of reactions by enumerating competing reactions, evaluating their cost with the supplied cost function, and then using the c-score formula, i.e. the _get_c_score() method, to determine the competitiveness score. Parallelized with ray. Args: rxns: the list of ComputedReaction objects to be evaluated Returns: The list of competitiveness scores \"\"\" results = [] for rxn in rxns : results . append ( self . calculate ( rxn )) return results","title":"calculate_many()"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.decorate","text":"Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Parameters: Name Type Description Default rxn Reaction The reaction object. required Returns: Type Description Reaction The reaction object, modified in place Source code in rxn_network/core/calculator.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def decorate ( self , rxn : Reaction ) -> Reaction : \"\"\" Returns a copy of the reaction with the calculated property by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" new_rxn = deepcopy ( rxn ) if not getattr ( new_rxn , \"data\" ): new_rxn . data = {} new_rxn . data [ self . name ] = self . calculate ( new_rxn ) return new_rxn","title":"decorate()"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.decorate_many","text":"Decorates a list of reactions with the calculated properties. Parameters: Name Type Description Default rxns List [ Reaction ] the list of ComputedReaction objects to be decorated required Returns: Type Description List [ Reaction ] The list of decorated ComputedReaction objects Source code in rxn_network/core/calculator.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def decorate_many ( self , rxns : List [ Reaction ]) -> List [ Reaction ]: \"\"\" Decorates a list of reactions with the calculated properties. Args: rxns: the list of ComputedReaction objects to be decorated Returns: The list of decorated ComputedReaction objects \"\"\" new_rxns = [] for rxn in rxns : new_rxns . append ( self . decorate ( rxn )) return new_rxns","title":"decorate_many()"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.name","text":"The name of the calculator; used to store the value within the reaction's data dictionary Source code in rxn_network/core/calculator.py 77 78 79 80 81 82 83 @property @abstractmethod def name ( self ): \"\"\" The name of the calculator; used to store the value within the reaction's data dictionary \"\"\"","title":"name()"},{"location":"reference/core/composition/","text":"Composition class used to represent a chemical composition. Composition Bases: PymatgenComposition Customized Composition class adapted from pymatgen Source code in rxn_network/core/composition.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Composition ( PymatgenComposition ): \"\"\"Customized Composition class adapted from pymatgen\"\"\" def __init__ ( self , * args , strict : bool = False , ** kwargs ): # pylint: disable=useless-parent-delegation super () . __init__ ( * args , strict = strict , ** kwargs ) @cached_property def reduced_formula ( self ) -> str : \"\"\" Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. \"\"\" return self . get_reduced_formula_and_factor ()[ 0 ] reduced_formula () property cached Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. Source code in rxn_network/core/composition.py 15 16 17 18 19 20 21 @cached_property def reduced_formula ( self ) -> str : \"\"\" Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. \"\"\" return self . get_reduced_formula_and_factor ()[ 0 ]","title":"Composition"},{"location":"reference/core/composition/#rxn_network.core.composition.Composition","text":"Bases: PymatgenComposition Customized Composition class adapted from pymatgen Source code in rxn_network/core/composition.py 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class Composition ( PymatgenComposition ): \"\"\"Customized Composition class adapted from pymatgen\"\"\" def __init__ ( self , * args , strict : bool = False , ** kwargs ): # pylint: disable=useless-parent-delegation super () . __init__ ( * args , strict = strict , ** kwargs ) @cached_property def reduced_formula ( self ) -> str : \"\"\" Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. \"\"\" return self . get_reduced_formula_and_factor ()[ 0 ]","title":"Composition"},{"location":"reference/core/composition/#rxn_network.core.composition.Composition.reduced_formula","text":"Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. Source code in rxn_network/core/composition.py 15 16 17 18 19 20 21 @cached_property def reduced_formula ( self ) -> str : \"\"\" Returns a pretty normalized formula, i.e., LiFePO4 instead of Li4Fe4P4O16. \"\"\" return self . get_reduced_formula_and_factor ()[ 0 ]","title":"reduced_formula()"},{"location":"reference/core/cost_function/","text":"Basic interface for a cost function CostFunction Bases: MSONable Base definition for a cost function Source code in rxn_network/core/cost_function.py 11 12 13 14 15 16 17 18 19 20 class CostFunction ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a cost function \"\"\" @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\" evaluate ( rxn ) abstractmethod Evaluates the total cost function on a reaction Source code in rxn_network/core/cost_function.py 16 17 18 19 20 @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\"","title":"Cost Function"},{"location":"reference/core/cost_function/#rxn_network.core.cost_function.CostFunction","text":"Bases: MSONable Base definition for a cost function Source code in rxn_network/core/cost_function.py 11 12 13 14 15 16 17 18 19 20 class CostFunction ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a cost function \"\"\" @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\"","title":"CostFunction"},{"location":"reference/core/cost_function/#rxn_network.core.cost_function.CostFunction.evaluate","text":"Evaluates the total cost function on a reaction Source code in rxn_network/core/cost_function.py 16 17 18 19 20 @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\"","title":"evaluate()"},{"location":"reference/core/enumerator/","text":"Basic interface for a reaction Enumerator Enumerator Bases: MSONable Base definition for a class that enumerates reactions. Source code in rxn_network/core/enumerator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Enumerator ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a class that enumerates reactions. \"\"\" def __init__ ( self , precursors , targets ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . precursors = precursors if precursors else [] self . targets = targets if targets else [] @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\" enumerate ( entries ) abstractmethod Enumerates the potential reactions from the list of entries Source code in rxn_network/core/enumerator.py 21 22 23 24 25 @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\"","title":"Enumerator"},{"location":"reference/core/enumerator/#rxn_network.core.enumerator.Enumerator","text":"Bases: MSONable Base definition for a class that enumerates reactions. Source code in rxn_network/core/enumerator.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 class Enumerator ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a class that enumerates reactions. \"\"\" def __init__ ( self , precursors , targets ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . precursors = precursors if precursors else [] self . targets = targets if targets else [] @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\"","title":"Enumerator"},{"location":"reference/core/enumerator/#rxn_network.core.enumerator.Enumerator.enumerate","text":"Enumerates the potential reactions from the list of entries Source code in rxn_network/core/enumerator.py 21 22 23 24 25 @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\"","title":"enumerate()"},{"location":"reference/core/network/","text":"Basic interface for a reaction network. Network Bases: MSONable Base definition for a reaction network. Source code in rxn_network/core/network.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Network ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction network. \"\"\" def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction , ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . rxns = rxns self . cost_function = cost_function self . entries = GibbsEntrySet ( rxns . entries ) self . entries . build_indices () self . _g = None self . _precursors = None self . _target = None @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\" @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\" @abstractmethod def set_precursors ( self , precursors ): \"\"\"Set the phases used as precursors in the network\"\"\" @abstractmethod def set_target ( self , target ): \"\"\"Set the phase used as a target in the network\"\"\" @property def precursors ( self ): \"\"\"The phases used as precursors in the network\"\"\" return self . _precursors @property def target ( self ): \"\"\"The phase used as a target in the network\"\"\" return self . _target @property def graph ( self ): \"\"\"Returns the network object in graph-tool\"\"\" return self . _g @property def chemsys ( self ): \"\"\"A string representing the chemical system (elements) of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys )) build () abstractmethod Construct the network from the supplied enumerators Source code in rxn_network/core/network.py 38 39 40 @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\" chemsys () property A string representing the chemical system (elements) of the network Source code in rxn_network/core/network.py 69 70 71 72 @property def chemsys ( self ): \"\"\"A string representing the chemical system (elements) of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys )) find_pathways ( target , k ) abstractmethod Find reaction pathways Source code in rxn_network/core/network.py 42 43 44 @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\" graph () property Returns the network object in graph-tool Source code in rxn_network/core/network.py 64 65 66 67 @property def graph ( self ): \"\"\"Returns the network object in graph-tool\"\"\" return self . _g precursors () property The phases used as precursors in the network Source code in rxn_network/core/network.py 54 55 56 57 @property def precursors ( self ): \"\"\"The phases used as precursors in the network\"\"\" return self . _precursors set_precursors ( precursors ) abstractmethod Set the phases used as precursors in the network Source code in rxn_network/core/network.py 46 47 48 @abstractmethod def set_precursors ( self , precursors ): \"\"\"Set the phases used as precursors in the network\"\"\" set_target ( target ) abstractmethod Set the phase used as a target in the network Source code in rxn_network/core/network.py 50 51 52 @abstractmethod def set_target ( self , target ): \"\"\"Set the phase used as a target in the network\"\"\" target () property The phase used as a target in the network Source code in rxn_network/core/network.py 59 60 61 62 @property def target ( self ): \"\"\"The phase used as a target in the network\"\"\" return self . _target","title":"Network"},{"location":"reference/core/network/#rxn_network.core.network.Network","text":"Bases: MSONable Base definition for a reaction network. Source code in rxn_network/core/network.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class Network ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction network. \"\"\" def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction , ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . rxns = rxns self . cost_function = cost_function self . entries = GibbsEntrySet ( rxns . entries ) self . entries . build_indices () self . _g = None self . _precursors = None self . _target = None @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\" @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\" @abstractmethod def set_precursors ( self , precursors ): \"\"\"Set the phases used as precursors in the network\"\"\" @abstractmethod def set_target ( self , target ): \"\"\"Set the phase used as a target in the network\"\"\" @property def precursors ( self ): \"\"\"The phases used as precursors in the network\"\"\" return self . _precursors @property def target ( self ): \"\"\"The phase used as a target in the network\"\"\" return self . _target @property def graph ( self ): \"\"\"Returns the network object in graph-tool\"\"\" return self . _g @property def chemsys ( self ): \"\"\"A string representing the chemical system (elements) of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys ))","title":"Network"},{"location":"reference/core/network/#rxn_network.core.network.Network.build","text":"Construct the network from the supplied enumerators Source code in rxn_network/core/network.py 38 39 40 @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\"","title":"build()"},{"location":"reference/core/network/#rxn_network.core.network.Network.chemsys","text":"A string representing the chemical system (elements) of the network Source code in rxn_network/core/network.py 69 70 71 72 @property def chemsys ( self ): \"\"\"A string representing the chemical system (elements) of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys ))","title":"chemsys()"},{"location":"reference/core/network/#rxn_network.core.network.Network.find_pathways","text":"Find reaction pathways Source code in rxn_network/core/network.py 42 43 44 @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\"","title":"find_pathways()"},{"location":"reference/core/network/#rxn_network.core.network.Network.graph","text":"Returns the network object in graph-tool Source code in rxn_network/core/network.py 64 65 66 67 @property def graph ( self ): \"\"\"Returns the network object in graph-tool\"\"\" return self . _g","title":"graph()"},{"location":"reference/core/network/#rxn_network.core.network.Network.precursors","text":"The phases used as precursors in the network Source code in rxn_network/core/network.py 54 55 56 57 @property def precursors ( self ): \"\"\"The phases used as precursors in the network\"\"\" return self . _precursors","title":"precursors()"},{"location":"reference/core/network/#rxn_network.core.network.Network.set_precursors","text":"Set the phases used as precursors in the network Source code in rxn_network/core/network.py 46 47 48 @abstractmethod def set_precursors ( self , precursors ): \"\"\"Set the phases used as precursors in the network\"\"\"","title":"set_precursors()"},{"location":"reference/core/network/#rxn_network.core.network.Network.set_target","text":"Set the phase used as a target in the network Source code in rxn_network/core/network.py 50 51 52 @abstractmethod def set_target ( self , target ): \"\"\"Set the phase used as a target in the network\"\"\"","title":"set_target()"},{"location":"reference/core/network/#rxn_network.core.network.Network.target","text":"The phase used as a target in the network Source code in rxn_network/core/network.py 59 60 61 62 @property def target ( self ): \"\"\"The phase used as a target in the network\"\"\" return self . _target","title":"target()"},{"location":"reference/core/pathway/","text":"Basic interface for a reaction pathway. Pathway Bases: MSONable Base definition for a reaction pathway. Source code in rxn_network/core/pathway.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Pathway ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction pathway. \"\"\" _reactions : List [ Reaction ] @property def entries ( self ): \"\"\"Entry objects in this Pathway\"\"\" return { entry for rxn in self . _reactions for entry in rxn . entries } @property def all_reactants ( self ): \"\"\"Entries serving as a reactant in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . reactants } @property def all_products ( self ): \"\"\"Entries serving as a product in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . products } @property def compositions ( self ): \"\"\"Compositions in the reaction\"\"\" return list ( self . all_reactants | self . all_products ) @property def reactants ( self ): \"\"\"The reactants of this whole reaction pathway\"\"\" return self . all_reactants - self . all_products @property def products ( self ): \"\"\"The products of this whole reaction pathway\"\"\" return self . all_products - self . all_reactants @property def intermediates ( self ): \"\"\"Intermediates as entries in this reaction pathway\"\"\" return self . all_products & self . all_reactants @property def energy ( self ): \"\"\"Total energy of this reaction pathway\"\"\" return sum ( rxn . energy for rxn in self . _reactions ) @property def energy_per_atom ( self ): \"\"\"Total energy per atom of this reaction pathway\"\"\" return sum ( rxn . energy_per_atom for rxn in self . _reactions ) all_products () property Entries serving as a product in any sub reaction Source code in rxn_network/core/pathway.py 29 30 31 32 @property def all_products ( self ): \"\"\"Entries serving as a product in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . products } all_reactants () property Entries serving as a reactant in any sub reaction Source code in rxn_network/core/pathway.py 24 25 26 27 @property def all_reactants ( self ): \"\"\"Entries serving as a reactant in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . reactants } compositions () property Compositions in the reaction Source code in rxn_network/core/pathway.py 34 35 36 37 @property def compositions ( self ): \"\"\"Compositions in the reaction\"\"\" return list ( self . all_reactants | self . all_products ) energy () property Total energy of this reaction pathway Source code in rxn_network/core/pathway.py 54 55 56 57 @property def energy ( self ): \"\"\"Total energy of this reaction pathway\"\"\" return sum ( rxn . energy for rxn in self . _reactions ) energy_per_atom () property Total energy per atom of this reaction pathway Source code in rxn_network/core/pathway.py 59 60 61 62 @property def energy_per_atom ( self ): \"\"\"Total energy per atom of this reaction pathway\"\"\" return sum ( rxn . energy_per_atom for rxn in self . _reactions ) entries () property Entry objects in this Pathway Source code in rxn_network/core/pathway.py 19 20 21 22 @property def entries ( self ): \"\"\"Entry objects in this Pathway\"\"\" return { entry for rxn in self . _reactions for entry in rxn . entries } intermediates () property Intermediates as entries in this reaction pathway Source code in rxn_network/core/pathway.py 49 50 51 52 @property def intermediates ( self ): \"\"\"Intermediates as entries in this reaction pathway\"\"\" return self . all_products & self . all_reactants products () property The products of this whole reaction pathway Source code in rxn_network/core/pathway.py 44 45 46 47 @property def products ( self ): \"\"\"The products of this whole reaction pathway\"\"\" return self . all_products - self . all_reactants reactants () property The reactants of this whole reaction pathway Source code in rxn_network/core/pathway.py 39 40 41 42 @property def reactants ( self ): \"\"\"The reactants of this whole reaction pathway\"\"\" return self . all_reactants - self . all_products","title":"Pathway"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway","text":"Bases: MSONable Base definition for a reaction pathway. Source code in rxn_network/core/pathway.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 class Pathway ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction pathway. \"\"\" _reactions : List [ Reaction ] @property def entries ( self ): \"\"\"Entry objects in this Pathway\"\"\" return { entry for rxn in self . _reactions for entry in rxn . entries } @property def all_reactants ( self ): \"\"\"Entries serving as a reactant in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . reactants } @property def all_products ( self ): \"\"\"Entries serving as a product in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . products } @property def compositions ( self ): \"\"\"Compositions in the reaction\"\"\" return list ( self . all_reactants | self . all_products ) @property def reactants ( self ): \"\"\"The reactants of this whole reaction pathway\"\"\" return self . all_reactants - self . all_products @property def products ( self ): \"\"\"The products of this whole reaction pathway\"\"\" return self . all_products - self . all_reactants @property def intermediates ( self ): \"\"\"Intermediates as entries in this reaction pathway\"\"\" return self . all_products & self . all_reactants @property def energy ( self ): \"\"\"Total energy of this reaction pathway\"\"\" return sum ( rxn . energy for rxn in self . _reactions ) @property def energy_per_atom ( self ): \"\"\"Total energy per atom of this reaction pathway\"\"\" return sum ( rxn . energy_per_atom for rxn in self . _reactions )","title":"Pathway"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.all_products","text":"Entries serving as a product in any sub reaction Source code in rxn_network/core/pathway.py 29 30 31 32 @property def all_products ( self ): \"\"\"Entries serving as a product in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . products }","title":"all_products()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.all_reactants","text":"Entries serving as a reactant in any sub reaction Source code in rxn_network/core/pathway.py 24 25 26 27 @property def all_reactants ( self ): \"\"\"Entries serving as a reactant in any sub reaction\"\"\" return { entry for rxn in self . _reactions for entry in rxn . reactants }","title":"all_reactants()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.compositions","text":"Compositions in the reaction Source code in rxn_network/core/pathway.py 34 35 36 37 @property def compositions ( self ): \"\"\"Compositions in the reaction\"\"\" return list ( self . all_reactants | self . all_products )","title":"compositions()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.energy","text":"Total energy of this reaction pathway Source code in rxn_network/core/pathway.py 54 55 56 57 @property def energy ( self ): \"\"\"Total energy of this reaction pathway\"\"\" return sum ( rxn . energy for rxn in self . _reactions )","title":"energy()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.energy_per_atom","text":"Total energy per atom of this reaction pathway Source code in rxn_network/core/pathway.py 59 60 61 62 @property def energy_per_atom ( self ): \"\"\"Total energy per atom of this reaction pathway\"\"\" return sum ( rxn . energy_per_atom for rxn in self . _reactions )","title":"energy_per_atom()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.entries","text":"Entry objects in this Pathway Source code in rxn_network/core/pathway.py 19 20 21 22 @property def entries ( self ): \"\"\"Entry objects in this Pathway\"\"\" return { entry for rxn in self . _reactions for entry in rxn . entries }","title":"entries()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.intermediates","text":"Intermediates as entries in this reaction pathway Source code in rxn_network/core/pathway.py 49 50 51 52 @property def intermediates ( self ): \"\"\"Intermediates as entries in this reaction pathway\"\"\" return self . all_products & self . all_reactants","title":"intermediates()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.products","text":"The products of this whole reaction pathway Source code in rxn_network/core/pathway.py 44 45 46 47 @property def products ( self ): \"\"\"The products of this whole reaction pathway\"\"\" return self . all_products - self . all_reactants","title":"products()"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.reactants","text":"The reactants of this whole reaction pathway Source code in rxn_network/core/pathway.py 39 40 41 42 @property def reactants ( self ): \"\"\"The reactants of this whole reaction pathway\"\"\" return self . all_reactants - self . all_products","title":"reactants()"},{"location":"reference/core/reaction/","text":"Basic interface for a (chemical) Reaction Reaction Bases: MSONable Base definition for a reaction class. Source code in rxn_network/core/reaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Reaction ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction class. \"\"\" @property @abstractmethod def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" @property @abstractmethod def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" @property @abstractmethod def coefficients ( self ) -> np . ndarray : \"\"\"Coefficients of the reaction\"\"\" @property @abstractmethod def energy ( self ) -> float : \"\"\"The energy of this reaction in total eV\"\"\" @property @abstractmethod def compositions ( self ) -> List [ Composition ]: \"\"\"List of all compositions in the reaction\"\"\" @property def elements ( self ) -> List [ Element ]: \"\"\"List of elements in the reaction\"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements )) coefficients () abstractmethod property Coefficients of the reaction Source code in rxn_network/core/reaction.py 29 30 31 32 @property @abstractmethod def coefficients ( self ) -> np . ndarray : \"\"\"Coefficients of the reaction\"\"\" compositions () abstractmethod property List of all compositions in the reaction Source code in rxn_network/core/reaction.py 39 40 41 42 @property @abstractmethod def compositions ( self ) -> List [ Composition ]: \"\"\"List of all compositions in the reaction\"\"\" elements () property List of elements in the reaction Source code in rxn_network/core/reaction.py 44 45 46 47 @property def elements ( self ) -> List [ Element ]: \"\"\"List of elements in the reaction\"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements )) energy () abstractmethod property The energy of this reaction in total eV Source code in rxn_network/core/reaction.py 34 35 36 37 @property @abstractmethod def energy ( self ) -> float : \"\"\"The energy of this reaction in total eV\"\"\" products () abstractmethod property List of products for this reaction Source code in rxn_network/core/reaction.py 24 25 26 27 @property @abstractmethod def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" reactants () abstractmethod property List of reactants for this reaction Source code in rxn_network/core/reaction.py 19 20 21 22 @property @abstractmethod def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\"","title":"Reaction"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction","text":"Bases: MSONable Base definition for a reaction class. Source code in rxn_network/core/reaction.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 class Reaction ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a reaction class. \"\"\" @property @abstractmethod def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" @property @abstractmethod def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" @property @abstractmethod def coefficients ( self ) -> np . ndarray : \"\"\"Coefficients of the reaction\"\"\" @property @abstractmethod def energy ( self ) -> float : \"\"\"The energy of this reaction in total eV\"\"\" @property @abstractmethod def compositions ( self ) -> List [ Composition ]: \"\"\"List of all compositions in the reaction\"\"\" @property def elements ( self ) -> List [ Element ]: \"\"\"List of elements in the reaction\"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ))","title":"Reaction"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.coefficients","text":"Coefficients of the reaction Source code in rxn_network/core/reaction.py 29 30 31 32 @property @abstractmethod def coefficients ( self ) -> np . ndarray : \"\"\"Coefficients of the reaction\"\"\"","title":"coefficients()"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.compositions","text":"List of all compositions in the reaction Source code in rxn_network/core/reaction.py 39 40 41 42 @property @abstractmethod def compositions ( self ) -> List [ Composition ]: \"\"\"List of all compositions in the reaction\"\"\"","title":"compositions()"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.elements","text":"List of elements in the reaction Source code in rxn_network/core/reaction.py 44 45 46 47 @property def elements ( self ) -> List [ Element ]: \"\"\"List of elements in the reaction\"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ))","title":"elements()"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.energy","text":"The energy of this reaction in total eV Source code in rxn_network/core/reaction.py 34 35 36 37 @property @abstractmethod def energy ( self ) -> float : \"\"\"The energy of this reaction in total eV\"\"\"","title":"energy()"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.products","text":"List of products for this reaction Source code in rxn_network/core/reaction.py 24 25 26 27 @property @abstractmethod def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\"","title":"products()"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.reactants","text":"List of reactants for this reaction Source code in rxn_network/core/reaction.py 19 20 21 22 @property @abstractmethod def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\"","title":"reactants()"},{"location":"reference/core/solver/","text":"Basic interface for a reaction pathway solver. Solver Bases: MSONable Base definition for a pathway solver class. Source code in rxn_network/core/solver.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solver ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a pathway solver class. \"\"\" def __init__ ( self , pathways ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . _pathways = pathways rxns = [] costs = [] for path in self . _pathways . get_paths (): for rxn , cost in zip ( path . reactions , path . costs ): if rxn not in rxns : rxns . append ( rxn ) costs . append ( cost ) self . _reactions = rxns self . _costs = costs @property def pathways ( self ) -> List [ Pathway ]: \"\"\"Pathways used in solver class\"\"\" return self . _pathways @property def reactions ( self ) -> List [ Reaction ]: \"\"\"Reactions used in solver class\"\"\" return self . _reactions @property def costs ( self ) -> List [ float ]: \"\"\"Costs used in solver class\"\"\" return self . _costs @property def num_rxns ( self ) -> int : \"\"\"Length of the reaction list\"\"\" return len ( self . reactions ) @property def num_entries ( self ) -> int : \"\"\"Length of entry list\"\"\" return len ( self . _entries ) costs () property Costs used in solver class Source code in rxn_network/core/solver.py 47 48 49 50 @property def costs ( self ) -> List [ float ]: \"\"\"Costs used in solver class\"\"\" return self . _costs num_entries () property Length of entry list Source code in rxn_network/core/solver.py 57 58 59 60 @property def num_entries ( self ) -> int : \"\"\"Length of entry list\"\"\" return len ( self . _entries ) num_rxns () property Length of the reaction list Source code in rxn_network/core/solver.py 52 53 54 55 @property def num_rxns ( self ) -> int : \"\"\"Length of the reaction list\"\"\" return len ( self . reactions ) pathways () property Pathways used in solver class Source code in rxn_network/core/solver.py 37 38 39 40 @property def pathways ( self ) -> List [ Pathway ]: \"\"\"Pathways used in solver class\"\"\" return self . _pathways reactions () property Reactions used in solver class Source code in rxn_network/core/solver.py 42 43 44 45 @property def reactions ( self ) -> List [ Reaction ]: \"\"\"Reactions used in solver class\"\"\" return self . _reactions","title":"Solver"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver","text":"Bases: MSONable Base definition for a pathway solver class. Source code in rxn_network/core/solver.py 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class Solver ( MSONable , metaclass = ABCMeta ): \"\"\" Base definition for a pathway solver class. \"\"\" def __init__ ( self , pathways ): self . logger = logging . getLogger ( str ( self . __class__ . __name__ )) self . logger . setLevel ( \"INFO\" ) self . _pathways = pathways rxns = [] costs = [] for path in self . _pathways . get_paths (): for rxn , cost in zip ( path . reactions , path . costs ): if rxn not in rxns : rxns . append ( rxn ) costs . append ( cost ) self . _reactions = rxns self . _costs = costs @property def pathways ( self ) -> List [ Pathway ]: \"\"\"Pathways used in solver class\"\"\" return self . _pathways @property def reactions ( self ) -> List [ Reaction ]: \"\"\"Reactions used in solver class\"\"\" return self . _reactions @property def costs ( self ) -> List [ float ]: \"\"\"Costs used in solver class\"\"\" return self . _costs @property def num_rxns ( self ) -> int : \"\"\"Length of the reaction list\"\"\" return len ( self . reactions ) @property def num_entries ( self ) -> int : \"\"\"Length of entry list\"\"\" return len ( self . _entries )","title":"Solver"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.costs","text":"Costs used in solver class Source code in rxn_network/core/solver.py 47 48 49 50 @property def costs ( self ) -> List [ float ]: \"\"\"Costs used in solver class\"\"\" return self . _costs","title":"costs()"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.num_entries","text":"Length of entry list Source code in rxn_network/core/solver.py 57 58 59 60 @property def num_entries ( self ) -> int : \"\"\"Length of entry list\"\"\" return len ( self . _entries )","title":"num_entries()"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.num_rxns","text":"Length of the reaction list Source code in rxn_network/core/solver.py 52 53 54 55 @property def num_rxns ( self ) -> int : \"\"\"Length of the reaction list\"\"\" return len ( self . reactions )","title":"num_rxns()"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.pathways","text":"Pathways used in solver class Source code in rxn_network/core/solver.py 37 38 39 40 @property def pathways ( self ) -> List [ Pathway ]: \"\"\"Pathways used in solver class\"\"\" return self . _pathways","title":"pathways()"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.reactions","text":"Reactions used in solver class Source code in rxn_network/core/solver.py 42 43 44 45 @property def reactions ( self ) -> List [ Reaction ]: \"\"\"Reactions used in solver class\"\"\" return self . _reactions","title":"reactions()"},{"location":"reference/costs/calculators/","text":"A calculator class for determining chemical potential distance of reactions ChempotDistanceCalculator Bases: Calculator Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please reference the paper below: Todd, P. K.; McDermott, M. J.; Rom, C. L.; Corrao, A. A.; Denney, J. J.; Dwaraknath, S. S.; Khalifah, P. G.; Persson, K. A.; Neilson, J. R. Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. J. Am. Chem. Soc. 2021, 143 (37), 15185\u201315194. https://doi.org/10.1021/jacs.1c06229 . Source code in rxn_network/costs/calculators.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class ChempotDistanceCalculator ( Calculator ): \"\"\" Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please reference the paper below: Todd, P. K.; McDermott, M. J.; Rom, C. L.; Corrao, A. A.; Denney, J. J.; Dwaraknath, S. S.; Khalifah, P. G.; Persson, K. A.; Neilson, J. R. Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. J. Am. Chem. Soc. 2021, 143 (37), 15185\u201315194. https://doi.org/10.1021/jacs.1c06229. \"\"\" def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram object mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). name: the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". \"\"\" self . cpd = cpd self . _name = name if mu_func == \"max\" : self . _mu_func = max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = sum # type: ignore self . _open_elems = set () if cpd . entries [ 0 ] . __class__ . __name__ == \"GrandPotPDEntry\" : self . _open_elems = set ( cpd . entries [ 0 ] . chempots . keys ()) def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Args: rxn: the ComputedReaction object Returns: The chemical potential distance of the reaction. \"\"\" reactant_entries = rxn . reactant_entries product_entries = rxn . product_entries if hasattr ( rxn , \"grand_entries\" ): reactant_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c < 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] product_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c > 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] combos = chain ( product ( reactant_entries , product_entries ), combinations ( product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , offset = self . cpd . get_offset ( combo [ 0 ]) + self . cpd . get_offset ( combo [ 1 ]), ) for combo in combos ] distance = round ( float ( self . _mu_func ( distances )), 5 ) return distance @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs , ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram. Returns: A ChempotDistanceCalculator object \"\"\" cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name ) @property def mu_func ( self ) -> Callable : \"\"\"Returns the function used to process the chemical potential distances into a single metric.\"\"\" return self . _mu_func @property def name ( self ) -> str : \"\"\"Returns the name of the data dictionary key where the value is stored\"\"\" return self . _name __init__ ( cpd , mu_func = 'sum' , name = 'chempot_distance' ) Parameters: Name Type Description Default cpd ChemicalPotentialDiagram the chemical potential diagram object required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). 'sum' name str the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". 'chempot_distance' Source code in rxn_network/costs/calculators.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram object mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). name: the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". \"\"\" self . cpd = cpd self . _name = name if mu_func == \"max\" : self . _mu_func = max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = sum # type: ignore self . _open_elems = set () if cpd . entries [ 0 ] . __class__ . __name__ == \"GrandPotPDEntry\" : self . _open_elems = set ( cpd . entries [ 0 ] . chempots . keys ()) calculate ( rxn ) Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Parameters: Name Type Description Default rxn ComputedReaction the ComputedReaction object required Returns: Type Description float The chemical potential distance of the reaction. Source code in rxn_network/costs/calculators.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Args: rxn: the ComputedReaction object Returns: The chemical potential distance of the reaction. \"\"\" reactant_entries = rxn . reactant_entries product_entries = rxn . product_entries if hasattr ( rxn , \"grand_entries\" ): reactant_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c < 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] product_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c > 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] combos = chain ( product ( reactant_entries , product_entries ), combinations ( product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , offset = self . cpd . get_offset ( combo [ 0 ]) + self . cpd . get_offset ( combo [ 1 ]), ) for combo in combos ] distance = round ( float ( self . _mu_func ( distances )), 5 ) return distance from_entries ( entries , mu_func = 'sum' , name = 'chempot_distance' , ** kwargs ) classmethod Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Parameters: Name Type Description Default entries List [ PDEntry ] entry objects used to build the ChemicalPotentialDiagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" 'chempot_distance' **kwargs optional kwargs passed to ChemicalPotentialDiagram. {} Returns: Type Description ChempotDistanceCalculator A ChempotDistanceCalculator object Source code in rxn_network/costs/calculators.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs , ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram. Returns: A ChempotDistanceCalculator object \"\"\" cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name ) mu_func () property Returns the function used to process the chemical potential distances into a single metric. Source code in rxn_network/costs/calculators.py 130 131 132 133 134 @property def mu_func ( self ) -> Callable : \"\"\"Returns the function used to process the chemical potential distances into a single metric.\"\"\" return self . _mu_func name () property Returns the name of the data dictionary key where the value is stored Source code in rxn_network/costs/calculators.py 136 137 138 139 @property def name ( self ) -> str : \"\"\"Returns the name of the data dictionary key where the value is stored\"\"\" return self . _name","title":"Calculators"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator","text":"Bases: Calculator Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please reference the paper below: Todd, P. K.; McDermott, M. J.; Rom, C. L.; Corrao, A. A.; Denney, J. J.; Dwaraknath, S. S.; Khalifah, P. G.; Persson, K. A.; Neilson, J. R. Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. J. Am. Chem. Soc. 2021, 143 (37), 15185\u201315194. https://doi.org/10.1021/jacs.1c06229 . Source code in rxn_network/costs/calculators.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 class ChempotDistanceCalculator ( Calculator ): \"\"\" Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please reference the paper below: Todd, P. K.; McDermott, M. J.; Rom, C. L.; Corrao, A. A.; Denney, J. J.; Dwaraknath, S. S.; Khalifah, P. G.; Persson, K. A.; Neilson, J. R. Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. J. Am. Chem. Soc. 2021, 143 (37), 15185\u201315194. https://doi.org/10.1021/jacs.1c06229. \"\"\" def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram object mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). name: the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". \"\"\" self . cpd = cpd self . _name = name if mu_func == \"max\" : self . _mu_func = max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = sum # type: ignore self . _open_elems = set () if cpd . entries [ 0 ] . __class__ . __name__ == \"GrandPotPDEntry\" : self . _open_elems = set ( cpd . entries [ 0 ] . chempots . keys ()) def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Args: rxn: the ComputedReaction object Returns: The chemical potential distance of the reaction. \"\"\" reactant_entries = rxn . reactant_entries product_entries = rxn . product_entries if hasattr ( rxn , \"grand_entries\" ): reactant_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c < 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] product_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c > 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] combos = chain ( product ( reactant_entries , product_entries ), combinations ( product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , offset = self . cpd . get_offset ( combo [ 0 ]) + self . cpd . get_offset ( combo [ 1 ]), ) for combo in combos ] distance = round ( float ( self . _mu_func ( distances )), 5 ) return distance @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs , ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram. Returns: A ChempotDistanceCalculator object \"\"\" cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name ) @property def mu_func ( self ) -> Callable : \"\"\"Returns the function used to process the chemical potential distances into a single metric.\"\"\" return self . _mu_func @property def name ( self ) -> str : \"\"\"Returns the name of the data dictionary key where the value is stored\"\"\" return self . _name","title":"ChempotDistanceCalculator"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.__init__","text":"Parameters: Name Type Description Default cpd ChemicalPotentialDiagram the chemical potential diagram object required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). 'sum' name str the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". 'chempot_distance' Source code in rxn_network/costs/calculators.py 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram object mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. Current options are 1) max, 2) mean, and 3) sum (default). name: the data dictionary key with which to store the calculated value. Defaults to \"chempot_distance\". \"\"\" self . cpd = cpd self . _name = name if mu_func == \"max\" : self . _mu_func = max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = sum # type: ignore self . _open_elems = set () if cpd . entries [ 0 ] . __class__ . __name__ == \"GrandPotPDEntry\" : self . _open_elems = set ( cpd . entries [ 0 ] . chempots . keys ())","title":"__init__()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.calculate","text":"Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Parameters: Name Type Description Default rxn ComputedReaction the ComputedReaction object required Returns: Type Description float The chemical potential distance of the reaction. Source code in rxn_network/costs/calculators.py 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the (aggregate) chemical potential distance in eV/atom. The mu_func parameter determines how the individual pairwise interface distances are aggregated into a single value describing the overall reaction. Args: rxn: the ComputedReaction object Returns: The chemical potential distance of the reaction. \"\"\" reactant_entries = rxn . reactant_entries product_entries = rxn . product_entries if hasattr ( rxn , \"grand_entries\" ): reactant_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c < 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] product_entries = [ e for e , c in zip ( rxn . grand_entries , rxn . coefficients ) if c > 0 and e . __class__ . __name__ == \"GrandPotPDEntry\" ] combos = chain ( product ( reactant_entries , product_entries ), combinations ( product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , offset = self . cpd . get_offset ( combo [ 0 ]) + self . cpd . get_offset ( combo [ 1 ]), ) for combo in combos ] distance = round ( float ( self . _mu_func ( distances )), 5 ) return distance","title":"calculate()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.from_entries","text":"Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Parameters: Name Type Description Default entries List [ PDEntry ] entry objects used to build the ChemicalPotentialDiagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" 'chempot_distance' **kwargs optional kwargs passed to ChemicalPotentialDiagram. {} Returns: Type Description ChempotDistanceCalculator A ChempotDistanceCalculator object Source code in rxn_network/costs/calculators.py 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs , ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram. Returns: A ChempotDistanceCalculator object \"\"\" cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name )","title":"from_entries()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.mu_func","text":"Returns the function used to process the chemical potential distances into a single metric. Source code in rxn_network/costs/calculators.py 130 131 132 133 134 @property def mu_func ( self ) -> Callable : \"\"\"Returns the function used to process the chemical potential distances into a single metric.\"\"\" return self . _mu_func","title":"mu_func()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.name","text":"Returns the name of the data dictionary key where the value is stored Source code in rxn_network/costs/calculators.py 136 137 138 139 @property def name ( self ) -> str : \"\"\"Returns the name of the data dictionary key where the value is stored\"\"\" return self . _name","title":"name()"},{"location":"reference/costs/softplus/","text":"Implementation of the softplus cost function. Softplus Bases: CostFunction The softplus cost function is a smoothed version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for determining a cost ranking of a reaction. Source code in rxn_network/costs/softplus.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Softplus ( CostFunction ): \"\"\" The softplus cost function is a smoothed version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for determining a cost ranking of a reaction. \"\"\" def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights ) def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the cost of reaction based on the initialized parameters and weights. Args: rxn: A ComputedReaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp ) @staticmethod def _softplus ( x : float , t : float ) -> float : \"\"\"The mathematical formula for the softplus function\"\"\" return np . log ( 1 + ( 273 / t ) * np . exp ( x )) def __repr__ ( self ): return ( \"Softplus with parameters: \" f \" { ' ' . join ([ f ' { k } ( { v } )' for k , v in zip ( self . params , self . weights )]) } \" ) __init__ ( temp = 300 , params = None , weights = None ) Parameters: Name Type Description Default temp float Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. 300 params Optional [ List [ str ]] List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] None weights Optional [ List [ float ]] List of corresponding values by which to weight the function parameters. Defaults to [1.0]. None Source code in rxn_network/costs/softplus.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights ) evaluate ( rxn ) Calculates the cost of reaction based on the initialized parameters and weights. Parameters: Name Type Description Default rxn ComputedReaction A ComputedReaction to evaluate. required Returns: Type Description float The cost of the reaction. Source code in rxn_network/costs/softplus.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the cost of reaction based on the initialized parameters and weights. Args: rxn: A ComputedReaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp )","title":"Softplus"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus","text":"Bases: CostFunction The softplus cost function is a smoothed version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for determining a cost ranking of a reaction. Source code in rxn_network/costs/softplus.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 class Softplus ( CostFunction ): \"\"\" The softplus cost function is a smoothed version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for determining a cost ranking of a reaction. \"\"\" def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights ) def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the cost of reaction based on the initialized parameters and weights. Args: rxn: A ComputedReaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp ) @staticmethod def _softplus ( x : float , t : float ) -> float : \"\"\"The mathematical formula for the softplus function\"\"\" return np . log ( 1 + ( 273 / t ) * np . exp ( x )) def __repr__ ( self ): return ( \"Softplus with parameters: \" f \" { ' ' . join ([ f ' { k } ( { v } )' for k , v in zip ( self . params , self . weights )]) } \" )","title":"Softplus"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus.__init__","text":"Parameters: Name Type Description Default temp float Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. 300 params Optional [ List [ str ]] List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] None weights Optional [ List [ float ]] List of corresponding values by which to weight the function parameters. Defaults to [1.0]. None Source code in rxn_network/costs/softplus.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Absolute Temperature [K]. This serves as a scale factor for the output of the function. Higher temperatures -> lower costs. Defaults to 300 K. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights )","title":"__init__()"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus.evaluate","text":"Calculates the cost of reaction based on the initialized parameters and weights. Parameters: Name Type Description Default rxn ComputedReaction A ComputedReaction to evaluate. required Returns: Type Description float The cost of the reaction. Source code in rxn_network/costs/softplus.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the cost of reaction based on the initialized parameters and weights. Args: rxn: A ComputedReaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp )","title":"evaluate()"},{"location":"reference/data/data/","text":"Experimental Gibbs free energy data from NIST-JANAF (compounds, gases), Barin tables (all compounds), and FactSage (elements) load_experimental_data ( fn ) Load experimental data from a json file. Parameters: Name Type Description Default fn Union [ str , Path ] The filename of the json file required Source code in rxn_network/data/__init__.py 19 20 21 22 23 24 25 26 27 def load_experimental_data ( fn : Union [ str , Path ]) -> Dict [ str , Dict [ float , Any ]]: \"\"\" Load experimental data from a json file. Args: fn: The filename of the json file \"\"\" d = loadfn ( fn ) return { comp : make_float_keys ( data ) for comp , data in d . items ()} make_float_keys ( d ) Convert all keys in a dict to floats. Source code in rxn_network/data/__init__.py 30 31 32 33 34 def make_float_keys ( d ) -> Dict [ float , Any ]: \"\"\" Convert all keys in a dict to floats. \"\"\" return { float ( k ): v for k , v in d . items ()}","title":"Data"},{"location":"reference/data/data/#rxn_network.data.load_experimental_data","text":"Load experimental data from a json file. Parameters: Name Type Description Default fn Union [ str , Path ] The filename of the json file required Source code in rxn_network/data/__init__.py 19 20 21 22 23 24 25 26 27 def load_experimental_data ( fn : Union [ str , Path ]) -> Dict [ str , Dict [ float , Any ]]: \"\"\" Load experimental data from a json file. Args: fn: The filename of the json file \"\"\" d = loadfn ( fn ) return { comp : make_float_keys ( data ) for comp , data in d . items ()}","title":"load_experimental_data()"},{"location":"reference/data/data/#rxn_network.data.make_float_keys","text":"Convert all keys in a dict to floats. Source code in rxn_network/data/__init__.py 30 31 32 33 34 def make_float_keys ( d ) -> Dict [ float , Any ]: \"\"\" Convert all keys in a dict to floats. \"\"\" return { float ( k ): v for k , v in d . items ()}","title":"make_float_keys()"},{"location":"reference/entries/barin/","text":"Implements an Entry that looks up pre-tabulated Gibbs free energies from the Barin tables. BarinReferenceEntry Bases: ExperimentalReferenceEntry An Entry class for Barin experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference Barin, I. (1995). Thermochemical data of pure substances. John Wiley & Sons, Ltd. https://doi.org/10.1002/9783527619825 Source code in rxn_network/entries/barin.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class BarinReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for Barin experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: Barin, I. (1995). Thermochemical data of pure substances. John Wiley & Sons, Ltd. https://doi.org/10.1002/9783527619825 \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Absolute temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , ) __init__ ( composition , temperature , energy_adjustments = None , data = None ) Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). temperature: Absolute required Source code in rxn_network/entries/barin.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Absolute temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"Barin"},{"location":"reference/entries/barin/#rxn_network.entries.barin.BarinReferenceEntry","text":"Bases: ExperimentalReferenceEntry An Entry class for Barin experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference Barin, I. (1995). Thermochemical data of pure substances. John Wiley & Sons, Ltd. https://doi.org/10.1002/9783527619825 Source code in rxn_network/entries/barin.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class BarinReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for Barin experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: Barin, I. (1995). Thermochemical data of pure substances. John Wiley & Sons, Ltd. https://doi.org/10.1002/9783527619825 \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Absolute temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"BarinReferenceEntry"},{"location":"reference/entries/barin/#rxn_network.entries.barin.BarinReferenceEntry.__init__","text":"Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). temperature: Absolute required Source code in rxn_network/entries/barin.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Absolute temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"__init__()"},{"location":"reference/entries/corrections/","text":"Energy correction classes for entry objects. CarbonateCorrection Bases: CompositionEnergyAdjustment Correct carbonate energies to obtain the right formation energies. Source code in rxn_network/entries/corrections.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class CarbonateCorrection ( CompositionEnergyAdjustment ): \"\"\" Correct carbonate energies to obtain the right formation energies. \"\"\" def __init__ ( self , num_ions , carbonate_correction = CARBONATE_CORRECTION ): \"\"\" Initalizes a carbonate correction object Args: num_ions (int): Number of carbonate ions in the composition object carbonate_correction (float): Energy correction per atom per (CO3)2- anion \"\"\" self . _num_ions = num_ions self . _carbonate_correction = carbonate_correction super () . __init__ ( adj_per_atom = carbonate_correction , n_atoms = num_ions , name = \"Carbonate Correction\" , description = ( \"Correction for dGf with (CO3)2- anion, as fit to MP data (300 K).\" ), ) @property def num_ions ( self ): \"\"\" Number of carbonate ions ion the composition object \"\"\" return self . _num_ions @property def carbonate_correction ( self ): \"\"\" Energy correction for carbonate ion, eV per (CO3)2- anion \"\"\" return self . _carbonate_correction __init__ ( num_ions , carbonate_correction = CARBONATE_CORRECTION ) Initalizes a carbonate correction object Parameters: Name Type Description Default num_ions int Number of carbonate ions in the composition object required carbonate_correction float Energy correction per atom per (CO3)2- anion CARBONATE_CORRECTION Source code in rxn_network/entries/corrections.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , num_ions , carbonate_correction = CARBONATE_CORRECTION ): \"\"\" Initalizes a carbonate correction object Args: num_ions (int): Number of carbonate ions in the composition object carbonate_correction (float): Energy correction per atom per (CO3)2- anion \"\"\" self . _num_ions = num_ions self . _carbonate_correction = carbonate_correction super () . __init__ ( adj_per_atom = carbonate_correction , n_atoms = num_ions , name = \"Carbonate Correction\" , description = ( \"Correction for dGf with (CO3)2- anion, as fit to MP data (300 K).\" ), ) carbonate_correction () property Energy correction for carbonate ion, eV per (CO3)2- anion Source code in rxn_network/entries/corrections.py 44 45 46 47 48 49 @property def carbonate_correction ( self ): \"\"\" Energy correction for carbonate ion, eV per (CO3)2- anion \"\"\" return self . _carbonate_correction num_ions () property Number of carbonate ions ion the composition object Source code in rxn_network/entries/corrections.py 37 38 39 40 41 42 @property def num_ions ( self ): \"\"\" Number of carbonate ions ion the composition object \"\"\" return self . _num_ions","title":"Corrections"},{"location":"reference/entries/corrections/#rxn_network.entries.corrections.CarbonateCorrection","text":"Bases: CompositionEnergyAdjustment Correct carbonate energies to obtain the right formation energies. Source code in rxn_network/entries/corrections.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 class CarbonateCorrection ( CompositionEnergyAdjustment ): \"\"\" Correct carbonate energies to obtain the right formation energies. \"\"\" def __init__ ( self , num_ions , carbonate_correction = CARBONATE_CORRECTION ): \"\"\" Initalizes a carbonate correction object Args: num_ions (int): Number of carbonate ions in the composition object carbonate_correction (float): Energy correction per atom per (CO3)2- anion \"\"\" self . _num_ions = num_ions self . _carbonate_correction = carbonate_correction super () . __init__ ( adj_per_atom = carbonate_correction , n_atoms = num_ions , name = \"Carbonate Correction\" , description = ( \"Correction for dGf with (CO3)2- anion, as fit to MP data (300 K).\" ), ) @property def num_ions ( self ): \"\"\" Number of carbonate ions ion the composition object \"\"\" return self . _num_ions @property def carbonate_correction ( self ): \"\"\" Energy correction for carbonate ion, eV per (CO3)2- anion \"\"\" return self . _carbonate_correction","title":"CarbonateCorrection"},{"location":"reference/entries/corrections/#rxn_network.entries.corrections.CarbonateCorrection.__init__","text":"Initalizes a carbonate correction object Parameters: Name Type Description Default num_ions int Number of carbonate ions in the composition object required carbonate_correction float Energy correction per atom per (CO3)2- anion CARBONATE_CORRECTION Source code in rxn_network/entries/corrections.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 def __init__ ( self , num_ions , carbonate_correction = CARBONATE_CORRECTION ): \"\"\" Initalizes a carbonate correction object Args: num_ions (int): Number of carbonate ions in the composition object carbonate_correction (float): Energy correction per atom per (CO3)2- anion \"\"\" self . _num_ions = num_ions self . _carbonate_correction = carbonate_correction super () . __init__ ( adj_per_atom = carbonate_correction , n_atoms = num_ions , name = \"Carbonate Correction\" , description = ( \"Correction for dGf with (CO3)2- anion, as fit to MP data (300 K).\" ), )","title":"__init__()"},{"location":"reference/entries/corrections/#rxn_network.entries.corrections.CarbonateCorrection.carbonate_correction","text":"Energy correction for carbonate ion, eV per (CO3)2- anion Source code in rxn_network/entries/corrections.py 44 45 46 47 48 49 @property def carbonate_correction ( self ): \"\"\" Energy correction for carbonate ion, eV per (CO3)2- anion \"\"\" return self . _carbonate_correction","title":"carbonate_correction()"},{"location":"reference/entries/corrections/#rxn_network.entries.corrections.CarbonateCorrection.num_ions","text":"Number of carbonate ions ion the composition object Source code in rxn_network/entries/corrections.py 37 38 39 40 41 42 @property def num_ions ( self ): \"\"\" Number of carbonate ions ion the composition object \"\"\" return self . _num_ions","title":"num_ions()"},{"location":"reference/entries/entry_set/","text":"An entry set class for automatically building GibbsComputedEntry objects. Some of this code has been adapted from the EntrySet class in pymatgen. GibbsEntrySet Bases: collections . abc . MutableSet , MSONable This object is based on pymatgen's EntrySet class and includes factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects. It also offers convenient methods for acquiring entries from the entry set, whether that be using composition, stability, chemical system, etc. Source code in rxn_network/entries/entry_set.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 class GibbsEntrySet ( collections . abc . MutableSet , MSONable ): \"\"\" This object is based on pymatgen's EntrySet class and includes factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects. It also offers convenient methods for acquiring entries from the entry set, whether that be using composition, stability, chemical system, etc. \"\"\" def __init__ ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]], calculate_e_above_hulls : bool = False , minimize_obj_size : bool = False , ): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. calculate_e_above_hulls: Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. minimize_object_size: Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). \"\"\" self . entries = set ( entries ) self . calculate_e_above_hulls = calculate_e_above_hulls self . minimize_obj_size = minimize_obj_size if minimize_obj_size : for e in self . entries : e . parameters = {} e . data = {} if calculate_e_above_hulls : for e in self . entries : e . data [ \"e_above_hull\" ] = self . get_e_above_hull ( e ) def __contains__ ( self , item ): return item in self . entries def __iter__ ( self ): return self . entries . __iter__ () def __len__ ( self ): return len ( self . entries ) def add ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Add an entry to the set. Args: entry: An entry object. \"\"\" self . entries . add ( entry ) self . _clear_cache () def update ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] ): \"\"\" Add an iterable of entries to the set. Args: entry: An iterable of entry objects. \"\"\" self . entries . update ( entries ) self . _clear_cache () def discard ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Discard an entry. :param element: Entry \"\"\" self . entries . discard ( entry ) self . _clear_cache () @cached_property def pd_dict ( self ): \"\"\" Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. \"\"\" return expand_pd ( self . entries ) def get_subset_in_chemsys ( self , chemsys : List [ str ]) -> \"GibbsEntrySet\" : \"\"\" Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Args: chemsys: Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] Returns: GibbsEntrySet \"\"\" chem_sys = set ( chemsys ) if not chem_sys . issubset ( self . chemsys ): raise ValueError ( f \" { chem_sys } is not a subset of { self . chemsys } \" ) subset = set () for e in self . entries : elements = [ sp . symbol for sp in e . composition . keys ()] if chem_sys . issuperset ( elements ): subset . add ( e ) return GibbsEntrySet ( subset , calculate_e_above_hulls = False ) def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = self . pd_dict filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = {} for _ , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries )) def build_indices ( self ): \"\"\" Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: None \"\"\" for idx , e in enumerate ( self . entries_list ): e . data . update ({ \"idx\" : idx }) def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" return self . min_entries_by_formula [ Composition ( formula ) . reduced_formula ] def get_stabilized_entry ( self , entry : ComputedEntry , tol : float = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" e_above_hull = None if hasattr ( entry , \"data\" ): e_above_hull = entry . data . get ( \"e_above_hull\" ) if e_above_hull is None : e_above_hull = self . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * e_above_hull * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that entry is on the convex hull\" , ) new_entry = self . get_adjusted_entry ( entry , adjustment ) return new_entry @deprecated ( get_stabilized_entry , \"This method has been renamed. Use get_stabilized_entry instead.\" , ) def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" This method is deprecated. Use get_stabilized_entry instead. \"\"\" return self . get_stabilized_entry ( entry , tol ) def get_entries_with_jitter ( self ) -> \"GibbsEntrySet\" : \"\"\" Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Args: None Returns: A new GibbsEntrySet with entries that have had their energies shifted by random noise. \"\"\" entries = deepcopy ( self . entries_list ) new_entries = [] jitter = normal ( size = len ( entries )) for idx , entry in enumerate ( entries ): if entry . is_element : continue adj = ConstantEnergyAdjustment ( value = jitter [ idx ] * entry . correction_uncertainty , name = \"Random jitter\" , description = \"Randomly sampled noise to account for uncertainty in data\" , ) new_entries . append ( self . get_adjusted_entry ( entry , adj )) return GibbsEntrySet ( new_entries ) def get_interpolated_entry ( self , formula : str , tol_per_atom = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for interpolating an entry from the entry set. Args: formula: The chemical formula of the desired entry. Returns: An interpolated GibbsComputedEntry object. \"\"\" comp = Composition ( formula ) . reduced_composition pd_entries = self . get_subset_in_chemsys ([ str ( e ) for e in comp . elements ]) energy = ( PhaseDiagram ( pd_entries ) . get_hull_energy ( comp ) - tol_per_atom * comp . num_atoms ) adj = ConstantEnergyAdjustment ( # for keeping track of uncertainty value = 0.0 , uncertainty = 0.05 * comp . num_atoms , # conservative: 50 meV/atom uncertainty name = \"Interpolation adjustment\" , description = \"Keeps track of uncertainty in interpolation\" , ) return InterpolatedEntry ( comp , energy , energy_adjustments = [ adj ], entry_id = f \"(Interpolated Entry: { comp . formula } )\" , ) def get_e_above_hull ( self , entry : ComputedEntry ) -> float : \"\"\" Helper method for calculating the energy above hull for a single entry. Args: entry: A ComputedEntry object. Returns: The energy above hull for the entry. \"\"\" e_above_hull = None for chemsys , pd in self . pd_dict . items (): elems_pd = set ( chemsys . split ( \"-\" )) elems_entry = set ( entry . composition . chemical_system . split ( \"-\" )) if elems_entry . issubset ( elems_pd ): e_above_hull = pd . get_e_above_hull ( entry ) return e_above_hull raise ValueError ( \"Entry not in any of the phase diagrams in pd_dict!\" ) @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] experimental_formulas = [] if include_barin_data : warnings . warn ( \"##### WARNING ##### \\n\\n \" \"Barin experimental data was acquired through optical character\" \"recognition and has not been verified. Use at your own risk! \\n\\n \" \"##### WARNING #####\" ) for entry in pd . all_entries : composition = entry . composition formula = composition . reduced_formula if ( composition . is_element and entry not in pd . el_refs . values () or formula in experimental_formulas ): continue new_entries = [] new_entry = None if include_nist_data : new_entry = cls . _check_for_experimental ( formula , \"nist\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_barin_data : new_entry = cls . _check_for_experimental ( formula , \"barin\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_freed_data : new_entry = cls . _check_for_experimental ( formula , \"freed\" , temperature ) if new_entry : new_entries . append ( new_entry ) if new_entry : experimental_formulas . append ( formula ) else : corr = None if apply_carbonate_correction : corr = cls . _get_carbonate_correction ( entry ) energy_adjustments = [ corr ] if corr else None structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) gibbs_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = energy_adjustments , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) new_entries . append ( gibbs_entry ) gibbs_entries . extend ( new_entries ) return cls ( gibbs_entries , minimize_obj_size = minimize_obj_size ) @classmethod def from_computed_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) pd_dict = expand_pd ( list ( e_set )) logger . info ( \"Building entries from expanded phase diagrams...\" ) for _ , pd in tqdm ( pd_dict . items (), desc = \"GibbsComputedEntry\" ): gibbs_set = cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries )) @classmethod def from_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" This method is deprecated. Use from_computed_entries instead. \"\"\" warnings . warn ( \"This method is deprecated. Use from_computed_entries instead.\" , category = FutureWarning , ) return cls . from_computed_entries ( entries , temperature , include_nist_data , include_barin_data , include_freed_data , apply_carbonate_correction , minimize_obj_size , ) @cached_property def entries_list ( self ) -> List [ ComputedEntry ]: \"\"\"Returns a list of all entries in the entry set.\"\"\" return list ( sorted ( self . entries , key = lambda e : e . composition )) @cached_property def min_entries_by_formula ( self ) -> Dict [ str , ComputedEntry ]: \"\"\" Returns a dict of minimum energy entries in the entry set, indexed by formula. \"\"\" min_entries = {} for e in self . entries : formula = e . composition . reduced_formula if formula not in min_entries : entries = filter ( lambda x : x . composition . reduced_formula == formula , self . entries ) min_entries [ formula ] = sorted ( entries , key = lambda x : x . energy_per_atom )[ 0 ] return min_entries @property def chemsys ( self ) -> set : \"\"\" Returns: set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} \"\"\" chemsys = set () for e in self . entries : chemsys . update ([ el . symbol for el in e . composition . keys ()]) return chemsys def copy ( self ) -> \"GibbsEntrySet\" : \"\"\"Returns a copy of the entry set.\"\"\" return GibbsEntrySet ( entries = self . entries , calculate_e_above_hulls = False ) def as_dict ( self ) -> dict : \"\"\" Returns: JSON serializable dict representation of the entry set. \"\"\" d = super () . as_dict () d [ \"entries\" ] = [ e . as_dict () for e in self . entries ] d [ \"calculate_e_above_hulls\" ] = self . calculate_e_above_hulls return d @staticmethod def _check_for_experimental ( formula : str , cls_name : str , temperature : float ): cls_name = cls_name . lower () if cls_name in ( \"nist\" , \"nistreferenceentry\" ): cl = NISTReferenceEntry elif cls_name in ( \"barin\" , \"barinreferenceentry\" ): cl = BarinReferenceEntry elif cls_name in ( \"freed\" , \"freedreferenceentry\" ): cl = FREEDReferenceEntry else : raise ValueError ( \"Invalid class name for experimental reference entry.\" ) entry = None if formula in cl . REFERENCES : try : entry = cl ( composition = Composition ( formula ), temperature = temperature ) except ValueError as error : logger . debug ( f \"Compound { formula } is in { cl } tables but at different\" f \" temperatures!: { error } \" ) return entry @staticmethod def _get_carbonate_correction ( entry ): \"\"\" Helper method for determining the carbonate correction for an entry. WARNING: Correction has been fit only to MP-derived entries (i.e., entries run with MP input sets). Please check that the correction is valid for your entry. \"\"\" comp = entry . composition if not { Element ( \"C\" ), Element ( \"O\" )} . issubset ( comp . elements ): # Skip phases that don't contain C and O return None # only correct GGA or GGA+U entries if entry . parameters . get ( \"run_type\" , None ) not in [ \"GGA\" , \"GGA+U\" ]: return None # Check for number of carbonate ions el_amts = comp . get_el_amt_dict () num_c = el_amts . get ( \"C\" , 0 ) num_o = el_amts . get ( \"O\" , 0 ) if num_c == 0 or num_o == 0 : return None if not math . isclose ( num_o / num_c , 3 ): return None return CarbonateCorrection ( num_c ) @staticmethod def get_adjusted_entry ( entry , adjustment ): entry_dict = entry . as_dict () original_entry = entry_dict . get ( \"entry\" , None ) if original_entry : energy_adjustments = original_entry [ \"energy_adjustments\" ] else : energy_adjustments = entry_dict [ \"energy_adjustments\" ] energy_adjustments . append ( adjustment . as_dict ()) new_entry = MontyDecoder () . process_decoded ( entry_dict ) return new_entry def _clear_cache ( self ): \"\"\" Clears cached properties. \"\"\" try : del self . entries_list except AttributeError : pass try : del self . pd_dict except AttributeError : pass try : del self . min_entries_by_formula except AttributeError : pass __init__ ( entries , calculate_e_above_hulls = False , minimize_obj_size = False ) The supplied collection of entries will automatically be converted to a set of unique entries. Parameters: Name Type Description Default entries Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] A collection of entry objects that will make up the entry set. required calculate_e_above_hulls bool Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. False minimize_object_size Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). required Source code in rxn_network/entries/entry_set.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]], calculate_e_above_hulls : bool = False , minimize_obj_size : bool = False , ): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. calculate_e_above_hulls: Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. minimize_object_size: Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). \"\"\" self . entries = set ( entries ) self . calculate_e_above_hulls = calculate_e_above_hulls self . minimize_obj_size = minimize_obj_size if minimize_obj_size : for e in self . entries : e . parameters = {} e . data = {} if calculate_e_above_hulls : for e in self . entries : e . data [ \"e_above_hull\" ] = self . get_e_above_hull ( e ) add ( entry ) Add an entry to the set. Parameters: Name Type Description Default entry Union [ GibbsComputedEntry , ExperimentalReferenceEntry ] An entry object. required Source code in rxn_network/entries/entry_set.py 86 87 88 89 90 91 92 93 94 def add ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Add an entry to the set. Args: entry: An entry object. \"\"\" self . entries . add ( entry ) self . _clear_cache () as_dict () Returns: Type Description dict JSON serializable dict representation of the entry set. Source code in rxn_network/entries/entry_set.py 569 570 571 572 573 574 575 576 577 def as_dict ( self ) -> dict : \"\"\" Returns: JSON serializable dict representation of the entry set. \"\"\" d = super () . as_dict () d [ \"entries\" ] = [ e . as_dict () for e in self . entries ] d [ \"calculate_e_above_hulls\" ] = self . calculate_e_above_hulls return d build_indices () Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: Type Description None Source code in rxn_network/entries/entry_set.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def build_indices ( self ): \"\"\" Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: None \"\"\" for idx , e in enumerate ( self . entries_list ): e . data . update ({ \"idx\" : idx }) chemsys () property Returns: Type Description set set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} Source code in rxn_network/entries/entry_set.py 554 555 556 557 558 559 560 561 562 563 @property def chemsys ( self ) -> set : \"\"\" Returns: set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} \"\"\" chemsys = set () for e in self . entries : chemsys . update ([ el . symbol for el in e . composition . keys ()]) return chemsys copy () Returns a copy of the entry set. Source code in rxn_network/entries/entry_set.py 565 566 567 def copy ( self ) -> \"GibbsEntrySet\" : \"\"\"Returns a copy of the entry set.\"\"\" return GibbsEntrySet ( entries = self . entries , calculate_e_above_hulls = False ) discard ( entry ) Discard an entry. :param element: Entry Source code in rxn_network/entries/entry_set.py 108 109 110 111 112 113 114 115 def discard ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Discard an entry. :param element: Entry \"\"\" self . entries . discard ( entry ) self . _clear_cache () entries_list () property cached Returns a list of all entries in the entry set. Source code in rxn_network/entries/entry_set.py 530 531 532 533 @cached_property def entries_list ( self ) -> List [ ComputedEntry ]: \"\"\"Returns a list of all entries in the entry set.\"\"\" return list ( sorted ( self . entries , key = lambda e : e . composition )) filter_by_stability ( e_above_hull , include_polymorphs = False ) Filter the entry set by a metastability (energy above hull) cutoff. Parameters: Name Type Description Default e_above_hull float Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. required include_polymorphs Optional [ bool ] optional specification of whether to include metastable polymorphs. Defaults to False. False Returns: Type Description GibbsEntrySet A new GibbsEntrySet where the entries have been filtered by an energy GibbsEntrySet cutoff (e_above_hull) via phase diagram construction. Source code in rxn_network/entries/entry_set.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = self . pd_dict filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = {} for _ , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries )) from_computed_entries ( entries , temperature , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False ) classmethod Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Parameters: Name Type Description Default entries Iterable [ ComputedStructureEntry ] List of ComputedStructureEntry objects, as downloaded from The Materials Project API. required temperature float Temperature for estimating Gibbs free energy of formation [K] required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and GibbsEntrySet experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 @classmethod def from_computed_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) pd_dict = expand_pd ( list ( e_set )) logger . info ( \"Building entries from expanded phase diagrams...\" ) for _ , pd in tqdm ( pd_dict . items (), desc = \"GibbsComputedEntry\" ): gibbs_set = cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries )) from_entries ( entries , temperature , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False ) classmethod This method is deprecated. Use from_computed_entries instead. Source code in rxn_network/entries/entry_set.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 @classmethod def from_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" This method is deprecated. Use from_computed_entries instead. \"\"\" warnings . warn ( \"This method is deprecated. Use from_computed_entries instead.\" , category = FutureWarning , ) return cls . from_computed_entries ( entries , temperature , include_nist_data , include_barin_data , include_freed_data , apply_carbonate_correction , minimize_obj_size , ) from_pd ( pd , temperature , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False ) classmethod Constructor method for building a GibbsEntrySet from an existing phase diagram. Parameters: Name Type Description Default pd PhaseDiagram Phase Diagram object (pymatgen) required temperature float Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) required include_nist_data Whether to include NIST data in the entry set. True include_barin_data Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. False Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and GibbsEntrySet experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] experimental_formulas = [] if include_barin_data : warnings . warn ( \"##### WARNING ##### \\n\\n \" \"Barin experimental data was acquired through optical character\" \"recognition and has not been verified. Use at your own risk! \\n\\n \" \"##### WARNING #####\" ) for entry in pd . all_entries : composition = entry . composition formula = composition . reduced_formula if ( composition . is_element and entry not in pd . el_refs . values () or formula in experimental_formulas ): continue new_entries = [] new_entry = None if include_nist_data : new_entry = cls . _check_for_experimental ( formula , \"nist\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_barin_data : new_entry = cls . _check_for_experimental ( formula , \"barin\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_freed_data : new_entry = cls . _check_for_experimental ( formula , \"freed\" , temperature ) if new_entry : new_entries . append ( new_entry ) if new_entry : experimental_formulas . append ( formula ) else : corr = None if apply_carbonate_correction : corr = cls . _get_carbonate_correction ( entry ) energy_adjustments = [ corr ] if corr else None structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) gibbs_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = energy_adjustments , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) new_entries . append ( gibbs_entry ) gibbs_entries . extend ( new_entries ) return cls ( gibbs_entries , minimize_obj_size = minimize_obj_size ) get_e_above_hull ( entry ) Helper method for calculating the energy above hull for a single entry. Parameters: Name Type Description Default entry ComputedEntry A ComputedEntry object. required Returns: Type Description float The energy above hull for the entry. Source code in rxn_network/entries/entry_set.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def get_e_above_hull ( self , entry : ComputedEntry ) -> float : \"\"\" Helper method for calculating the energy above hull for a single entry. Args: entry: A ComputedEntry object. Returns: The energy above hull for the entry. \"\"\" e_above_hull = None for chemsys , pd in self . pd_dict . items (): elems_pd = set ( chemsys . split ( \"-\" )) elems_entry = set ( entry . composition . chemical_system . split ( \"-\" )) if elems_entry . issubset ( elems_pd ): e_above_hull = pd . get_e_above_hull ( entry ) return e_above_hull raise ValueError ( \"Entry not in any of the phase diagrams in pd_dict!\" ) get_entries_with_jitter () Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Returns: Type Description GibbsEntrySet A new GibbsEntrySet with entries that have had their energies shifted by GibbsEntrySet random noise. Source code in rxn_network/entries/entry_set.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def get_entries_with_jitter ( self ) -> \"GibbsEntrySet\" : \"\"\" Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Args: None Returns: A new GibbsEntrySet with entries that have had their energies shifted by random noise. \"\"\" entries = deepcopy ( self . entries_list ) new_entries = [] jitter = normal ( size = len ( entries )) for idx , entry in enumerate ( entries ): if entry . is_element : continue adj = ConstantEnergyAdjustment ( value = jitter [ idx ] * entry . correction_uncertainty , name = \"Random jitter\" , description = \"Randomly sampled noise to account for uncertainty in data\" , ) new_entries . append ( self . get_adjusted_entry ( entry , adj )) return GibbsEntrySet ( new_entries ) get_interpolated_entry ( formula , tol_per_atom = 0.001 ) Helper method for interpolating an entry from the entry set. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry An interpolated GibbsComputedEntry object. Source code in rxn_network/entries/entry_set.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def get_interpolated_entry ( self , formula : str , tol_per_atom = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for interpolating an entry from the entry set. Args: formula: The chemical formula of the desired entry. Returns: An interpolated GibbsComputedEntry object. \"\"\" comp = Composition ( formula ) . reduced_composition pd_entries = self . get_subset_in_chemsys ([ str ( e ) for e in comp . elements ]) energy = ( PhaseDiagram ( pd_entries ) . get_hull_energy ( comp ) - tol_per_atom * comp . num_atoms ) adj = ConstantEnergyAdjustment ( # for keeping track of uncertainty value = 0.0 , uncertainty = 0.05 * comp . num_atoms , # conservative: 50 meV/atom uncertainty name = \"Interpolation adjustment\" , description = \"Keeps track of uncertainty in interpolation\" , ) return InterpolatedEntry ( comp , energy , energy_adjustments = [ adj ], entry_id = f \"(Interpolated Entry: { comp . formula } )\" , ) get_min_entry_by_formula ( formula ) Helper method for acquiring the ground state entry with the specified formula. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry Ground state computed entry object. Source code in rxn_network/entries/entry_set.py 206 207 208 209 210 211 212 213 214 215 216 def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" return self . min_entries_by_formula [ Composition ( formula ) . reduced_formula ] get_stabilized_entry ( entry , tol = 0.001 ) Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Parameters: Name Type Description Default entry ComputedEntry A computed entry object. required tol float The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. 0.001 Returns: Type Description ComputedEntry A new ComputedEntry with energy adjustment making it appear to be stable. Source code in rxn_network/entries/entry_set.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def get_stabilized_entry ( self , entry : ComputedEntry , tol : float = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" e_above_hull = None if hasattr ( entry , \"data\" ): e_above_hull = entry . data . get ( \"e_above_hull\" ) if e_above_hull is None : e_above_hull = self . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * e_above_hull * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that entry is on the convex hull\" , ) new_entry = self . get_adjusted_entry ( entry , adjustment ) return new_entry get_subset_in_chemsys ( chemsys ) Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Parameters: Name Type Description Default chemsys List [ str ] Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] required Source code in rxn_network/entries/entry_set.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def get_subset_in_chemsys ( self , chemsys : List [ str ]) -> \"GibbsEntrySet\" : \"\"\" Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Args: chemsys: Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] Returns: GibbsEntrySet \"\"\" chem_sys = set ( chemsys ) if not chem_sys . issubset ( self . chemsys ): raise ValueError ( f \" { chem_sys } is not a subset of { self . chemsys } \" ) subset = set () for e in self . entries : elements = [ sp . symbol for sp in e . composition . keys ()] if chem_sys . issuperset ( elements ): subset . add ( e ) return GibbsEntrySet ( subset , calculate_e_above_hulls = False ) min_entries_by_formula () property cached Returns a dict of minimum energy entries in the entry set, indexed by formula. Source code in rxn_network/entries/entry_set.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @cached_property def min_entries_by_formula ( self ) -> Dict [ str , ComputedEntry ]: \"\"\" Returns a dict of minimum energy entries in the entry set, indexed by formula. \"\"\" min_entries = {} for e in self . entries : formula = e . composition . reduced_formula if formula not in min_entries : entries = filter ( lambda x : x . composition . reduced_formula == formula , self . entries ) min_entries [ formula ] = sorted ( entries , key = lambda x : x . energy_per_atom )[ 0 ] return min_entries pd_dict () property cached Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. Source code in rxn_network/entries/entry_set.py 117 118 119 120 121 122 123 124 @cached_property def pd_dict ( self ): \"\"\" Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. \"\"\" return expand_pd ( self . entries ) stabilize_entry ( entry , tol = 1e-06 ) This method is deprecated. Use get_stabilized_entry instead. Source code in rxn_network/entries/entry_set.py 258 259 260 261 262 263 264 265 266 @deprecated ( get_stabilized_entry , \"This method has been renamed. Use get_stabilized_entry instead.\" , ) def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" This method is deprecated. Use get_stabilized_entry instead. \"\"\" return self . get_stabilized_entry ( entry , tol ) update ( entries ) Add an iterable of entries to the set. Parameters: Name Type Description Default entry An iterable of entry objects. required Source code in rxn_network/entries/entry_set.py 96 97 98 99 100 101 102 103 104 105 106 def update ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] ): \"\"\" Add an iterable of entries to the set. Args: entry: An iterable of entry objects. \"\"\" self . entries . update ( entries ) self . _clear_cache ()","title":"Entry Set"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet","text":"Bases: collections . abc . MutableSet , MSONable This object is based on pymatgen's EntrySet class and includes factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects. It also offers convenient methods for acquiring entries from the entry set, whether that be using composition, stability, chemical system, etc. Source code in rxn_network/entries/entry_set.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 556 557 558 559 560 561 562 563 564 565 566 567 568 569 570 571 572 573 574 575 576 577 578 579 580 581 582 583 584 585 586 587 588 589 590 591 592 593 594 595 596 597 598 599 600 601 602 603 604 605 606 607 608 609 610 611 612 613 614 615 616 617 618 619 620 621 622 623 624 625 626 627 628 629 630 631 632 633 634 635 636 637 638 639 640 641 642 643 644 645 646 647 648 649 650 651 652 653 654 655 656 657 658 659 660 661 662 663 664 665 666 667 class GibbsEntrySet ( collections . abc . MutableSet , MSONable ): \"\"\" This object is based on pymatgen's EntrySet class and includes factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects. It also offers convenient methods for acquiring entries from the entry set, whether that be using composition, stability, chemical system, etc. \"\"\" def __init__ ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]], calculate_e_above_hulls : bool = False , minimize_obj_size : bool = False , ): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. calculate_e_above_hulls: Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. minimize_object_size: Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). \"\"\" self . entries = set ( entries ) self . calculate_e_above_hulls = calculate_e_above_hulls self . minimize_obj_size = minimize_obj_size if minimize_obj_size : for e in self . entries : e . parameters = {} e . data = {} if calculate_e_above_hulls : for e in self . entries : e . data [ \"e_above_hull\" ] = self . get_e_above_hull ( e ) def __contains__ ( self , item ): return item in self . entries def __iter__ ( self ): return self . entries . __iter__ () def __len__ ( self ): return len ( self . entries ) def add ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Add an entry to the set. Args: entry: An entry object. \"\"\" self . entries . add ( entry ) self . _clear_cache () def update ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] ): \"\"\" Add an iterable of entries to the set. Args: entry: An iterable of entry objects. \"\"\" self . entries . update ( entries ) self . _clear_cache () def discard ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Discard an entry. :param element: Entry \"\"\" self . entries . discard ( entry ) self . _clear_cache () @cached_property def pd_dict ( self ): \"\"\" Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. \"\"\" return expand_pd ( self . entries ) def get_subset_in_chemsys ( self , chemsys : List [ str ]) -> \"GibbsEntrySet\" : \"\"\" Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Args: chemsys: Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] Returns: GibbsEntrySet \"\"\" chem_sys = set ( chemsys ) if not chem_sys . issubset ( self . chemsys ): raise ValueError ( f \" { chem_sys } is not a subset of { self . chemsys } \" ) subset = set () for e in self . entries : elements = [ sp . symbol for sp in e . composition . keys ()] if chem_sys . issuperset ( elements ): subset . add ( e ) return GibbsEntrySet ( subset , calculate_e_above_hulls = False ) def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = self . pd_dict filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = {} for _ , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries )) def build_indices ( self ): \"\"\" Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: None \"\"\" for idx , e in enumerate ( self . entries_list ): e . data . update ({ \"idx\" : idx }) def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" return self . min_entries_by_formula [ Composition ( formula ) . reduced_formula ] def get_stabilized_entry ( self , entry : ComputedEntry , tol : float = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" e_above_hull = None if hasattr ( entry , \"data\" ): e_above_hull = entry . data . get ( \"e_above_hull\" ) if e_above_hull is None : e_above_hull = self . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * e_above_hull * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that entry is on the convex hull\" , ) new_entry = self . get_adjusted_entry ( entry , adjustment ) return new_entry @deprecated ( get_stabilized_entry , \"This method has been renamed. Use get_stabilized_entry instead.\" , ) def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" This method is deprecated. Use get_stabilized_entry instead. \"\"\" return self . get_stabilized_entry ( entry , tol ) def get_entries_with_jitter ( self ) -> \"GibbsEntrySet\" : \"\"\" Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Args: None Returns: A new GibbsEntrySet with entries that have had their energies shifted by random noise. \"\"\" entries = deepcopy ( self . entries_list ) new_entries = [] jitter = normal ( size = len ( entries )) for idx , entry in enumerate ( entries ): if entry . is_element : continue adj = ConstantEnergyAdjustment ( value = jitter [ idx ] * entry . correction_uncertainty , name = \"Random jitter\" , description = \"Randomly sampled noise to account for uncertainty in data\" , ) new_entries . append ( self . get_adjusted_entry ( entry , adj )) return GibbsEntrySet ( new_entries ) def get_interpolated_entry ( self , formula : str , tol_per_atom = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for interpolating an entry from the entry set. Args: formula: The chemical formula of the desired entry. Returns: An interpolated GibbsComputedEntry object. \"\"\" comp = Composition ( formula ) . reduced_composition pd_entries = self . get_subset_in_chemsys ([ str ( e ) for e in comp . elements ]) energy = ( PhaseDiagram ( pd_entries ) . get_hull_energy ( comp ) - tol_per_atom * comp . num_atoms ) adj = ConstantEnergyAdjustment ( # for keeping track of uncertainty value = 0.0 , uncertainty = 0.05 * comp . num_atoms , # conservative: 50 meV/atom uncertainty name = \"Interpolation adjustment\" , description = \"Keeps track of uncertainty in interpolation\" , ) return InterpolatedEntry ( comp , energy , energy_adjustments = [ adj ], entry_id = f \"(Interpolated Entry: { comp . formula } )\" , ) def get_e_above_hull ( self , entry : ComputedEntry ) -> float : \"\"\" Helper method for calculating the energy above hull for a single entry. Args: entry: A ComputedEntry object. Returns: The energy above hull for the entry. \"\"\" e_above_hull = None for chemsys , pd in self . pd_dict . items (): elems_pd = set ( chemsys . split ( \"-\" )) elems_entry = set ( entry . composition . chemical_system . split ( \"-\" )) if elems_entry . issubset ( elems_pd ): e_above_hull = pd . get_e_above_hull ( entry ) return e_above_hull raise ValueError ( \"Entry not in any of the phase diagrams in pd_dict!\" ) @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] experimental_formulas = [] if include_barin_data : warnings . warn ( \"##### WARNING ##### \\n\\n \" \"Barin experimental data was acquired through optical character\" \"recognition and has not been verified. Use at your own risk! \\n\\n \" \"##### WARNING #####\" ) for entry in pd . all_entries : composition = entry . composition formula = composition . reduced_formula if ( composition . is_element and entry not in pd . el_refs . values () or formula in experimental_formulas ): continue new_entries = [] new_entry = None if include_nist_data : new_entry = cls . _check_for_experimental ( formula , \"nist\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_barin_data : new_entry = cls . _check_for_experimental ( formula , \"barin\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_freed_data : new_entry = cls . _check_for_experimental ( formula , \"freed\" , temperature ) if new_entry : new_entries . append ( new_entry ) if new_entry : experimental_formulas . append ( formula ) else : corr = None if apply_carbonate_correction : corr = cls . _get_carbonate_correction ( entry ) energy_adjustments = [ corr ] if corr else None structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) gibbs_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = energy_adjustments , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) new_entries . append ( gibbs_entry ) gibbs_entries . extend ( new_entries ) return cls ( gibbs_entries , minimize_obj_size = minimize_obj_size ) @classmethod def from_computed_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) pd_dict = expand_pd ( list ( e_set )) logger . info ( \"Building entries from expanded phase diagrams...\" ) for _ , pd in tqdm ( pd_dict . items (), desc = \"GibbsComputedEntry\" ): gibbs_set = cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries )) @classmethod def from_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" This method is deprecated. Use from_computed_entries instead. \"\"\" warnings . warn ( \"This method is deprecated. Use from_computed_entries instead.\" , category = FutureWarning , ) return cls . from_computed_entries ( entries , temperature , include_nist_data , include_barin_data , include_freed_data , apply_carbonate_correction , minimize_obj_size , ) @cached_property def entries_list ( self ) -> List [ ComputedEntry ]: \"\"\"Returns a list of all entries in the entry set.\"\"\" return list ( sorted ( self . entries , key = lambda e : e . composition )) @cached_property def min_entries_by_formula ( self ) -> Dict [ str , ComputedEntry ]: \"\"\" Returns a dict of minimum energy entries in the entry set, indexed by formula. \"\"\" min_entries = {} for e in self . entries : formula = e . composition . reduced_formula if formula not in min_entries : entries = filter ( lambda x : x . composition . reduced_formula == formula , self . entries ) min_entries [ formula ] = sorted ( entries , key = lambda x : x . energy_per_atom )[ 0 ] return min_entries @property def chemsys ( self ) -> set : \"\"\" Returns: set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} \"\"\" chemsys = set () for e in self . entries : chemsys . update ([ el . symbol for el in e . composition . keys ()]) return chemsys def copy ( self ) -> \"GibbsEntrySet\" : \"\"\"Returns a copy of the entry set.\"\"\" return GibbsEntrySet ( entries = self . entries , calculate_e_above_hulls = False ) def as_dict ( self ) -> dict : \"\"\" Returns: JSON serializable dict representation of the entry set. \"\"\" d = super () . as_dict () d [ \"entries\" ] = [ e . as_dict () for e in self . entries ] d [ \"calculate_e_above_hulls\" ] = self . calculate_e_above_hulls return d @staticmethod def _check_for_experimental ( formula : str , cls_name : str , temperature : float ): cls_name = cls_name . lower () if cls_name in ( \"nist\" , \"nistreferenceentry\" ): cl = NISTReferenceEntry elif cls_name in ( \"barin\" , \"barinreferenceentry\" ): cl = BarinReferenceEntry elif cls_name in ( \"freed\" , \"freedreferenceentry\" ): cl = FREEDReferenceEntry else : raise ValueError ( \"Invalid class name for experimental reference entry.\" ) entry = None if formula in cl . REFERENCES : try : entry = cl ( composition = Composition ( formula ), temperature = temperature ) except ValueError as error : logger . debug ( f \"Compound { formula } is in { cl } tables but at different\" f \" temperatures!: { error } \" ) return entry @staticmethod def _get_carbonate_correction ( entry ): \"\"\" Helper method for determining the carbonate correction for an entry. WARNING: Correction has been fit only to MP-derived entries (i.e., entries run with MP input sets). Please check that the correction is valid for your entry. \"\"\" comp = entry . composition if not { Element ( \"C\" ), Element ( \"O\" )} . issubset ( comp . elements ): # Skip phases that don't contain C and O return None # only correct GGA or GGA+U entries if entry . parameters . get ( \"run_type\" , None ) not in [ \"GGA\" , \"GGA+U\" ]: return None # Check for number of carbonate ions el_amts = comp . get_el_amt_dict () num_c = el_amts . get ( \"C\" , 0 ) num_o = el_amts . get ( \"O\" , 0 ) if num_c == 0 or num_o == 0 : return None if not math . isclose ( num_o / num_c , 3 ): return None return CarbonateCorrection ( num_c ) @staticmethod def get_adjusted_entry ( entry , adjustment ): entry_dict = entry . as_dict () original_entry = entry_dict . get ( \"entry\" , None ) if original_entry : energy_adjustments = original_entry [ \"energy_adjustments\" ] else : energy_adjustments = entry_dict [ \"energy_adjustments\" ] energy_adjustments . append ( adjustment . as_dict ()) new_entry = MontyDecoder () . process_decoded ( entry_dict ) return new_entry def _clear_cache ( self ): \"\"\" Clears cached properties. \"\"\" try : del self . entries_list except AttributeError : pass try : del self . pd_dict except AttributeError : pass try : del self . min_entries_by_formula except AttributeError : pass","title":"GibbsEntrySet"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.__init__","text":"The supplied collection of entries will automatically be converted to a set of unique entries. Parameters: Name Type Description Default entries Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] A collection of entry objects that will make up the entry set. required calculate_e_above_hulls bool Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. False minimize_object_size Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). required Source code in rxn_network/entries/entry_set.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def __init__ ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]], calculate_e_above_hulls : bool = False , minimize_obj_size : bool = False , ): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. calculate_e_above_hulls: Whether to pre-calculate the energy above hull for each entry and store that in that entry's data. minimize_object_size: Whether to reduce the size of the entry set by removing metadata from each entry. This may be useful when working with entry sets (or ComputedReaction sets). \"\"\" self . entries = set ( entries ) self . calculate_e_above_hulls = calculate_e_above_hulls self . minimize_obj_size = minimize_obj_size if minimize_obj_size : for e in self . entries : e . parameters = {} e . data = {} if calculate_e_above_hulls : for e in self . entries : e . data [ \"e_above_hull\" ] = self . get_e_above_hull ( e )","title":"__init__()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.add","text":"Add an entry to the set. Parameters: Name Type Description Default entry Union [ GibbsComputedEntry , ExperimentalReferenceEntry ] An entry object. required Source code in rxn_network/entries/entry_set.py 86 87 88 89 90 91 92 93 94 def add ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Add an entry to the set. Args: entry: An entry object. \"\"\" self . entries . add ( entry ) self . _clear_cache ()","title":"add()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.as_dict","text":"Returns: Type Description dict JSON serializable dict representation of the entry set. Source code in rxn_network/entries/entry_set.py 569 570 571 572 573 574 575 576 577 def as_dict ( self ) -> dict : \"\"\" Returns: JSON serializable dict representation of the entry set. \"\"\" d = super () . as_dict () d [ \"entries\" ] = [ e . as_dict () for e in self . entries ] d [ \"calculate_e_above_hulls\" ] = self . calculate_e_above_hulls return d","title":"as_dict()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.build_indices","text":"Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: Type Description None Source code in rxn_network/entries/entry_set.py 191 192 193 194 195 196 197 198 199 200 201 202 203 204 def build_indices ( self ): \"\"\" Builds the indices for the entry set. This method is called whenever an entry is added/removed the entry set. The entry indices are useful for querying the entry set for specific entries. Warning: this internally modifies the entries in the entry set by updating data for each entry to include the index. Returns: None \"\"\" for idx , e in enumerate ( self . entries_list ): e . data . update ({ \"idx\" : idx })","title":"build_indices()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.chemsys","text":"Returns: Type Description set set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} Source code in rxn_network/entries/entry_set.py 554 555 556 557 558 559 560 561 562 563 @property def chemsys ( self ) -> set : \"\"\" Returns: set representing the chemical system, e.g., {\"Li\", \"Fe\", \"P\", \"O\"} \"\"\" chemsys = set () for e in self . entries : chemsys . update ([ el . symbol for el in e . composition . keys ()]) return chemsys","title":"chemsys()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.copy","text":"Returns a copy of the entry set. Source code in rxn_network/entries/entry_set.py 565 566 567 def copy ( self ) -> \"GibbsEntrySet\" : \"\"\"Returns a copy of the entry set.\"\"\" return GibbsEntrySet ( entries = self . entries , calculate_e_above_hulls = False )","title":"copy()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.discard","text":"Discard an entry. :param element: Entry Source code in rxn_network/entries/entry_set.py 108 109 110 111 112 113 114 115 def discard ( self , entry : Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]): \"\"\" Discard an entry. :param element: Entry \"\"\" self . entries . discard ( entry ) self . _clear_cache ()","title":"discard()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.entries_list","text":"Returns a list of all entries in the entry set. Source code in rxn_network/entries/entry_set.py 530 531 532 533 @cached_property def entries_list ( self ) -> List [ ComputedEntry ]: \"\"\"Returns a list of all entries in the entry set.\"\"\" return list ( sorted ( self . entries , key = lambda e : e . composition ))","title":"entries_list()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.filter_by_stability","text":"Filter the entry set by a metastability (energy above hull) cutoff. Parameters: Name Type Description Default e_above_hull float Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. required include_polymorphs Optional [ bool ] optional specification of whether to include metastable polymorphs. Defaults to False. False Returns: Type Description GibbsEntrySet A new GibbsEntrySet where the entries have been filtered by an energy GibbsEntrySet cutoff (e_above_hull) via phase diagram construction. Source code in rxn_network/entries/entry_set.py 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = self . pd_dict filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = {} for _ , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries ))","title":"filter_by_stability()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.from_computed_entries","text":"Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Parameters: Name Type Description Default entries Iterable [ ComputedStructureEntry ] List of ComputedStructureEntry objects, as downloaded from The Materials Project API. required temperature float Temperature for estimating Gibbs free energy of formation [K] required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and GibbsEntrySet experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 @classmethod def from_computed_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) pd_dict = expand_pd ( list ( e_set )) logger . info ( \"Building entries from expanded phase diagrams...\" ) for _ , pd in tqdm ( pd_dict . items (), desc = \"GibbsComputedEntry\" ): gibbs_set = cls . from_pd ( pd , temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , apply_carbonate_correction = apply_carbonate_correction , minimize_obj_size = minimize_obj_size , ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries ))","title":"from_computed_entries()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.from_entries","text":"This method is deprecated. Use from_computed_entries instead. Source code in rxn_network/entries/entry_set.py 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 @classmethod def from_entries ( cls , entries : Iterable [ ComputedStructureEntry ], temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" This method is deprecated. Use from_computed_entries instead. \"\"\" warnings . warn ( \"This method is deprecated. Use from_computed_entries instead.\" , category = FutureWarning , ) return cls . from_computed_entries ( entries , temperature , include_nist_data , include_barin_data , include_freed_data , apply_carbonate_correction , minimize_obj_size , )","title":"from_entries()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.from_pd","text":"Constructor method for building a GibbsEntrySet from an existing phase diagram. Parameters: Name Type Description Default pd PhaseDiagram Phase Diagram object (pymatgen) required temperature float Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) required include_nist_data Whether to include NIST data in the entry set. True include_barin_data Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. False Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and GibbsEntrySet experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float , include_nist_data = True , include_barin_data = False , include_freed_data = False , apply_carbonate_correction = True , minimize_obj_size = False , ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. Defaults to False. Warning: Barin data has not been verified. Use with caution. Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] experimental_formulas = [] if include_barin_data : warnings . warn ( \"##### WARNING ##### \\n\\n \" \"Barin experimental data was acquired through optical character\" \"recognition and has not been verified. Use at your own risk! \\n\\n \" \"##### WARNING #####\" ) for entry in pd . all_entries : composition = entry . composition formula = composition . reduced_formula if ( composition . is_element and entry not in pd . el_refs . values () or formula in experimental_formulas ): continue new_entries = [] new_entry = None if include_nist_data : new_entry = cls . _check_for_experimental ( formula , \"nist\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_barin_data : new_entry = cls . _check_for_experimental ( formula , \"barin\" , temperature ) if new_entry : new_entries . append ( new_entry ) if include_freed_data : new_entry = cls . _check_for_experimental ( formula , \"freed\" , temperature ) if new_entry : new_entries . append ( new_entry ) if new_entry : experimental_formulas . append ( formula ) else : corr = None if apply_carbonate_correction : corr = cls . _get_carbonate_correction ( entry ) energy_adjustments = [ corr ] if corr else None structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) gibbs_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = energy_adjustments , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) new_entries . append ( gibbs_entry ) gibbs_entries . extend ( new_entries ) return cls ( gibbs_entries , minimize_obj_size = minimize_obj_size )","title":"from_pd()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_e_above_hull","text":"Helper method for calculating the energy above hull for a single entry. Parameters: Name Type Description Default entry ComputedEntry A ComputedEntry object. required Returns: Type Description float The energy above hull for the entry. Source code in rxn_network/entries/entry_set.py 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 def get_e_above_hull ( self , entry : ComputedEntry ) -> float : \"\"\" Helper method for calculating the energy above hull for a single entry. Args: entry: A ComputedEntry object. Returns: The energy above hull for the entry. \"\"\" e_above_hull = None for chemsys , pd in self . pd_dict . items (): elems_pd = set ( chemsys . split ( \"-\" )) elems_entry = set ( entry . composition . chemical_system . split ( \"-\" )) if elems_entry . issubset ( elems_pd ): e_above_hull = pd . get_e_above_hull ( entry ) return e_above_hull raise ValueError ( \"Entry not in any of the phase diagrams in pd_dict!\" )","title":"get_e_above_hull()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_entries_with_jitter","text":"Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Returns: Type Description GibbsEntrySet A new GibbsEntrySet with entries that have had their energies shifted by GibbsEntrySet random noise. Source code in rxn_network/entries/entry_set.py 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 def get_entries_with_jitter ( self ) -> \"GibbsEntrySet\" : \"\"\" Returns a new GibbsEntrySet with entries that have had their energies shifted by randomly sampled noise to account for uncertainty in data. This is done by sampling from a Gaussian distribution using the entry's \"correction_uncertainty\" attribute as the scale. Args: None Returns: A new GibbsEntrySet with entries that have had their energies shifted by random noise. \"\"\" entries = deepcopy ( self . entries_list ) new_entries = [] jitter = normal ( size = len ( entries )) for idx , entry in enumerate ( entries ): if entry . is_element : continue adj = ConstantEnergyAdjustment ( value = jitter [ idx ] * entry . correction_uncertainty , name = \"Random jitter\" , description = \"Randomly sampled noise to account for uncertainty in data\" , ) new_entries . append ( self . get_adjusted_entry ( entry , adj )) return GibbsEntrySet ( new_entries )","title":"get_entries_with_jitter()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_interpolated_entry","text":"Helper method for interpolating an entry from the entry set. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry An interpolated GibbsComputedEntry object. Source code in rxn_network/entries/entry_set.py 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 def get_interpolated_entry ( self , formula : str , tol_per_atom = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for interpolating an entry from the entry set. Args: formula: The chemical formula of the desired entry. Returns: An interpolated GibbsComputedEntry object. \"\"\" comp = Composition ( formula ) . reduced_composition pd_entries = self . get_subset_in_chemsys ([ str ( e ) for e in comp . elements ]) energy = ( PhaseDiagram ( pd_entries ) . get_hull_energy ( comp ) - tol_per_atom * comp . num_atoms ) adj = ConstantEnergyAdjustment ( # for keeping track of uncertainty value = 0.0 , uncertainty = 0.05 * comp . num_atoms , # conservative: 50 meV/atom uncertainty name = \"Interpolation adjustment\" , description = \"Keeps track of uncertainty in interpolation\" , ) return InterpolatedEntry ( comp , energy , energy_adjustments = [ adj ], entry_id = f \"(Interpolated Entry: { comp . formula } )\" , )","title":"get_interpolated_entry()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_min_entry_by_formula","text":"Helper method for acquiring the ground state entry with the specified formula. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry Ground state computed entry object. Source code in rxn_network/entries/entry_set.py 206 207 208 209 210 211 212 213 214 215 216 def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" return self . min_entries_by_formula [ Composition ( formula ) . reduced_formula ]","title":"get_min_entry_by_formula()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_stabilized_entry","text":"Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Parameters: Name Type Description Default entry ComputedEntry A computed entry object. required tol float The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. 0.001 Returns: Type Description ComputedEntry A new ComputedEntry with energy adjustment making it appear to be stable. Source code in rxn_network/entries/entry_set.py 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 def get_stabilized_entry ( self , entry : ComputedEntry , tol : float = 1e-3 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. If the entry is already stable, it will be returned unchanged. If the entry includes the \"e_above_hull\" data, this value will be used to stabilize the entry. Otherwise, the energy above hull will be calculated via creation of a phase diagram (can take a long time for repeated calls) Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" e_above_hull = None if hasattr ( entry , \"data\" ): e_above_hull = entry . data . get ( \"e_above_hull\" ) if e_above_hull is None : e_above_hull = self . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * e_above_hull * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that entry is on the convex hull\" , ) new_entry = self . get_adjusted_entry ( entry , adjustment ) return new_entry","title":"get_stabilized_entry()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_subset_in_chemsys","text":"Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Parameters: Name Type Description Default chemsys List [ str ] Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] required Source code in rxn_network/entries/entry_set.py 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def get_subset_in_chemsys ( self , chemsys : List [ str ]) -> \"GibbsEntrySet\" : \"\"\" Returns a GibbsEntrySet containing only the set of entries belonging to a particular chemical system (including subsystems). For example, if the entries are from the Li-Fe-P-O system, and chemsys=[\"Li\", \"O\"], only the Li, O, and Li-O entries are returned. Args: chemsys: Chemical system specified as list of elements. E.g., [\"Li\", \"O\"] Returns: GibbsEntrySet \"\"\" chem_sys = set ( chemsys ) if not chem_sys . issubset ( self . chemsys ): raise ValueError ( f \" { chem_sys } is not a subset of { self . chemsys } \" ) subset = set () for e in self . entries : elements = [ sp . symbol for sp in e . composition . keys ()] if chem_sys . issuperset ( elements ): subset . add ( e ) return GibbsEntrySet ( subset , calculate_e_above_hulls = False )","title":"get_subset_in_chemsys()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.min_entries_by_formula","text":"Returns a dict of minimum energy entries in the entry set, indexed by formula. Source code in rxn_network/entries/entry_set.py 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 @cached_property def min_entries_by_formula ( self ) -> Dict [ str , ComputedEntry ]: \"\"\" Returns a dict of minimum energy entries in the entry set, indexed by formula. \"\"\" min_entries = {} for e in self . entries : formula = e . composition . reduced_formula if formula not in min_entries : entries = filter ( lambda x : x . composition . reduced_formula == formula , self . entries ) min_entries [ formula ] = sorted ( entries , key = lambda x : x . energy_per_atom )[ 0 ] return min_entries","title":"min_entries_by_formula()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.pd_dict","text":"Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. Source code in rxn_network/entries/entry_set.py 117 118 119 120 121 122 123 124 @cached_property def pd_dict ( self ): \"\"\" Returns a dictionary of phase diagrams, keyed by the chemical system. This is acquired using the helper method expand_pd() and represents one of the simplest divisions of sub-PDs for large chemical systems. Cached for speed. \"\"\" return expand_pd ( self . entries )","title":"pd_dict()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.stabilize_entry","text":"This method is deprecated. Use get_stabilized_entry instead. Source code in rxn_network/entries/entry_set.py 258 259 260 261 262 263 264 265 266 @deprecated ( get_stabilized_entry , \"This method has been renamed. Use get_stabilized_entry instead.\" , ) def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" This method is deprecated. Use get_stabilized_entry instead. \"\"\" return self . get_stabilized_entry ( entry , tol )","title":"stabilize_entry()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.update","text":"Add an iterable of entries to the set. Parameters: Name Type Description Default entry An iterable of entry objects. required Source code in rxn_network/entries/entry_set.py 96 97 98 99 100 101 102 103 104 105 106 def update ( self , entries : Iterable [ Union [ GibbsComputedEntry , ExperimentalReferenceEntry ]] ): \"\"\" Add an iterable of entries to the set. Args: entry: An iterable of entry objects. \"\"\" self . entries . update ( entries ) self . _clear_cache ()","title":"update()"},{"location":"reference/entries/experimental/","text":"Implements an Entry that looks up NIST pre-tabulated Gibbs free energies ExperimentalReferenceEntry Bases: ComputedEntry An Entry class for experimental reference data, to be sub-classed for specific data sources. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Source code in rxn_network/entries/experimental.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class ExperimentalReferenceEntry ( ComputedEntry ): \"\"\" An Entry class for experimental reference data, to be sub-classed for specific data sources. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. \"\"\" REFERENCES : Dict = {} def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ dict ] = None , ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected within the range of the reference data (see self._validate_temperature), then this will raise an error. energy_adjustments: A list of EnergyAdjustments to apply to the entry. data: Optional dictionary containing entry data \"\"\" formula = composition . reduced_formula entry_id = self . __class__ . __name__ self . _temperature = temperature self . _validate_temperature ( formula , temperature ) energy = self . _get_energy ( formula , temperature ) super () . __init__ ( composition , energy , energy_adjustments = energy_adjustments , data = data , entry_id = entry_id , ) self . _composition = composition self . name = formula def get_new_temperature ( self , new_temperature : float ) -> \"ExperimentalReferenceEntry\" : \"\"\" Return a copy of the NISTReferenceEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the NISTReferenceEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry def to_grand_entry ( self , chempots ): \"\"\" Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) @classmethod def _validate_temperature ( cls , formula : str , temperature : float ) -> None : \"\"\"Ensure that the temperature is from a valid range.\"\"\" if formula not in cls . REFERENCES : raise ValueError ( f \" { formula } not in reference data!\" ) g = cls . REFERENCES [ formula ] if temperature < min ( g ) or temperature > max ( g ): raise ValueError ( f \"Temperature must be selected from range: { min ( g ) } K to { max ( g ) } K\" ) @classmethod def _get_energy ( cls , formula : str , temperature : float ) -> float : \"\"\" Convenience method for accessing and interpolating experimental data. Args: formula: Chemical formula by which to search experimental data. temperature: Absolute temperature [K]. Returns: Gibbs free energy of formation of formula at specified temperature [eV] \"\"\" data = cls . REFERENCES [ formula ] if temperature % 100 > 0 : g_interp = interp1d ( list ( data . keys ()), list ( data . values ())) return g_interp ( temperature )[()] return data [ temperature ] @property def temperature ( self ) -> float : \"\"\"Returns temperature used to calculate entry's energy\"\"\" return self . _temperature @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return True @property def is_element ( self ) -> bool : \"\"\"Returns True if the entry is an element.\"\"\" return self . composition . is_element def as_dict ( self ): \"\"\" Returns: A dict representation of the Entry. \"\"\" d = super () . as_dict () d [ \"temperature\" ] = self . temperature del d [ \"energy\" ] del d [ \"entry_id\" ] del d [ \"parameters\" ] del d [ \"correction\" ] return d @classmethod def from_dict ( cls , d ): dec = MontyDecoder () entry = cls ( composition = Composition ( d [ \"composition\" ]), temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), data = d [ \"data\" ], ) return entry def __repr__ ( self ): output = [ f \" { self . __class__ . __name__ } | { self . composition . reduced_formula } \" , f \"Gibbs Energy ( { self . temperature } K) = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return ( ( self . composition . reduced_formula == other . composition . reduced_formula ) and ( self . temperature == other . temperature ) and ( set ( self . energy_adjustments ) == set ( other . energy_adjustments )) ) return False def __hash__ ( self ): data_md5 = hashlib . md5 ( # nosec f \" { self . __class__ . __name__ }{ self . composition } _ { self . temperature } \" . encode ( \"utf-8\" ) ) . hexdigest () return int ( data_md5 , 16 ) __init__ ( composition , temperature , energy_adjustments = None , data = None ) Parameters: Name Type Description Default composition Composition Composition object (pymatgen). temperature: Temperature in required energy_adjustments Optional [ List [ EnergyAdjustment ]] A list of EnergyAdjustments to apply to the entry. data: None Source code in rxn_network/entries/experimental.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ dict ] = None , ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected within the range of the reference data (see self._validate_temperature), then this will raise an error. energy_adjustments: A list of EnergyAdjustments to apply to the entry. data: Optional dictionary containing entry data \"\"\" formula = composition . reduced_formula entry_id = self . __class__ . __name__ self . _temperature = temperature self . _validate_temperature ( formula , temperature ) energy = self . _get_energy ( formula , temperature ) super () . __init__ ( composition , energy , energy_adjustments = energy_adjustments , data = data , entry_id = entry_id , ) self . _composition = composition self . name = formula as_dict () Returns: Type Description A dict representation of the Entry. Source code in rxn_network/entries/experimental.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def as_dict ( self ): \"\"\" Returns: A dict representation of the Entry. \"\"\" d = super () . as_dict () d [ \"temperature\" ] = self . temperature del d [ \"energy\" ] del d [ \"entry_id\" ] del d [ \"parameters\" ] del d [ \"correction\" ] return d get_new_temperature ( new_temperature ) Return a copy of the NISTReferenceEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description ExperimentalReferenceEntry A copy of the NISTReferenceEntry at the new specified temperature. Source code in rxn_network/entries/experimental.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def get_new_temperature ( self , new_temperature : float ) -> \"ExperimentalReferenceEntry\" : \"\"\" Return a copy of the NISTReferenceEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the NISTReferenceEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry is_element () property Returns True if the entry is an element. Source code in rxn_network/entries/experimental.py 132 133 134 135 @property def is_element ( self ) -> bool : \"\"\"Returns True if the entry is an element.\"\"\" return self . composition . is_element is_experimental () property Returns True by default. Source code in rxn_network/entries/experimental.py 127 128 129 130 @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return True temperature () property Returns temperature used to calculate entry's energy Source code in rxn_network/entries/experimental.py 122 123 124 125 @property def temperature ( self ) -> float : \"\"\"Returns temperature used to calculate entry's energy\"\"\" return self . _temperature to_grand_entry ( chempots ) Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/experimental.py 77 78 79 80 81 82 83 84 85 86 87 def to_grand_entry ( self , chempots ): \"\"\" Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"Experimental"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry","text":"Bases: ComputedEntry An Entry class for experimental reference data, to be sub-classed for specific data sources. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Source code in rxn_network/entries/experimental.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 class ExperimentalReferenceEntry ( ComputedEntry ): \"\"\" An Entry class for experimental reference data, to be sub-classed for specific data sources. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. \"\"\" REFERENCES : Dict = {} def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ dict ] = None , ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected within the range of the reference data (see self._validate_temperature), then this will raise an error. energy_adjustments: A list of EnergyAdjustments to apply to the entry. data: Optional dictionary containing entry data \"\"\" formula = composition . reduced_formula entry_id = self . __class__ . __name__ self . _temperature = temperature self . _validate_temperature ( formula , temperature ) energy = self . _get_energy ( formula , temperature ) super () . __init__ ( composition , energy , energy_adjustments = energy_adjustments , data = data , entry_id = entry_id , ) self . _composition = composition self . name = formula def get_new_temperature ( self , new_temperature : float ) -> \"ExperimentalReferenceEntry\" : \"\"\" Return a copy of the NISTReferenceEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the NISTReferenceEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry def to_grand_entry ( self , chempots ): \"\"\" Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) @classmethod def _validate_temperature ( cls , formula : str , temperature : float ) -> None : \"\"\"Ensure that the temperature is from a valid range.\"\"\" if formula not in cls . REFERENCES : raise ValueError ( f \" { formula } not in reference data!\" ) g = cls . REFERENCES [ formula ] if temperature < min ( g ) or temperature > max ( g ): raise ValueError ( f \"Temperature must be selected from range: { min ( g ) } K to { max ( g ) } K\" ) @classmethod def _get_energy ( cls , formula : str , temperature : float ) -> float : \"\"\" Convenience method for accessing and interpolating experimental data. Args: formula: Chemical formula by which to search experimental data. temperature: Absolute temperature [K]. Returns: Gibbs free energy of formation of formula at specified temperature [eV] \"\"\" data = cls . REFERENCES [ formula ] if temperature % 100 > 0 : g_interp = interp1d ( list ( data . keys ()), list ( data . values ())) return g_interp ( temperature )[()] return data [ temperature ] @property def temperature ( self ) -> float : \"\"\"Returns temperature used to calculate entry's energy\"\"\" return self . _temperature @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return True @property def is_element ( self ) -> bool : \"\"\"Returns True if the entry is an element.\"\"\" return self . composition . is_element def as_dict ( self ): \"\"\" Returns: A dict representation of the Entry. \"\"\" d = super () . as_dict () d [ \"temperature\" ] = self . temperature del d [ \"energy\" ] del d [ \"entry_id\" ] del d [ \"parameters\" ] del d [ \"correction\" ] return d @classmethod def from_dict ( cls , d ): dec = MontyDecoder () entry = cls ( composition = Composition ( d [ \"composition\" ]), temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), data = d [ \"data\" ], ) return entry def __repr__ ( self ): output = [ f \" { self . __class__ . __name__ } | { self . composition . reduced_formula } \" , f \"Gibbs Energy ( { self . temperature } K) = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return ( ( self . composition . reduced_formula == other . composition . reduced_formula ) and ( self . temperature == other . temperature ) and ( set ( self . energy_adjustments ) == set ( other . energy_adjustments )) ) return False def __hash__ ( self ): data_md5 = hashlib . md5 ( # nosec f \" { self . __class__ . __name__ }{ self . composition } _ { self . temperature } \" . encode ( \"utf-8\" ) ) . hexdigest () return int ( data_md5 , 16 )","title":"ExperimentalReferenceEntry"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.__init__","text":"Parameters: Name Type Description Default composition Composition Composition object (pymatgen). temperature: Temperature in required energy_adjustments Optional [ List [ EnergyAdjustment ]] A list of EnergyAdjustments to apply to the entry. data: None Source code in rxn_network/entries/experimental.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ dict ] = None , ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected within the range of the reference data (see self._validate_temperature), then this will raise an error. energy_adjustments: A list of EnergyAdjustments to apply to the entry. data: Optional dictionary containing entry data \"\"\" formula = composition . reduced_formula entry_id = self . __class__ . __name__ self . _temperature = temperature self . _validate_temperature ( formula , temperature ) energy = self . _get_energy ( formula , temperature ) super () . __init__ ( composition , energy , energy_adjustments = energy_adjustments , data = data , entry_id = entry_id , ) self . _composition = composition self . name = formula","title":"__init__()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.as_dict","text":"Returns: Type Description A dict representation of the Entry. Source code in rxn_network/entries/experimental.py 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 def as_dict ( self ): \"\"\" Returns: A dict representation of the Entry. \"\"\" d = super () . as_dict () d [ \"temperature\" ] = self . temperature del d [ \"energy\" ] del d [ \"entry_id\" ] del d [ \"parameters\" ] del d [ \"correction\" ] return d","title":"as_dict()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.get_new_temperature","text":"Return a copy of the NISTReferenceEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description ExperimentalReferenceEntry A copy of the NISTReferenceEntry at the new specified temperature. Source code in rxn_network/entries/experimental.py 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 def get_new_temperature ( self , new_temperature : float ) -> \"ExperimentalReferenceEntry\" : \"\"\" Return a copy of the NISTReferenceEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the NISTReferenceEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry","title":"get_new_temperature()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.is_element","text":"Returns True if the entry is an element. Source code in rxn_network/entries/experimental.py 132 133 134 135 @property def is_element ( self ) -> bool : \"\"\"Returns True if the entry is an element.\"\"\" return self . composition . is_element","title":"is_element()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.is_experimental","text":"Returns True by default. Source code in rxn_network/entries/experimental.py 127 128 129 130 @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return True","title":"is_experimental()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.temperature","text":"Returns temperature used to calculate entry's energy Source code in rxn_network/entries/experimental.py 122 123 124 125 @property def temperature ( self ) -> float : \"\"\"Returns temperature used to calculate entry's energy\"\"\" return self . _temperature","title":"temperature()"},{"location":"reference/entries/experimental/#rxn_network.entries.experimental.ExperimentalReferenceEntry.to_grand_entry","text":"Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/experimental.py 77 78 79 80 81 82 83 84 85 86 87 def to_grand_entry ( self , chempots ): \"\"\" Convert an ExperimentalReferenceEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"to_grand_entry()"},{"location":"reference/entries/freed/","text":"Implements an Entry that looks up pre-tabulated Gibbs free energies from the NIST-JANAF tables. FREEDReferenceEntry Bases: ExperimentalReferenceEntry An Entry class for FREED experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference https://www.thermart.net/freed-thermodynamic-database/ Source code in rxn_network/entries/freed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class FREEDReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for FREED experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: https://www.thermart.net/freed-thermodynamic-database/ \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , ) __init__ ( composition , temperature , energy_adjustments = None , data = None ) Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required data Optional [ Dict ] Optional dictionary containing entry data None Source code in rxn_network/entries/freed.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"Freed"},{"location":"reference/entries/freed/#rxn_network.entries.freed.FREEDReferenceEntry","text":"Bases: ExperimentalReferenceEntry An Entry class for FREED experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference https://www.thermart.net/freed-thermodynamic-database/ Source code in rxn_network/entries/freed.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 class FREEDReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for FREED experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: https://www.thermart.net/freed-thermodynamic-database/ \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"FREEDReferenceEntry"},{"location":"reference/entries/freed/#rxn_network.entries.freed.FREEDReferenceEntry.__init__","text":"Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required data Optional [ Dict ] Optional dictionary containing entry data None Source code in rxn_network/entries/freed.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"__init__()"},{"location":"reference/entries/gibbs/","text":"A computed entry object for estimating the Gibbs free energy of formation. Note that this is similar to the implementation within pymatgen, but has been refactored here to add extra functionality. GibbsComputedEntry Bases: ComputedEntry An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2). Reference Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Source code in rxn_network/entries/gibbs.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class GibbsComputedEntry ( ComputedEntry ): \"\"\" An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2). Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 \"\"\" def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a _formation_ energy, it must be calculated using a phase diagram construction. volume_per_atom: The total volume of the associated structure divided by its number of atoms. temperature: Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" composition = Composition ( composition ) self . _composition = composition self . volume_per_atom = volume_per_atom num_atoms = composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) self . _composition = composition self . formation_energy_per_atom = formation_energy_per_atom self . temperature = temperature def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry, initialized at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature ) def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) def copy ( self ): return deepcopy ( self ) @staticmethod def _g_delta_sisso ( volume_per_atom : float , reduced_mass : float , temp : float ) -> float : \"\"\" G^delta as predicted by SISSO-learned descriptor from Eq. (4) in Bartel et al. (2018). Args: vol_per_atom: volume per atom [\u00c5^3/atom] reduced_mass: reduced mass as calculated with pair-wise sum formula [amu] temp: Temperature [K] Returns: float: G^delta \"\"\" return ( ( - 2.48e-4 * np . log ( volume_per_atom ) - 8.94e-5 * reduced_mass / volume_per_atom ) * temp + 0.181 * np . log ( temp ) - 0.882 ) @staticmethod def _sum_g_i ( composition : Composition , temperature : float ) -> float : \"\"\" Sum of the stoichiometrically weighted chemical potentials [eV] of the elements at specified temperature, as acquired from data/elements.json. \"\"\" elems = composition . get_el_amt_dict () if temperature % 100 > 0 : sum_g_i = 0 for elem , amt in elems . items (): g_interp = interp1d ( [ float ( t ) for t in G_ELEMS . keys ()], [ g_dict [ elem ] for g_dict in G_ELEMS . values ()], ) sum_g_i += amt * g_interp ( temperature ) else : sum_g_i = sum ( amt * G_ELEMS [ str ( temperature )][ elem ] for elem , amt in elems . items () ) return sum_g_i @staticmethod def _reduced_mass ( composition : Composition ) -> float : \"\"\" Reduced mass [amu] as calculated via Eq. 6 in Bartel et al. (2018), to be used in SISSO descriptor equation. \"\"\" reduced_comp = composition . reduced_composition num_elems = len ( reduced_comp . elements ) elem_dict = reduced_comp . get_el_amt_dict () denominator = ( num_elems - 1 ) * reduced_comp . num_atoms all_pairs = combinations ( elem_dict . items (), 2 ) mass_sum = 0.0 for pair in all_pairs : m_i = Composition ( pair [ 0 ][ 0 ]) . weight m_j = Composition ( pair [ 1 ][ 0 ]) . weight alpha_i = pair [ 0 ][ 1 ] alpha_j = pair [ 1 ][ 1 ] mass_sum += ( alpha_i + alpha_j ) * ( m_i * m_j ) / ( m_i + m_j ) reduced_mass = ( 1 / denominator ) * mass_sum return reduced_mass @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to GibbsComputedEntry.__init__ Returns: A new GibbsComputedEntry object \"\"\" composition = Composition ( structure . composition ) volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry @property def is_experimental ( self ) -> bool : \"\"\" Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. \"\"\" if \"theoretical\" in self . data : return not self . data [ \"theoretical\" ] if \"icsd_ids\" in self . data : return len ( self . data [ \"icsd_ids\" ]) >= 1 return False def as_dict ( self ) -> dict : \"\"\"Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data @classmethod def from_dict ( cls , d : dict ) -> \"GibbsComputedEntry\" : \"\"\" \"Returns a GibbsComputedEntry object from MSONable dictionary\"\"\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry def __repr__ ( self ): output = [ ( f \"GibbsComputedEntry | { self . entry_id } | { self . composition . formula } \" f \"( { self . composition . reduced_formula } )\" ), f \"Gibbs Energy ( { self . temperature } K) = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if not type ( other ) is type ( self ): return False if not np . isclose ( self . energy , other . energy ): return False if getattr ( self , \"entry_id\" , None ) and getattr ( other , \"entry_id\" , None ): return self . entry_id == other . entry_id if self . composition != other . composition : return False return True def __hash__ ( self ): return hash ( ( self . composition , self . energy , self . entry_id , self . temperature , ) ) __init__ ( composition , formation_energy_per_atom , volume_per_atom , temperature , energy_adjustments = None , parameters = None , data = None , entry_id = None ) A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Parameters: Name Type Description Default composition Composition The composition object (pymatgen) required formation_energy_per_atom float Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a formation energy, it must be calculated using a phase diagram construction. required volume_per_atom float The total volume of the associated structure divided by its number of atoms. required temperature float Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. required energy_adjustments Optional [ List [ EnergyAdjustment ]] Optional list of energy adjustments None parameters Optional [ dict ] Optional list of calculation parameters None data Optional [ dict ] Optional dictionary containing entry data None entry_id Optional [ object ] Optional entry-id, such as the entry's mp-id None Source code in rxn_network/entries/gibbs.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a _formation_ energy, it must be calculated using a phase diagram construction. volume_per_atom: The total volume of the associated structure divided by its number of atoms. temperature: Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" composition = Composition ( composition ) self . _composition = composition self . volume_per_atom = volume_per_atom num_atoms = composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) self . _composition = composition self . formation_energy_per_atom = formation_energy_per_atom self . temperature = temperature as_dict () Returns an MSONable dict. Source code in rxn_network/entries/gibbs.py 294 295 296 297 298 299 300 def as_dict ( self ) -> dict : \"\"\"Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data from_dict ( d ) classmethod \"Returns a GibbsComputedEntry object from MSONable dictionary Source code in rxn_network/entries/gibbs.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @classmethod def from_dict ( cls , d : dict ) -> \"GibbsComputedEntry\" : \"\"\" \"Returns a GibbsComputedEntry object from MSONable dictionary\"\"\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry from_structure ( structure , formation_energy_per_atom , temperature , ** kwargs ) classmethod Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Parameters: Name Type Description Default structure Structure Structure object (pymatgen) required formation_energy_per_atom float Formation enthalpy at T = 298 K associated with structure required temperature float Desired temperature [K] for acquiring dGf(T) required **kwargs Optional kwargs to be passed to GibbsComputedEntry. init {} Returns: Type Description GibbsComputedEntry A new GibbsComputedEntry object Source code in rxn_network/entries/gibbs.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to GibbsComputedEntry.__init__ Returns: A new GibbsComputedEntry object \"\"\" composition = Composition ( structure . composition ) volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry get_new_temperature ( new_temperature ) Return a copy of the GibbsComputedEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description GibbsComputedEntry A copy of the GibbsComputedEntry, initialized at the new specified GibbsComputedEntry temperature. Source code in rxn_network/entries/gibbs.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry, initialized at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry gibbs_adjustment ( temperature ) Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Parameters: Name Type Description Default temperature float The absolute temperature [K]. required Returns: Type Description float The correction to Gibbs free energy of formation (eV) from DFT energy. Source code in rxn_network/entries/gibbs.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature ) is_experimental () property Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. Source code in rxn_network/entries/gibbs.py 280 281 282 283 284 285 286 287 288 289 290 291 292 @property def is_experimental ( self ) -> bool : \"\"\" Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. \"\"\" if \"theoretical\" in self . data : return not self . data [ \"theoretical\" ] if \"icsd_ids\" in self . data : return len ( self . data [ \"icsd_ids\" ]) >= 1 return False to_grand_entry ( chempots ) Convert a GibbsComputedEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/gibbs.py 155 156 157 158 159 160 161 162 163 164 165 def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"Gibbs"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry","text":"Bases: ComputedEntry An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2). Reference Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Source code in rxn_network/entries/gibbs.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 class GibbsComputedEntry ( ComputedEntry ): \"\"\" An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2). Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 \"\"\" def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a _formation_ energy, it must be calculated using a phase diagram construction. volume_per_atom: The total volume of the associated structure divided by its number of atoms. temperature: Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" composition = Composition ( composition ) self . _composition = composition self . volume_per_atom = volume_per_atom num_atoms = composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) self . _composition = composition self . formation_energy_per_atom = formation_energy_per_atom self . temperature = temperature def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry, initialized at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature ) def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) def copy ( self ): return deepcopy ( self ) @staticmethod def _g_delta_sisso ( volume_per_atom : float , reduced_mass : float , temp : float ) -> float : \"\"\" G^delta as predicted by SISSO-learned descriptor from Eq. (4) in Bartel et al. (2018). Args: vol_per_atom: volume per atom [\u00c5^3/atom] reduced_mass: reduced mass as calculated with pair-wise sum formula [amu] temp: Temperature [K] Returns: float: G^delta \"\"\" return ( ( - 2.48e-4 * np . log ( volume_per_atom ) - 8.94e-5 * reduced_mass / volume_per_atom ) * temp + 0.181 * np . log ( temp ) - 0.882 ) @staticmethod def _sum_g_i ( composition : Composition , temperature : float ) -> float : \"\"\" Sum of the stoichiometrically weighted chemical potentials [eV] of the elements at specified temperature, as acquired from data/elements.json. \"\"\" elems = composition . get_el_amt_dict () if temperature % 100 > 0 : sum_g_i = 0 for elem , amt in elems . items (): g_interp = interp1d ( [ float ( t ) for t in G_ELEMS . keys ()], [ g_dict [ elem ] for g_dict in G_ELEMS . values ()], ) sum_g_i += amt * g_interp ( temperature ) else : sum_g_i = sum ( amt * G_ELEMS [ str ( temperature )][ elem ] for elem , amt in elems . items () ) return sum_g_i @staticmethod def _reduced_mass ( composition : Composition ) -> float : \"\"\" Reduced mass [amu] as calculated via Eq. 6 in Bartel et al. (2018), to be used in SISSO descriptor equation. \"\"\" reduced_comp = composition . reduced_composition num_elems = len ( reduced_comp . elements ) elem_dict = reduced_comp . get_el_amt_dict () denominator = ( num_elems - 1 ) * reduced_comp . num_atoms all_pairs = combinations ( elem_dict . items (), 2 ) mass_sum = 0.0 for pair in all_pairs : m_i = Composition ( pair [ 0 ][ 0 ]) . weight m_j = Composition ( pair [ 1 ][ 0 ]) . weight alpha_i = pair [ 0 ][ 1 ] alpha_j = pair [ 1 ][ 1 ] mass_sum += ( alpha_i + alpha_j ) * ( m_i * m_j ) / ( m_i + m_j ) reduced_mass = ( 1 / denominator ) * mass_sum return reduced_mass @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to GibbsComputedEntry.__init__ Returns: A new GibbsComputedEntry object \"\"\" composition = Composition ( structure . composition ) volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry @property def is_experimental ( self ) -> bool : \"\"\" Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. \"\"\" if \"theoretical\" in self . data : return not self . data [ \"theoretical\" ] if \"icsd_ids\" in self . data : return len ( self . data [ \"icsd_ids\" ]) >= 1 return False def as_dict ( self ) -> dict : \"\"\"Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data @classmethod def from_dict ( cls , d : dict ) -> \"GibbsComputedEntry\" : \"\"\" \"Returns a GibbsComputedEntry object from MSONable dictionary\"\"\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry def __repr__ ( self ): output = [ ( f \"GibbsComputedEntry | { self . entry_id } | { self . composition . formula } \" f \"( { self . composition . reduced_formula } )\" ), f \"Gibbs Energy ( { self . temperature } K) = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if not type ( other ) is type ( self ): return False if not np . isclose ( self . energy , other . energy ): return False if getattr ( self , \"entry_id\" , None ) and getattr ( other , \"entry_id\" , None ): return self . entry_id == other . entry_id if self . composition != other . composition : return False return True def __hash__ ( self ): return hash ( ( self . composition , self . energy , self . entry_id , self . temperature , ) )","title":"GibbsComputedEntry"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.__init__","text":"A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Parameters: Name Type Description Default composition Composition The composition object (pymatgen) required formation_energy_per_atom float Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a formation energy, it must be calculated using a phase diagram construction. required volume_per_atom float The total volume of the associated structure divided by its number of atoms. required temperature float Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. required energy_adjustments Optional [ List [ EnergyAdjustment ]] Optional list of energy adjustments None parameters Optional [ dict ] Optional list of calculation parameters None data Optional [ dict ] Optional dictionary containing entry data None entry_id Optional [ object ] Optional entry-id, such as the entry's mp-id None Source code in rxn_network/entries/gibbs.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. NOTE: since this is a _formation_ energy, it must be calculated using a phase diagram construction. volume_per_atom: The total volume of the associated structure divided by its number of atoms. temperature: Temperature [K] by which to acquire dGf(T); must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" composition = Composition ( composition ) self . _composition = composition self . volume_per_atom = volume_per_atom num_atoms = composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) self . _composition = composition self . formation_energy_per_atom = formation_energy_per_atom self . temperature = temperature","title":"__init__()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.as_dict","text":"Returns an MSONable dict. Source code in rxn_network/entries/gibbs.py 294 295 296 297 298 299 300 def as_dict ( self ) -> dict : \"\"\"Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data","title":"as_dict()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.from_dict","text":"\"Returns a GibbsComputedEntry object from MSONable dictionary Source code in rxn_network/entries/gibbs.py 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 @classmethod def from_dict ( cls , d : dict ) -> \"GibbsComputedEntry\" : \"\"\" \"Returns a GibbsComputedEntry object from MSONable dictionary\"\"\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry","title":"from_dict()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.from_structure","text":"Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Parameters: Name Type Description Default structure Structure Structure object (pymatgen) required formation_energy_per_atom float Formation enthalpy at T = 298 K associated with structure required temperature float Desired temperature [K] for acquiring dGf(T) required **kwargs Optional kwargs to be passed to GibbsComputedEntry. init {} Returns: Type Description GibbsComputedEntry A new GibbsComputedEntry object Source code in rxn_network/entries/gibbs.py 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to GibbsComputedEntry.__init__ Returns: A new GibbsComputedEntry object \"\"\" composition = Composition ( structure . composition ) volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry","title":"from_structure()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.get_new_temperature","text":"Return a copy of the GibbsComputedEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description GibbsComputedEntry A copy of the GibbsComputedEntry, initialized at the new specified GibbsComputedEntry temperature. Source code in rxn_network/entries/gibbs.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry, initialized at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry","title":"get_new_temperature()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.gibbs_adjustment","text":"Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Parameters: Name Type Description Default temperature float The absolute temperature [K]. required Returns: Type Description float The correction to Gibbs free energy of formation (eV) from DFT energy. Source code in rxn_network/entries/gibbs.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature )","title":"gibbs_adjustment()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.is_experimental","text":"Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. Source code in rxn_network/entries/gibbs.py 280 281 282 283 284 285 286 287 288 289 290 291 292 @property def is_experimental ( self ) -> bool : \"\"\" Returns True if self.data contains {\"theoretical\": False}. If theoretical is not specified but there is greater than 1 icsd_id provided, assumes that the presence of an icsd_id means the entry is experimental. \"\"\" if \"theoretical\" in self . data : return not self . data [ \"theoretical\" ] if \"icsd_ids\" in self . data : return len ( self . data [ \"icsd_ids\" ]) >= 1 return False","title":"is_experimental()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.to_grand_entry","text":"Convert a GibbsComputedEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/gibbs.py 155 156 157 158 159 160 161 162 163 164 165 def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"to_grand_entry()"},{"location":"reference/entries/interpolated/","text":"Class for intepolated entries InterpolatedEntry Bases: ComputedEntry Lightweight Entry object for computed data. Contains facilities for applying corrections to the energy attribute and for storing calculation parameters. Source code in rxn_network/entries/interpolated.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class InterpolatedEntry ( ComputedEntry ): \"\"\" Lightweight Entry object for computed data. Contains facilities for applying corrections to the energy attribute and for storing calculation parameters. \"\"\" def __init__ ( self , composition : Composition , energy : float , correction : float = 0.0 , energy_adjustments : list = None , parameters : dict = None , data : dict = None , entry_id : object = None , ): \"\"\" Initializes an InterpolatedEntry. Args: composition (Composition): Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. energy (float): Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. correction (float): Manually set an energy correction, will ignore energy_adjustments if specified. energy_adjustments: An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. parameters: An optional dict of parameters associated with the entry. Defaults to None. data: An optional dict of any additional data associated with the entry. Defaults to None. entry_id: An optional id to uniquely identify the entry. \"\"\" super () . __init__ ( composition , energy , correction = correction , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return False def __repr__ ( self ): output = [ ( f \"InterpolatedEntry | { self . composition . formula } \" f \"( { self . composition . reduced_formula } )\" ), f \"Energy = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if not type ( other ) is type ( self ): return False if not np . isclose ( self . energy , other . energy ): return False if getattr ( self , \"entry_id\" , None ) and getattr ( other , \"entry_id\" , None ): return self . entry_id == other . entry_id if self . composition != other . composition : return False return True def __hash__ ( self ): return hash ( ( self . composition , self . energy , self . entry_id , ) ) __init__ ( composition , energy , correction = 0.0 , energy_adjustments = None , parameters = None , data = None , entry_id = None ) Initializes an InterpolatedEntry. Parameters: Name Type Description Default composition Composition Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. required energy float Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. required correction float Manually set an energy correction, will ignore energy_adjustments if specified. 0.0 energy_adjustments list An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. None parameters dict An optional dict of parameters associated with the entry. Defaults to None. None data dict An optional dict of any additional data associated with the entry. Defaults to None. None entry_id object An optional id to uniquely identify the entry. None Source code in rxn_network/entries/interpolated.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , composition : Composition , energy : float , correction : float = 0.0 , energy_adjustments : list = None , parameters : dict = None , data : dict = None , entry_id : object = None , ): \"\"\" Initializes an InterpolatedEntry. Args: composition (Composition): Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. energy (float): Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. correction (float): Manually set an energy correction, will ignore energy_adjustments if specified. energy_adjustments: An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. parameters: An optional dict of parameters associated with the entry. Defaults to None. data: An optional dict of any additional data associated with the entry. Defaults to None. entry_id: An optional id to uniquely identify the entry. \"\"\" super () . __init__ ( composition , energy , correction = correction , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) is_experimental () property Returns True by default. Source code in rxn_network/entries/interpolated.py 70 71 72 73 @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return False to_grand_entry ( chempots ) Convert a GibbsComputedEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/interpolated.py 58 59 60 61 62 63 64 65 66 67 68 def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"Interpolated"},{"location":"reference/entries/interpolated/#rxn_network.entries.interpolated.InterpolatedEntry","text":"Bases: ComputedEntry Lightweight Entry object for computed data. Contains facilities for applying corrections to the energy attribute and for storing calculation parameters. Source code in rxn_network/entries/interpolated.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 class InterpolatedEntry ( ComputedEntry ): \"\"\" Lightweight Entry object for computed data. Contains facilities for applying corrections to the energy attribute and for storing calculation parameters. \"\"\" def __init__ ( self , composition : Composition , energy : float , correction : float = 0.0 , energy_adjustments : list = None , parameters : dict = None , data : dict = None , entry_id : object = None , ): \"\"\" Initializes an InterpolatedEntry. Args: composition (Composition): Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. energy (float): Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. correction (float): Manually set an energy correction, will ignore energy_adjustments if specified. energy_adjustments: An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. parameters: An optional dict of parameters associated with the entry. Defaults to None. data: An optional dict of any additional data associated with the entry. Defaults to None. entry_id: An optional id to uniquely identify the entry. \"\"\" super () . __init__ ( composition , energy , correction = correction , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots ) @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return False def __repr__ ( self ): output = [ ( f \"InterpolatedEntry | { self . composition . formula } \" f \"( { self . composition . reduced_formula } )\" ), f \"Energy = { self . energy : .4f } \" , ] return \" \\n \" . join ( output ) def __eq__ ( self , other ): if not type ( other ) is type ( self ): return False if not np . isclose ( self . energy , other . energy ): return False if getattr ( self , \"entry_id\" , None ) and getattr ( other , \"entry_id\" , None ): return self . entry_id == other . entry_id if self . composition != other . composition : return False return True def __hash__ ( self ): return hash ( ( self . composition , self . energy , self . entry_id , ) )","title":"InterpolatedEntry"},{"location":"reference/entries/interpolated/#rxn_network.entries.interpolated.InterpolatedEntry.__init__","text":"Initializes an InterpolatedEntry. Parameters: Name Type Description Default composition Composition Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. required energy float Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. required correction float Manually set an energy correction, will ignore energy_adjustments if specified. 0.0 energy_adjustments list An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. None parameters dict An optional dict of parameters associated with the entry. Defaults to None. None data dict An optional dict of any additional data associated with the entry. Defaults to None. None entry_id object An optional id to uniquely identify the entry. None Source code in rxn_network/entries/interpolated.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 def __init__ ( self , composition : Composition , energy : float , correction : float = 0.0 , energy_adjustments : list = None , parameters : dict = None , data : dict = None , entry_id : object = None , ): \"\"\" Initializes an InterpolatedEntry. Args: composition (Composition): Composition of the entry. For flexibility, this can take the form of all the typical input taken by a Composition, including a {symbol: amt} dict, a string formula, and others. energy (float): Energy of the entry. Usually the final calculated energy from VASP or other electronic structure codes. correction (float): Manually set an energy correction, will ignore energy_adjustments if specified. energy_adjustments: An optional list of EnergyAdjustment to be applied to the energy. This is used to modify the energy for certain analyses. Defaults to None. parameters: An optional dict of parameters associated with the entry. Defaults to None. data: An optional dict of any additional data associated with the entry. Defaults to None. entry_id: An optional id to uniquely identify the entry. \"\"\" super () . __init__ ( composition , energy , correction = correction , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , )","title":"__init__()"},{"location":"reference/entries/interpolated/#rxn_network.entries.interpolated.InterpolatedEntry.is_experimental","text":"Returns True by default. Source code in rxn_network/entries/interpolated.py 70 71 72 73 @property def is_experimental ( self ) -> bool : \"\"\"Returns True by default.\"\"\" return False","title":"is_experimental()"},{"location":"reference/entries/interpolated/#rxn_network.entries.interpolated.InterpolatedEntry.to_grand_entry","text":"Convert a GibbsComputedEntry to a GrandComputedEntry. Parameters: Name Type Description Default chempots A dictionary of {element: chempot} pairs. required Returns: Type Description A GrandComputedEntry. Source code in rxn_network/entries/interpolated.py 58 59 60 61 62 63 64 65 66 67 68 def to_grand_entry ( self , chempots ): \"\"\" Convert a GibbsComputedEntry to a GrandComputedEntry. Args: chempots: A dictionary of {element: chempot} pairs. Returns: A GrandComputedEntry. \"\"\" return GrandPotPDEntry ( self , chempots )","title":"to_grand_entry()"},{"location":"reference/entries/nist/","text":"Implements an Entry that looks up pre-tabulated Gibbs free energies from the NIST-JANAF tables. NISTReferenceEntry Bases: ExperimentalReferenceEntry An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998. Source code in rxn_network/entries/nist.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class NISTReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998. \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , ) __init__ ( composition , temperature , energy_adjustments = None , data = None ) Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required data Optional [ Dict ] Optional dictionary containing entry data None Source code in rxn_network/entries/nist.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"Nist"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry","text":"Bases: ExperimentalReferenceEntry An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998. Source code in rxn_network/entries/nist.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 class NISTReferenceEntry ( ExperimentalReferenceEntry ): \"\"\" An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values. Reference: Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998. \"\"\" REFERENCES = G_COMPOUNDS def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"NISTReferenceEntry"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.__init__","text":"Parameters: Name Type Description Default composition Composition Composition object (within pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required data Optional [ Dict ] Optional dictionary containing entry data None Source code in rxn_network/entries/nist.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 def __init__ ( self , composition : Composition , temperature : float , energy_adjustments : Optional [ List [ EnergyAdjustment ]] = None , data : Optional [ Dict ] = None , ): \"\"\" Args: composition: Composition object (within pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. data: Optional dictionary containing entry data \"\"\" super () . __init__ ( composition = composition , temperature = temperature , energy_adjustments = energy_adjustments , data = data , )","title":"__init__()"},{"location":"reference/entries/utils/","text":"get_all_entries_in_chemsys ( db , elements , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , n = 1000 ) Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. WARNING This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required elements str or [str] Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure str If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. None property_data list Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False n int Chunk size, i.e., number of sub-chemical systems to consider 1000 Returns: Type Description List [ ComputedEntry ] List of ComputedEntries. Source code in rxn_network/entries/utils.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def get_all_entries_in_chemsys ( db : MongoStore , elements : Union [ str , List [ str ]], compatible_only : bool = True , inc_structure : Optional [ str ] = None , property_data : Optional [ list ] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , n : int = 1000 , ) -> List [ ComputedEntry ]: # noqa: MC0001 # pragma: no cover \"\"\" Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. WARNING: This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Args: db: MongoStore object with database connection elements (str or [str]): Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. compatible_only (bool): Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure (str): If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. property_data (list): Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell (bool): Whether to get the standard conventional unit cell n (int): Chunk size, i.e., number of sub-chemical systems to consider Returns: List of ComputedEntries. \"\"\" def divide_chunks ( my_list , n ): for i in range ( 0 , len ( my_list ), n ): yield my_list [ i : i + n ] if isinstance ( elements , str ): elements = elements . split ( \"-\" ) if len ( elements ) < 13 : all_chemsyses = [] for i in range ( len ( elements )): for els in itertools . combinations ( elements , i + 1 ): all_chemsyses . append ( \"-\" . join ( sorted ( els ))) all_chemsyses = list ( divide_chunks ( all_chemsyses , n )) entries = [] for chemsys_group in all_chemsyses : entries . extend ( get_entries ( db , { \"chemsys\" : { \"$in\" : chemsys_group }}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) ) else : # for very large chemical systems, use a different approach entries = get_entries ( db , { \"elements\" : { \"$not\" : { \"$elemMatch\" : { \"$nin\" : elements }}}}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) return entries get_entries ( db , chemsys_formula_id_criteria , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , sort_by_e_above_hull = False ) Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. WARNING This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required chemsys_formula_id_criteria Union [ str , dict ] A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure Optional [ str ] If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. None property_data Optional [ List [ str ]] Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False sort_by_e_above_hull bool Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). False Returns: Type Description List of ComputedEntry or ComputedStructureEntry objects. Source code in rxn_network/entries/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def get_entries ( # noqa: MC0001 db : MongoStore , chemsys_formula_id_criteria : Union [ str , dict ], compatible_only : bool = True , inc_structure : Optional [ str ] = None , property_data : Optional [ List [ str ]] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , sort_by_e_above_hull : bool = False , ): # pragma: no cover \"\"\" Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. WARNING: This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Args: db: MongoStore object with database connection chemsys_formula_id_criteria: A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. compatible_only: Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure: If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. property_data: Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell: Whether to get the standard conventional unit cell sort_by_e_above_hull: Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). Returns: List of ComputedEntry or ComputedStructureEntry objects. \"\"\" params = [ \"deprecated\" , \"run_type\" , \"is_hubbard\" , \"pseudo_potential\" , \"hubbards\" , \"potcar_symbols\" , \"oxide_type\" , ] props = [ \"final_energy\" , \"unit_cell_formula\" , \"task_id\" ] + params if sort_by_e_above_hull : if property_data and \"e_above_hull\" not in property_data : property_data . append ( \"e_above_hull\" ) elif not property_data : property_data = [ \"e_above_hull\" ] if property_data : props += property_data if inc_structure : if inc_structure == \"initial\" : props . append ( \"initial_structure\" ) else : props . append ( \"structure\" ) if not isinstance ( chemsys_formula_id_criteria , dict ): criteria = parse_criteria ( chemsys_formula_id_criteria ) else : criteria = chemsys_formula_id_criteria if use_premade_entries : props = [ \"entries\" , \"deprecated\" ] entries = [] for d in db . query ( criteria , props ): if d . get ( \"deprecated\" ): continue if use_premade_entries : ent = d [ \"entries\" ] if ent . get ( \"GGA\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA\" ]) elif ent . get ( \"GGA+U\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA+U\" ]) else : print ( f \"Missing entry for { d [ '_id' ] } \" ) continue else : d [ \"potcar_symbols\" ] = [ f \" { d [ 'pseudo_potential' ][ 'functional' ] } { label } \" for label in d [ \"pseudo_potential\" ] . get ( \"labels\" , []) ] data = { \"oxide_type\" : d [ \"oxide_type\" ]} if property_data : data . update ({ k : d [ k ] for k in property_data }) if not inc_structure : e = ComputedEntry ( d [ \"unit_cell_formula\" ], d [ \"final_energy\" ], parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) else : prim = Structure . from_dict ( d [ \"initial_structure\" ] if inc_structure == \"initial\" else d [ \"structure\" ] ) if conventional_unit_cell : s = SpacegroupAnalyzer ( prim ) . get_conventional_standard_structure () energy = d [ \"final_energy\" ] * ( len ( s ) / len ( prim )) else : s = prim . copy () energy = d [ \"final_energy\" ] e = ComputedStructureEntry ( s , energy , parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) entries . append ( e ) if compatible_only : with warnings . catch_warnings (): warnings . filterwarnings ( \"ignore\" , message = \"Failed to guess oxidation states.*\" ) entries = MaterialsProject2020Compatibility () . process_entries ( entries , clean = True ) if sort_by_e_above_hull : entries = sorted ( entries , key = lambda entry : entry . data [ \"e_above_hull\" ]) return entries initialize_entry ( formula , entry_set , stabilize = False ) Acquire a (stabilized) entry by user-specified formula. Parameters: Name Type Description Default formula str Chemical formula required entry_set GibbsEntrySet GibbsEntrySet containing 1 or more entries corresponding to given formula required stabilize bool Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' False Source code in rxn_network/entries/utils.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def initialize_entry ( formula : str , entry_set : GibbsEntrySet , stabilize : bool = False ): \"\"\" Acquire a (stabilized) entry by user-specified formula. Args: formula: Chemical formula entry_set: GibbsEntrySet containing 1 or more entries corresponding to given formula stabilize: Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' \"\"\" try : entry = entry_set . get_min_entry_by_formula ( formula ) except KeyError : entry = entry_set . get_interpolated_entry ( formula ) warnings . warn ( f \"Using interpolated entry for { entry . composition . reduced_formula } \" ) if stabilize : entry = entry_set . get_stabilized_entry ( entry ) return entry parse_criteria ( criteria_string ) Parses a powerful and simple string criteria and generates a proper mongo syntax criteria. Parameters: Name Type Description Default criteria_string str A string representing a search criteria. Also supports wild cards. E.g., something like \"*2O\" gets converted to {'pretty_formula': {'$in': [u'B2O', u'Xe2O', u\"Li2O\", ...]}} Other syntax examples: mp-1234: Interpreted as a Materials ID. Fe2O3 or 2O3: Interpreted as reduced formulas. Li-Fe-O or -Fe-O: Interpreted as chemical systems. You can mix and match with spaces, which are interpreted as \"OR\". E.g., \"mp-1234 FeO\" means query for all compounds with reduced formula FeO or with materials_id mp-1234. required Returns: Type Description A mongo query dict. Source code in rxn_network/entries/utils.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def parse_criteria ( criteria_string ): # pragma: no cover \"\"\" Parses a powerful and simple string criteria and generates a proper mongo syntax criteria. Args: criteria_string (str): A string representing a search criteria. Also supports wild cards. E.g., something like \"*2O\" gets converted to {'pretty_formula': {'$in': [u'B2O', u'Xe2O', u\"Li2O\", ...]}} Other syntax examples: mp-1234: Interpreted as a Materials ID. Fe2O3 or *2O3: Interpreted as reduced formulas. Li-Fe-O or *-Fe-O: Interpreted as chemical systems. You can mix and match with spaces, which are interpreted as \"OR\". E.g., \"mp-1234 FeO\" means query for all compounds with reduced formula FeO or with materials_id mp-1234. Returns: A mongo query dict. \"\"\" toks = criteria_string . split () def parse_sym ( sym ): if sym == \"*\" : return [ el . symbol for el in Element ] m = re . match ( r \"\\{(.*)\\}\" , sym ) if m : return [ s . strip () for s in m . group ( 1 ) . split ( \",\" )] return [ sym ] def parse_tok ( t ): if re . match ( r \"\\w+-\\d+\" , t ): return { \"task_id\" : t } if \"-\" in t : elements = [ parse_sym ( sym ) for sym in t . split ( \"-\" )] chemsyss = [] for cs in itertools . product ( * elements ): if len ( set ( cs )) == len ( cs ): # Check for valid symbols cs = [ Element ( s ) . symbol for s in cs ] chemsyss . append ( \"-\" . join ( sorted ( cs ))) return { \"chemsys\" : { \"$in\" : chemsyss }} all_formulas = set () explicit_els = [] wild_card_els = [] for sym in re . findall ( r \"(\\*[\\.\\d]*|\\{.*\\}[\\.\\d]*|[A-Z][a-z]*)[\\.\\d]*\" , t ): if ( \"*\" in sym ) or ( \"{\" in sym ): wild_card_els . append ( sym ) else : m = re . match ( r \"([A-Z][a-z]*)[\\.\\d]*\" , sym ) explicit_els . append ( m . group ( 1 )) nelements = len ( wild_card_els ) + len ( set ( explicit_els )) parts = re . split ( r \"(\\*|\\{.*\\})\" , t ) parts = [ parse_sym ( s ) for s in parts if s != \"\" ] for f in itertools . product ( * parts ): c = Composition ( \"\" . join ( f )) if len ( c ) == nelements : # Check for valid Elements in keys. for e in c : Element ( e . symbol ) all_formulas . add ( c . reduced_formula ) return { \"pretty_formula\" : { \"$in\" : list ( all_formulas )}} if len ( toks ) == 1 : return parse_tok ( toks [ 0 ]) return { \"$or\" : list ( map ( parse_tok , toks ))} process_entries ( entries , temperature , include_nist_data , include_barin_data , include_freed_data , e_above_hull , include_polymorphs , formulas_to_include , calculate_e_above_hulls = False ) Parameters: Name Type Description Default entries Iterable [ Entry ] Iterable of Entry objects to process. required temperature float Temperature (K) at which to build GibbsComputedEntry objects required include_nist_data bool Whether or not to include NIST data when constructing the GibbsComputedEntry objects. Defaults to True. required include_barin_data bool Whether or not to include Barin data when constructing the GibbsComputedEntry objects. Defaults to False. required e_above_hull float Only include entries with an energy above hull below this value (eV) required include_polymorphs bool Whether or not to include metastable polymorphs. Defaults to False. required formulas_to_include Iterable [ str ] Formulas to ensure are in the entries. required Returns: Type Description GibbsEntrySet A GibbsEntrySet object containing GibbsComputedEntry objects with specified GibbsEntrySet constraints. Source code in rxn_network/entries/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def process_entries ( entries : Iterable [ Entry ], temperature : float , include_nist_data : bool , include_barin_data : bool , include_freed_data : bool , e_above_hull : float , include_polymorphs : bool , formulas_to_include : Iterable [ str ], calculate_e_above_hulls : bool = False , ) -> GibbsEntrySet : \"\"\" Args: entries: Iterable of Entry objects to process. temperature (float): Temperature (K) at which to build GibbsComputedEntry objects include_nist_data (bool): Whether or not to include NIST data when constructing the GibbsComputedEntry objects. Defaults to True. include_barin_data (bool): Whether or not to include Barin data when constructing the GibbsComputedEntry objects. Defaults to False. e_above_hull (float): Only include entries with an energy above hull below this value (eV) include_polymorphs (bool): Whether or not to include metastable polymorphs. Defaults to False. formulas_to_include: Formulas to ensure are in the entries. Returns: A GibbsEntrySet object containing GibbsComputedEntry objects with specified constraints. \"\"\" entry_set = GibbsEntrySet . from_entries ( entries = entries , temperature = temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , ) entry_set = entry_set . filter_by_stability ( e_above_hull = e_above_hull , include_polymorphs = include_polymorphs ) if calculate_e_above_hulls : entry_set = GibbsEntrySet ( deepcopy ( entry_set ), calculate_e_above_hulls = True ) included_entries = [ initialize_entry ( f , entry_set ) for f in formulas_to_include ] entry_set . update ( included_entries ) return entry_set","title":"Utils"},{"location":"reference/entries/utils/#rxn_network.entries.utils.get_all_entries_in_chemsys","text":"Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. WARNING This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required elements str or [str] Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure str If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. None property_data list Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False n int Chunk size, i.e., number of sub-chemical systems to consider 1000 Returns: Type Description List [ ComputedEntry ] List of ComputedEntries. Source code in rxn_network/entries/utils.py 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def get_all_entries_in_chemsys ( db : MongoStore , elements : Union [ str , List [ str ]], compatible_only : bool = True , inc_structure : Optional [ str ] = None , property_data : Optional [ list ] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , n : int = 1000 , ) -> List [ ComputedEntry ]: # noqa: MC0001 # pragma: no cover \"\"\" Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. WARNING: This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Args: db: MongoStore object with database connection elements (str or [str]): Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. compatible_only (bool): Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure (str): If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. property_data (list): Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell (bool): Whether to get the standard conventional unit cell n (int): Chunk size, i.e., number of sub-chemical systems to consider Returns: List of ComputedEntries. \"\"\" def divide_chunks ( my_list , n ): for i in range ( 0 , len ( my_list ), n ): yield my_list [ i : i + n ] if isinstance ( elements , str ): elements = elements . split ( \"-\" ) if len ( elements ) < 13 : all_chemsyses = [] for i in range ( len ( elements )): for els in itertools . combinations ( elements , i + 1 ): all_chemsyses . append ( \"-\" . join ( sorted ( els ))) all_chemsyses = list ( divide_chunks ( all_chemsyses , n )) entries = [] for chemsys_group in all_chemsyses : entries . extend ( get_entries ( db , { \"chemsys\" : { \"$in\" : chemsys_group }}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) ) else : # for very large chemical systems, use a different approach entries = get_entries ( db , { \"elements\" : { \"$not\" : { \"$elemMatch\" : { \"$nin\" : elements }}}}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) return entries","title":"get_all_entries_in_chemsys()"},{"location":"reference/entries/utils/#rxn_network.entries.utils.get_entries","text":"Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. WARNING This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required chemsys_formula_id_criteria Union [ str , dict ] A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure Optional [ str ] If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. None property_data Optional [ List [ str ]] Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False sort_by_e_above_hull bool Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). False Returns: Type Description List of ComputedEntry or ComputedStructureEntry objects. Source code in rxn_network/entries/utils.py 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def get_entries ( # noqa: MC0001 db : MongoStore , chemsys_formula_id_criteria : Union [ str , dict ], compatible_only : bool = True , inc_structure : Optional [ str ] = None , property_data : Optional [ List [ str ]] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , sort_by_e_above_hull : bool = False , ): # pragma: no cover \"\"\" Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. WARNING: This function is legacy code directly adapted from pymatgen.ext.matproj. It is not broadly useful or applicable to other databases. It is only used in jobs interfaced directly with internal databases at Materials Project. This code is not adequately tested and may not work as expected. Args: db: MongoStore object with database connection chemsys_formula_id_criteria: A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. compatible_only: Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure: If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. property_data: Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell: Whether to get the standard conventional unit cell sort_by_e_above_hull: Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). Returns: List of ComputedEntry or ComputedStructureEntry objects. \"\"\" params = [ \"deprecated\" , \"run_type\" , \"is_hubbard\" , \"pseudo_potential\" , \"hubbards\" , \"potcar_symbols\" , \"oxide_type\" , ] props = [ \"final_energy\" , \"unit_cell_formula\" , \"task_id\" ] + params if sort_by_e_above_hull : if property_data and \"e_above_hull\" not in property_data : property_data . append ( \"e_above_hull\" ) elif not property_data : property_data = [ \"e_above_hull\" ] if property_data : props += property_data if inc_structure : if inc_structure == \"initial\" : props . append ( \"initial_structure\" ) else : props . append ( \"structure\" ) if not isinstance ( chemsys_formula_id_criteria , dict ): criteria = parse_criteria ( chemsys_formula_id_criteria ) else : criteria = chemsys_formula_id_criteria if use_premade_entries : props = [ \"entries\" , \"deprecated\" ] entries = [] for d in db . query ( criteria , props ): if d . get ( \"deprecated\" ): continue if use_premade_entries : ent = d [ \"entries\" ] if ent . get ( \"GGA\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA\" ]) elif ent . get ( \"GGA+U\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA+U\" ]) else : print ( f \"Missing entry for { d [ '_id' ] } \" ) continue else : d [ \"potcar_symbols\" ] = [ f \" { d [ 'pseudo_potential' ][ 'functional' ] } { label } \" for label in d [ \"pseudo_potential\" ] . get ( \"labels\" , []) ] data = { \"oxide_type\" : d [ \"oxide_type\" ]} if property_data : data . update ({ k : d [ k ] for k in property_data }) if not inc_structure : e = ComputedEntry ( d [ \"unit_cell_formula\" ], d [ \"final_energy\" ], parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) else : prim = Structure . from_dict ( d [ \"initial_structure\" ] if inc_structure == \"initial\" else d [ \"structure\" ] ) if conventional_unit_cell : s = SpacegroupAnalyzer ( prim ) . get_conventional_standard_structure () energy = d [ \"final_energy\" ] * ( len ( s ) / len ( prim )) else : s = prim . copy () energy = d [ \"final_energy\" ] e = ComputedStructureEntry ( s , energy , parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) entries . append ( e ) if compatible_only : with warnings . catch_warnings (): warnings . filterwarnings ( \"ignore\" , message = \"Failed to guess oxidation states.*\" ) entries = MaterialsProject2020Compatibility () . process_entries ( entries , clean = True ) if sort_by_e_above_hull : entries = sorted ( entries , key = lambda entry : entry . data [ \"e_above_hull\" ]) return entries","title":"get_entries()"},{"location":"reference/entries/utils/#rxn_network.entries.utils.initialize_entry","text":"Acquire a (stabilized) entry by user-specified formula. Parameters: Name Type Description Default formula str Chemical formula required entry_set GibbsEntrySet GibbsEntrySet containing 1 or more entries corresponding to given formula required stabilize bool Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' False Source code in rxn_network/entries/utils.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 def initialize_entry ( formula : str , entry_set : GibbsEntrySet , stabilize : bool = False ): \"\"\" Acquire a (stabilized) entry by user-specified formula. Args: formula: Chemical formula entry_set: GibbsEntrySet containing 1 or more entries corresponding to given formula stabilize: Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' \"\"\" try : entry = entry_set . get_min_entry_by_formula ( formula ) except KeyError : entry = entry_set . get_interpolated_entry ( formula ) warnings . warn ( f \"Using interpolated entry for { entry . composition . reduced_formula } \" ) if stabilize : entry = entry_set . get_stabilized_entry ( entry ) return entry","title":"initialize_entry()"},{"location":"reference/entries/utils/#rxn_network.entries.utils.parse_criteria","text":"Parses a powerful and simple string criteria and generates a proper mongo syntax criteria. Parameters: Name Type Description Default criteria_string str A string representing a search criteria. Also supports wild cards. E.g., something like \"*2O\" gets converted to {'pretty_formula': {'$in': [u'B2O', u'Xe2O', u\"Li2O\", ...]}} Other syntax examples: mp-1234: Interpreted as a Materials ID. Fe2O3 or 2O3: Interpreted as reduced formulas. Li-Fe-O or -Fe-O: Interpreted as chemical systems. You can mix and match with spaces, which are interpreted as \"OR\". E.g., \"mp-1234 FeO\" means query for all compounds with reduced formula FeO or with materials_id mp-1234. required Returns: Type Description A mongo query dict. Source code in rxn_network/entries/utils.py 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 def parse_criteria ( criteria_string ): # pragma: no cover \"\"\" Parses a powerful and simple string criteria and generates a proper mongo syntax criteria. Args: criteria_string (str): A string representing a search criteria. Also supports wild cards. E.g., something like \"*2O\" gets converted to {'pretty_formula': {'$in': [u'B2O', u'Xe2O', u\"Li2O\", ...]}} Other syntax examples: mp-1234: Interpreted as a Materials ID. Fe2O3 or *2O3: Interpreted as reduced formulas. Li-Fe-O or *-Fe-O: Interpreted as chemical systems. You can mix and match with spaces, which are interpreted as \"OR\". E.g., \"mp-1234 FeO\" means query for all compounds with reduced formula FeO or with materials_id mp-1234. Returns: A mongo query dict. \"\"\" toks = criteria_string . split () def parse_sym ( sym ): if sym == \"*\" : return [ el . symbol for el in Element ] m = re . match ( r \"\\{(.*)\\}\" , sym ) if m : return [ s . strip () for s in m . group ( 1 ) . split ( \",\" )] return [ sym ] def parse_tok ( t ): if re . match ( r \"\\w+-\\d+\" , t ): return { \"task_id\" : t } if \"-\" in t : elements = [ parse_sym ( sym ) for sym in t . split ( \"-\" )] chemsyss = [] for cs in itertools . product ( * elements ): if len ( set ( cs )) == len ( cs ): # Check for valid symbols cs = [ Element ( s ) . symbol for s in cs ] chemsyss . append ( \"-\" . join ( sorted ( cs ))) return { \"chemsys\" : { \"$in\" : chemsyss }} all_formulas = set () explicit_els = [] wild_card_els = [] for sym in re . findall ( r \"(\\*[\\.\\d]*|\\{.*\\}[\\.\\d]*|[A-Z][a-z]*)[\\.\\d]*\" , t ): if ( \"*\" in sym ) or ( \"{\" in sym ): wild_card_els . append ( sym ) else : m = re . match ( r \"([A-Z][a-z]*)[\\.\\d]*\" , sym ) explicit_els . append ( m . group ( 1 )) nelements = len ( wild_card_els ) + len ( set ( explicit_els )) parts = re . split ( r \"(\\*|\\{.*\\})\" , t ) parts = [ parse_sym ( s ) for s in parts if s != \"\" ] for f in itertools . product ( * parts ): c = Composition ( \"\" . join ( f )) if len ( c ) == nelements : # Check for valid Elements in keys. for e in c : Element ( e . symbol ) all_formulas . add ( c . reduced_formula ) return { \"pretty_formula\" : { \"$in\" : list ( all_formulas )}} if len ( toks ) == 1 : return parse_tok ( toks [ 0 ]) return { \"$or\" : list ( map ( parse_tok , toks ))}","title":"parse_criteria()"},{"location":"reference/entries/utils/#rxn_network.entries.utils.process_entries","text":"Parameters: Name Type Description Default entries Iterable [ Entry ] Iterable of Entry objects to process. required temperature float Temperature (K) at which to build GibbsComputedEntry objects required include_nist_data bool Whether or not to include NIST data when constructing the GibbsComputedEntry objects. Defaults to True. required include_barin_data bool Whether or not to include Barin data when constructing the GibbsComputedEntry objects. Defaults to False. required e_above_hull float Only include entries with an energy above hull below this value (eV) required include_polymorphs bool Whether or not to include metastable polymorphs. Defaults to False. required formulas_to_include Iterable [ str ] Formulas to ensure are in the entries. required Returns: Type Description GibbsEntrySet A GibbsEntrySet object containing GibbsComputedEntry objects with specified GibbsEntrySet constraints. Source code in rxn_network/entries/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 def process_entries ( entries : Iterable [ Entry ], temperature : float , include_nist_data : bool , include_barin_data : bool , include_freed_data : bool , e_above_hull : float , include_polymorphs : bool , formulas_to_include : Iterable [ str ], calculate_e_above_hulls : bool = False , ) -> GibbsEntrySet : \"\"\" Args: entries: Iterable of Entry objects to process. temperature (float): Temperature (K) at which to build GibbsComputedEntry objects include_nist_data (bool): Whether or not to include NIST data when constructing the GibbsComputedEntry objects. Defaults to True. include_barin_data (bool): Whether or not to include Barin data when constructing the GibbsComputedEntry objects. Defaults to False. e_above_hull (float): Only include entries with an energy above hull below this value (eV) include_polymorphs (bool): Whether or not to include metastable polymorphs. Defaults to False. formulas_to_include: Formulas to ensure are in the entries. Returns: A GibbsEntrySet object containing GibbsComputedEntry objects with specified constraints. \"\"\" entry_set = GibbsEntrySet . from_entries ( entries = entries , temperature = temperature , include_nist_data = include_nist_data , include_barin_data = include_barin_data , include_freed_data = include_freed_data , ) entry_set = entry_set . filter_by_stability ( e_above_hull = e_above_hull , include_polymorphs = include_polymorphs ) if calculate_e_above_hulls : entry_set = GibbsEntrySet ( deepcopy ( entry_set ), calculate_e_above_hulls = True ) included_entries = [ initialize_entry ( f , entry_set ) for f in formulas_to_include ] entry_set . update ( included_entries ) return entry_set","title":"process_entries()"},{"location":"reference/enumerators/basic/","text":"This module implements two types of basic reaction enumerators, differing in the option to consider open entries. BasicEnumerator Bases: Enumerator Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n); i.e., how many phases on either side of the reaction. This approach does not explicitly take into account thermodynamic stability (i.e. phase diagram). This allows for enumeration of reactions where the products may not be stable with respect to each other. Source code in rxn_network/enumerators/basic.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 class BasicEnumerator ( Enumerator ): \"\"\" Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n); i.e., how many phases on either side of the reaction. This approach does not explicitly take into account thermodynamic stability (i.e. phase diagram). This allows for enumeration of reactions where the products may not be stable with respect to each other. \"\"\" CHUNK_SIZE = 2500 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. targets: Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. exclusive_targets: Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. calculate_e_above_hulls: Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets ) self . n = n self . exclusive_precursors = exclusive_precursors self . exclusive_targets = exclusive_targets self . filter_by_chemsys = filter_by_chemsys self . max_num_constraints = max_num_constraints self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . calculate_e_above_hulls = calculate_e_above_hulls self . quiet = quiet self . _stabilize = False self . _p_set_func = \"issuperset\" if self . exclusive_precursors else \"intersection\" self . _t_set_func = \"issuperset\" if self . exclusive_targets else \"intersection\" self . open_phases : Optional [ List ] = None self . _build_pd = False self . _build_grand_pd = False def enumerate ( self , entries : GibbsEntrySet , batch_size = None ) -> ReactionSet : \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" initialize_ray () entries , precursors , targets , open_entries = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , targets , open_entries , ) open_combos = self . _get_open_combos ( open_entries ) if not open_combos : open_combos = [] items = combos_dict . items () precursors = ray . put ( precursors ) targets = ray . put ( targets ) react_function = ray . put ( self . _react_function ) open_entries = ray . put ( open_entries ) p_set_func = ray . put ( self . _p_set_func ) t_set_func = ray . put ( self . _t_set_func ) remove_unbalanced = ray . put ( self . remove_unbalanced ) remove_changed = ray . put ( self . remove_changed ) max_num_constraints = ray . put ( self . max_num_constraints ) rxn_chunk_refs = [] # type: ignore results = [] if not batch_size : batch_size = ray . cluster_resources ()[ \"CPU\" ] * 2 with tqdm ( total = self . _num_chunks ( items , open_combos ), disable = self . quiet ) as pbar : for item in items : chemsys , combos = item elems = chemsys . split ( \"-\" ) filtered_entries = None pd = None grand_pd = None if self . build_pd or self . build_grand_pd : filtered_entries = entries . get_subset_in_chemsys ( elems ) if self . build_pd : pd = PhaseDiagram ( filtered_entries ) if self . build_grand_pd : chempots = getattr ( self , \"chempots\" ) grand_pd = GrandPotentialPhaseDiagram ( filtered_entries , chempots ) filtered_entries = ray . put ( filtered_entries ) pd = ray . put ( pd ) grand_pd = ray . put ( grand_pd ) for rxn_iterable_chunk in grouper ( self . _get_rxn_iterable ( combos , open_combos ), self . CHUNK_SIZE ): if len ( rxn_chunk_refs ) > batch_size : num_ready = len ( rxn_chunk_refs ) - batch_size newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = num_ready ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) rxn_chunk_refs . append ( _react . remote ( rxn_iterable_chunk , react_function , open_entries , precursors , targets , p_set_func , t_set_func , remove_unbalanced , remove_changed , max_num_constraints , filtered_entries , pd , grand_pd , ) ) newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = len ( rxn_chunk_refs ) ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) all_indices , all_coeffs , all_data = [], [], [] for r in results : all_indices . append ( r [ 0 ]) all_coeffs . append ( r [ 1 ]) all_data . append ( r [ 2 ]) rxn_set = ReactionSet ( entries . entries_list , all_indices , all_coeffs , all_data = all_data ) rxn_set = rxn_set . filter_duplicates () return rxn_set @classmethod def _num_chunks ( cls , items , open_combos ): _ = open_combos # not used n = 0 for _ , i in items : num_combos = cls . _rxn_iter_length ( i , open_combos ) if num_combos > 0 : n += num_combos // cls . CHUNK_SIZE + 1 return n @staticmethod def _rxn_iter_length ( combos , open_combos ): _ = open_combos # not used return comb ( len ( combos ), 2 ) def _get_combos_dict ( self , entries , precursor_entries , target_entries , open_entries ): \"\"\" Gets all possible entry combinations up to predefined cardinality (n), filtered and grouped by chemical system. \"\"\" precursor_elems = [ [ str ( el ) for el in e . composition . elements ] for e in precursor_entries ] target_elems = [ [ str ( el ) for el in e . composition . elements ] for e in target_entries ] all_open_elems = { el for e in open_entries for el in e . composition . elements } entries = entries - open_entries combos = [ set ( c ) for c in limited_powerset ( entries , self . n )] combos_dict = group_by_chemsys ( combos , all_open_elems ) filtered_combos = self . _filter_dict_by_elems ( combos_dict , precursor_elems , target_elems , all_open_elems , ) return filtered_combos def _get_open_combos ( # pylint: disable=useless-return self , open_entries ) -> Optional [ List [ Set [ ComputedEntry ]]]: \"\"\"No open entries for BasicEnumerator, returns None\"\"\" _ = ( self , open_entries ) # unused_arguments return None @staticmethod def _react_function ( reactants , products , ** kwargs ): _ = kwargs # unused_argument forward_rxn = ComputedReaction . balance ( reactants , products ) backward_rxn = forward_rxn . reverse () return [ forward_rxn , backward_rxn ] @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Get all reaction/product combinations\"\"\" _ = open_combos # unused argument return combinations ( combos , 2 ) def _get_initialized_entries ( self , entries ): \"\"\"Returns initialized entries, precursors, target, and open entries\"\"\" def initialize_entries_list ( ents ): new_ents = { initialize_entry ( f , entries , self . stabilize ) for f in ents } return new_ents precursors , targets = set (), set () entries_new = GibbsEntrySet ( deepcopy ( entries ), calculate_e_above_hulls = self . calculate_e_above_hulls ) if self . precursors : precursors = initialize_entries_list ( self . precursors ) if self . targets : targets = initialize_entries_list ( self . targets ) for e in precursors | targets : if e not in entries_new : try : old_e = entries_new . get_min_entry_by_formula ( e . composition . reduced_formula ) entries_new . discard ( old_e ) except KeyError : pass entries_new . add ( e ) if self . stabilize : entries_new = entries_new . filter_by_stability ( e_above_hull = 0.0 ) logger . info ( \"Filtering by stable entries!\" ) entries_new . build_indices () open_entries = set () if self . open_phases : open_entries = { e for e in entries_new if e . composition . reduced_formula in self . open_phases } return entries_new , precursors , targets , open_entries def _filter_dict_by_elems ( self , combos_dict , precursor_elems , target_elems , all_open_elems , ): \"\"\"Filters the dictionary of combinations by elements\"\"\" filtered_dict = {} all_precursor_elems = { el for g in precursor_elems for el in g } all_target_elems = { el for g in target_elems for el in g } all_open_elems = { str ( el ) for el in all_open_elems } filter_elems = None if self . filter_by_chemsys : filter_elems = set ( self . filter_by_chemsys . split ( \"-\" )) for chemsys , combos in combos_dict . items (): elems = set ( chemsys . split ( \"-\" )) if filter_elems : if not elems . issuperset ( filter_elems ): continue if len ( elems ) >= 10 or len ( elems ) == 1 : # too few or too many elements continue if precursor_elems : if not getattr ( all_precursor_elems | all_open_elems , self . _p_set_func )( elems ): continue if target_elems : if not getattr ( all_target_elems | all_open_elems , self . _t_set_func )( elems ): continue filtered_dict [ chemsys ] = combos return filtered_dict @property def stabilize ( self ): \"\"\"Whether or not to use only stable entries in analysis\"\"\" return self . _stabilize @property def build_pd ( self ): \"\"\"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses)\"\"\" return self . _build_pd @property def build_grand_pd ( self ): \"\"\"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses)\"\"\" return self . _build_grand_pd __init__ ( precursors = None , targets = None , n = 2 , exclusive_precursors = True , exclusive_targets = False , filter_by_chemsys = None , max_num_constraints = 1 , remove_unbalanced = True , remove_changed = True , calculate_e_above_hulls = False , quiet = False ) Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default precursors Optional [ List [ str ]] Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. None targets Optional [ List [ str ]] Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. 2 exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. False remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True. True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True calculate_e_above_hulls bool Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/basic.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. targets: Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. exclusive_targets: Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. calculate_e_above_hulls: Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets ) self . n = n self . exclusive_precursors = exclusive_precursors self . exclusive_targets = exclusive_targets self . filter_by_chemsys = filter_by_chemsys self . max_num_constraints = max_num_constraints self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . calculate_e_above_hulls = calculate_e_above_hulls self . quiet = quiet self . _stabilize = False self . _p_set_func = \"issuperset\" if self . exclusive_precursors else \"intersection\" self . _t_set_func = \"issuperset\" if self . exclusive_targets else \"intersection\" self . open_phases : Optional [ List ] = None self . _build_pd = False self . _build_grand_pd = False build_grand_pd () property Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses) Source code in rxn_network/enumerators/basic.py 409 410 411 412 413 @property def build_grand_pd ( self ): \"\"\"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses)\"\"\" return self . _build_grand_pd build_pd () property Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses) Source code in rxn_network/enumerators/basic.py 403 404 405 406 407 @property def build_pd ( self ): \"\"\"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses)\"\"\" return self . _build_pd enumerate ( entries , batch_size = None ) Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Parameters: Name Type Description Default entries GibbsEntrySet the set of all entries to enumerate from required Source code in rxn_network/enumerators/basic.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def enumerate ( self , entries : GibbsEntrySet , batch_size = None ) -> ReactionSet : \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" initialize_ray () entries , precursors , targets , open_entries = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , targets , open_entries , ) open_combos = self . _get_open_combos ( open_entries ) if not open_combos : open_combos = [] items = combos_dict . items () precursors = ray . put ( precursors ) targets = ray . put ( targets ) react_function = ray . put ( self . _react_function ) open_entries = ray . put ( open_entries ) p_set_func = ray . put ( self . _p_set_func ) t_set_func = ray . put ( self . _t_set_func ) remove_unbalanced = ray . put ( self . remove_unbalanced ) remove_changed = ray . put ( self . remove_changed ) max_num_constraints = ray . put ( self . max_num_constraints ) rxn_chunk_refs = [] # type: ignore results = [] if not batch_size : batch_size = ray . cluster_resources ()[ \"CPU\" ] * 2 with tqdm ( total = self . _num_chunks ( items , open_combos ), disable = self . quiet ) as pbar : for item in items : chemsys , combos = item elems = chemsys . split ( \"-\" ) filtered_entries = None pd = None grand_pd = None if self . build_pd or self . build_grand_pd : filtered_entries = entries . get_subset_in_chemsys ( elems ) if self . build_pd : pd = PhaseDiagram ( filtered_entries ) if self . build_grand_pd : chempots = getattr ( self , \"chempots\" ) grand_pd = GrandPotentialPhaseDiagram ( filtered_entries , chempots ) filtered_entries = ray . put ( filtered_entries ) pd = ray . put ( pd ) grand_pd = ray . put ( grand_pd ) for rxn_iterable_chunk in grouper ( self . _get_rxn_iterable ( combos , open_combos ), self . CHUNK_SIZE ): if len ( rxn_chunk_refs ) > batch_size : num_ready = len ( rxn_chunk_refs ) - batch_size newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = num_ready ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) rxn_chunk_refs . append ( _react . remote ( rxn_iterable_chunk , react_function , open_entries , precursors , targets , p_set_func , t_set_func , remove_unbalanced , remove_changed , max_num_constraints , filtered_entries , pd , grand_pd , ) ) newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = len ( rxn_chunk_refs ) ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) all_indices , all_coeffs , all_data = [], [], [] for r in results : all_indices . append ( r [ 0 ]) all_coeffs . append ( r [ 1 ]) all_data . append ( r [ 2 ]) rxn_set = ReactionSet ( entries . entries_list , all_indices , all_coeffs , all_data = all_data ) rxn_set = rxn_set . filter_duplicates () return rxn_set stabilize () property Whether or not to use only stable entries in analysis Source code in rxn_network/enumerators/basic.py 398 399 400 401 @property def stabilize ( self ): \"\"\"Whether or not to use only stable entries in analysis\"\"\" return self . _stabilize BasicOpenEnumerator Bases: BasicEnumerator Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class). Source code in rxn_network/enumerators/basic.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 class BasicOpenEnumerator ( BasicEnumerator ): \"\"\" Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class). \"\"\" CHUNK_SIZE = 2500 def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. targets: Optional list of formulas of targets; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , n = n , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , max_num_constraints = max_num_constraints , remove_unbalanced = remove_unbalanced , remove_changed = remove_changed , ) self . open_phases : List [ str ] = open_phases @staticmethod def _rxn_iter_length ( combos , open_combos ): num_combos_with_open = sum ( 1 if not i & j else 0 for i in combos for j in open_combos ) return len ( combos ) * num_combos_with_open def _get_open_combos ( self , open_entries ): \"\"\"Get all possible combinations of open entries. For a single entry, this is just the entry itself.\"\"\" open_combos = [ set ( c ) for c in limited_powerset ( open_entries , len ( open_entries )) ] return open_combos @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Get all reaction/product combinations.\"\"\" combos_with_open = [ combo | open_combo for combo in combos for open_combo in open_combos if not combo & open_combo ] rxn_iter = product ( combos , combos_with_open ) return rxn_iter __init__ ( open_phases , precursors = None , targets = None , n = 2 , exclusive_precursors = True , exclusive_targets = False , filter_by_chemsys = None , max_num_constraints = 1 , remove_unbalanced = True , remove_changed = True , calculate_e_above_hulls = False , quiet = False ) Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default open_phases List [ str ] List of formulas of open entries (e.g. [\"O2\"]) required precursors Optional [ List [ str ]] Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. None targets Optional [ List [ str ]] Optional list of formulas of targets; only reactions which make this target will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). required n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. 2 exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/basic.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. targets: Optional list of formulas of targets; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , n = n , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , max_num_constraints = max_num_constraints , remove_unbalanced = remove_unbalanced , remove_changed = remove_changed , ) self . open_phases : List [ str ] = open_phases","title":"Basic"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator","text":"Bases: Enumerator Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n); i.e., how many phases on either side of the reaction. This approach does not explicitly take into account thermodynamic stability (i.e. phase diagram). This allows for enumeration of reactions where the products may not be stable with respect to each other. Source code in rxn_network/enumerators/basic.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 class BasicEnumerator ( Enumerator ): \"\"\" Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n); i.e., how many phases on either side of the reaction. This approach does not explicitly take into account thermodynamic stability (i.e. phase diagram). This allows for enumeration of reactions where the products may not be stable with respect to each other. \"\"\" CHUNK_SIZE = 2500 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. targets: Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. exclusive_targets: Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. calculate_e_above_hulls: Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets ) self . n = n self . exclusive_precursors = exclusive_precursors self . exclusive_targets = exclusive_targets self . filter_by_chemsys = filter_by_chemsys self . max_num_constraints = max_num_constraints self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . calculate_e_above_hulls = calculate_e_above_hulls self . quiet = quiet self . _stabilize = False self . _p_set_func = \"issuperset\" if self . exclusive_precursors else \"intersection\" self . _t_set_func = \"issuperset\" if self . exclusive_targets else \"intersection\" self . open_phases : Optional [ List ] = None self . _build_pd = False self . _build_grand_pd = False def enumerate ( self , entries : GibbsEntrySet , batch_size = None ) -> ReactionSet : \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" initialize_ray () entries , precursors , targets , open_entries = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , targets , open_entries , ) open_combos = self . _get_open_combos ( open_entries ) if not open_combos : open_combos = [] items = combos_dict . items () precursors = ray . put ( precursors ) targets = ray . put ( targets ) react_function = ray . put ( self . _react_function ) open_entries = ray . put ( open_entries ) p_set_func = ray . put ( self . _p_set_func ) t_set_func = ray . put ( self . _t_set_func ) remove_unbalanced = ray . put ( self . remove_unbalanced ) remove_changed = ray . put ( self . remove_changed ) max_num_constraints = ray . put ( self . max_num_constraints ) rxn_chunk_refs = [] # type: ignore results = [] if not batch_size : batch_size = ray . cluster_resources ()[ \"CPU\" ] * 2 with tqdm ( total = self . _num_chunks ( items , open_combos ), disable = self . quiet ) as pbar : for item in items : chemsys , combos = item elems = chemsys . split ( \"-\" ) filtered_entries = None pd = None grand_pd = None if self . build_pd or self . build_grand_pd : filtered_entries = entries . get_subset_in_chemsys ( elems ) if self . build_pd : pd = PhaseDiagram ( filtered_entries ) if self . build_grand_pd : chempots = getattr ( self , \"chempots\" ) grand_pd = GrandPotentialPhaseDiagram ( filtered_entries , chempots ) filtered_entries = ray . put ( filtered_entries ) pd = ray . put ( pd ) grand_pd = ray . put ( grand_pd ) for rxn_iterable_chunk in grouper ( self . _get_rxn_iterable ( combos , open_combos ), self . CHUNK_SIZE ): if len ( rxn_chunk_refs ) > batch_size : num_ready = len ( rxn_chunk_refs ) - batch_size newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = num_ready ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) rxn_chunk_refs . append ( _react . remote ( rxn_iterable_chunk , react_function , open_entries , precursors , targets , p_set_func , t_set_func , remove_unbalanced , remove_changed , max_num_constraints , filtered_entries , pd , grand_pd , ) ) newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = len ( rxn_chunk_refs ) ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) all_indices , all_coeffs , all_data = [], [], [] for r in results : all_indices . append ( r [ 0 ]) all_coeffs . append ( r [ 1 ]) all_data . append ( r [ 2 ]) rxn_set = ReactionSet ( entries . entries_list , all_indices , all_coeffs , all_data = all_data ) rxn_set = rxn_set . filter_duplicates () return rxn_set @classmethod def _num_chunks ( cls , items , open_combos ): _ = open_combos # not used n = 0 for _ , i in items : num_combos = cls . _rxn_iter_length ( i , open_combos ) if num_combos > 0 : n += num_combos // cls . CHUNK_SIZE + 1 return n @staticmethod def _rxn_iter_length ( combos , open_combos ): _ = open_combos # not used return comb ( len ( combos ), 2 ) def _get_combos_dict ( self , entries , precursor_entries , target_entries , open_entries ): \"\"\" Gets all possible entry combinations up to predefined cardinality (n), filtered and grouped by chemical system. \"\"\" precursor_elems = [ [ str ( el ) for el in e . composition . elements ] for e in precursor_entries ] target_elems = [ [ str ( el ) for el in e . composition . elements ] for e in target_entries ] all_open_elems = { el for e in open_entries for el in e . composition . elements } entries = entries - open_entries combos = [ set ( c ) for c in limited_powerset ( entries , self . n )] combos_dict = group_by_chemsys ( combos , all_open_elems ) filtered_combos = self . _filter_dict_by_elems ( combos_dict , precursor_elems , target_elems , all_open_elems , ) return filtered_combos def _get_open_combos ( # pylint: disable=useless-return self , open_entries ) -> Optional [ List [ Set [ ComputedEntry ]]]: \"\"\"No open entries for BasicEnumerator, returns None\"\"\" _ = ( self , open_entries ) # unused_arguments return None @staticmethod def _react_function ( reactants , products , ** kwargs ): _ = kwargs # unused_argument forward_rxn = ComputedReaction . balance ( reactants , products ) backward_rxn = forward_rxn . reverse () return [ forward_rxn , backward_rxn ] @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Get all reaction/product combinations\"\"\" _ = open_combos # unused argument return combinations ( combos , 2 ) def _get_initialized_entries ( self , entries ): \"\"\"Returns initialized entries, precursors, target, and open entries\"\"\" def initialize_entries_list ( ents ): new_ents = { initialize_entry ( f , entries , self . stabilize ) for f in ents } return new_ents precursors , targets = set (), set () entries_new = GibbsEntrySet ( deepcopy ( entries ), calculate_e_above_hulls = self . calculate_e_above_hulls ) if self . precursors : precursors = initialize_entries_list ( self . precursors ) if self . targets : targets = initialize_entries_list ( self . targets ) for e in precursors | targets : if e not in entries_new : try : old_e = entries_new . get_min_entry_by_formula ( e . composition . reduced_formula ) entries_new . discard ( old_e ) except KeyError : pass entries_new . add ( e ) if self . stabilize : entries_new = entries_new . filter_by_stability ( e_above_hull = 0.0 ) logger . info ( \"Filtering by stable entries!\" ) entries_new . build_indices () open_entries = set () if self . open_phases : open_entries = { e for e in entries_new if e . composition . reduced_formula in self . open_phases } return entries_new , precursors , targets , open_entries def _filter_dict_by_elems ( self , combos_dict , precursor_elems , target_elems , all_open_elems , ): \"\"\"Filters the dictionary of combinations by elements\"\"\" filtered_dict = {} all_precursor_elems = { el for g in precursor_elems for el in g } all_target_elems = { el for g in target_elems for el in g } all_open_elems = { str ( el ) for el in all_open_elems } filter_elems = None if self . filter_by_chemsys : filter_elems = set ( self . filter_by_chemsys . split ( \"-\" )) for chemsys , combos in combos_dict . items (): elems = set ( chemsys . split ( \"-\" )) if filter_elems : if not elems . issuperset ( filter_elems ): continue if len ( elems ) >= 10 or len ( elems ) == 1 : # too few or too many elements continue if precursor_elems : if not getattr ( all_precursor_elems | all_open_elems , self . _p_set_func )( elems ): continue if target_elems : if not getattr ( all_target_elems | all_open_elems , self . _t_set_func )( elems ): continue filtered_dict [ chemsys ] = combos return filtered_dict @property def stabilize ( self ): \"\"\"Whether or not to use only stable entries in analysis\"\"\" return self . _stabilize @property def build_pd ( self ): \"\"\"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses)\"\"\" return self . _build_pd @property def build_grand_pd ( self ): \"\"\"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses)\"\"\" return self . _build_grand_pd","title":"BasicEnumerator"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.__init__","text":"Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default precursors Optional [ List [ str ]] Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. None targets Optional [ List [ str ]] Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. 2 exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. False remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True. True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True calculate_e_above_hulls bool Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/basic.py 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. See the \"exclusive_precursors\" parameter for more details. targets: Optional list of target formulas; only reactions which include formation of at least one of these targets will be enumerated. See the \"exclusive_targets\" parameter for more details. n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. In other words, if True, this only identifies reactions with reactants selected from the precursors argument. Defaults to True. exclusive_targets: Whether to consider only reactions that make the form products that are a subset of the provided list of targets. If False, this only identifies reactions with no unspecified byproducts. Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. calculate_e_above_hulls: Whether to calculate e_above_hull for each entry upon initialization of the entries at the beginning of enumeration. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets ) self . n = n self . exclusive_precursors = exclusive_precursors self . exclusive_targets = exclusive_targets self . filter_by_chemsys = filter_by_chemsys self . max_num_constraints = max_num_constraints self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . calculate_e_above_hulls = calculate_e_above_hulls self . quiet = quiet self . _stabilize = False self . _p_set_func = \"issuperset\" if self . exclusive_precursors else \"intersection\" self . _t_set_func = \"issuperset\" if self . exclusive_targets else \"intersection\" self . open_phases : Optional [ List ] = None self . _build_pd = False self . _build_grand_pd = False","title":"__init__()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.build_grand_pd","text":"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses) Source code in rxn_network/enumerators/basic.py 409 410 411 412 413 @property def build_grand_pd ( self ): \"\"\"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses)\"\"\" return self . _build_grand_pd","title":"build_grand_pd()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.build_pd","text":"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses) Source code in rxn_network/enumerators/basic.py 403 404 405 406 407 @property def build_pd ( self ): \"\"\"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses)\"\"\" return self . _build_pd","title":"build_pd()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.enumerate","text":"Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Parameters: Name Type Description Default entries GibbsEntrySet the set of all entries to enumerate from required Source code in rxn_network/enumerators/basic.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 def enumerate ( self , entries : GibbsEntrySet , batch_size = None ) -> ReactionSet : \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e., ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible \"node\", i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant; i.e., don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" initialize_ray () entries , precursors , targets , open_entries = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , targets , open_entries , ) open_combos = self . _get_open_combos ( open_entries ) if not open_combos : open_combos = [] items = combos_dict . items () precursors = ray . put ( precursors ) targets = ray . put ( targets ) react_function = ray . put ( self . _react_function ) open_entries = ray . put ( open_entries ) p_set_func = ray . put ( self . _p_set_func ) t_set_func = ray . put ( self . _t_set_func ) remove_unbalanced = ray . put ( self . remove_unbalanced ) remove_changed = ray . put ( self . remove_changed ) max_num_constraints = ray . put ( self . max_num_constraints ) rxn_chunk_refs = [] # type: ignore results = [] if not batch_size : batch_size = ray . cluster_resources ()[ \"CPU\" ] * 2 with tqdm ( total = self . _num_chunks ( items , open_combos ), disable = self . quiet ) as pbar : for item in items : chemsys , combos = item elems = chemsys . split ( \"-\" ) filtered_entries = None pd = None grand_pd = None if self . build_pd or self . build_grand_pd : filtered_entries = entries . get_subset_in_chemsys ( elems ) if self . build_pd : pd = PhaseDiagram ( filtered_entries ) if self . build_grand_pd : chempots = getattr ( self , \"chempots\" ) grand_pd = GrandPotentialPhaseDiagram ( filtered_entries , chempots ) filtered_entries = ray . put ( filtered_entries ) pd = ray . put ( pd ) grand_pd = ray . put ( grand_pd ) for rxn_iterable_chunk in grouper ( self . _get_rxn_iterable ( combos , open_combos ), self . CHUNK_SIZE ): if len ( rxn_chunk_refs ) > batch_size : num_ready = len ( rxn_chunk_refs ) - batch_size newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = num_ready ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) rxn_chunk_refs . append ( _react . remote ( rxn_iterable_chunk , react_function , open_entries , precursors , targets , p_set_func , t_set_func , remove_unbalanced , remove_changed , max_num_constraints , filtered_entries , pd , grand_pd , ) ) newly_completed , rxn_chunk_refs = ray . wait ( rxn_chunk_refs , num_returns = len ( rxn_chunk_refs ) ) for completed_ref in newly_completed : results . extend ( ray . get ( completed_ref )) pbar . update ( 1 ) all_indices , all_coeffs , all_data = [], [], [] for r in results : all_indices . append ( r [ 0 ]) all_coeffs . append ( r [ 1 ]) all_data . append ( r [ 2 ]) rxn_set = ReactionSet ( entries . entries_list , all_indices , all_coeffs , all_data = all_data ) rxn_set = rxn_set . filter_duplicates () return rxn_set","title":"enumerate()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.stabilize","text":"Whether or not to use only stable entries in analysis Source code in rxn_network/enumerators/basic.py 398 399 400 401 @property def stabilize ( self ): \"\"\"Whether or not to use only stable entries in analysis\"\"\" return self . _stabilize","title":"stabilize()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicOpenEnumerator","text":"Bases: BasicEnumerator Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class). Source code in rxn_network/enumerators/basic.py 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 class BasicOpenEnumerator ( BasicEnumerator ): \"\"\" Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class). \"\"\" CHUNK_SIZE = 2500 def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. targets: Optional list of formulas of targets; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , n = n , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , max_num_constraints = max_num_constraints , remove_unbalanced = remove_unbalanced , remove_changed = remove_changed , ) self . open_phases : List [ str ] = open_phases @staticmethod def _rxn_iter_length ( combos , open_combos ): num_combos_with_open = sum ( 1 if not i & j else 0 for i in combos for j in open_combos ) return len ( combos ) * num_combos_with_open def _get_open_combos ( self , open_entries ): \"\"\"Get all possible combinations of open entries. For a single entry, this is just the entry itself.\"\"\" open_combos = [ set ( c ) for c in limited_powerset ( open_entries , len ( open_entries )) ] return open_combos @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Get all reaction/product combinations.\"\"\" combos_with_open = [ combo | open_combo for combo in combos for open_combo in open_combos if not combo & open_combo ] rxn_iter = product ( combos , combos_with_open ) return rxn_iter","title":"BasicOpenEnumerator"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicOpenEnumerator.__init__","text":"Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default open_phases List [ str ] List of formulas of open entries (e.g. [\"O2\"]) required precursors Optional [ List [ str ]] Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. None targets Optional [ List [ str ]] Optional list of formulas of targets; only reactions which make this target will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). required n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. 2 exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/basic.py 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , n : int = 2 , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , remove_unbalanced : bool = True , remove_changed : bool = True , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. targets: Optional list of formulas of targets; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , n = n , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , max_num_constraints = max_num_constraints , remove_unbalanced = remove_unbalanced , remove_changed = remove_changed , ) self . open_phases : List [ str ] = open_phases","title":"__init__()"},{"location":"reference/enumerators/minimize/","text":"This module implements two types of reaction enumerators using a free energy minimization technique, with or without the option of an open entry. MinimizeGibbsEnumerator Bases: BasicEnumerator Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded. Source code in rxn_network/enumerators/minimize.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class MinimizeGibbsEnumerator ( BasicEnumerator ): \"\"\" Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded. \"\"\" CHUNK_SIZE = 10000 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Args: precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . _build_pd = True @staticmethod def _react_function ( reactants , products , filtered_entries = None , pd = None , grand_pd = None , ** kwargs ): \"\"\"React method for MinimizeGibbsEnumerator, which uses the interfacial reaction approach (see _react_interface())\"\"\" r = list ( reactants ) r0 = r [ 0 ] if len ( r ) == 1 : r1 = r [ 0 ] else : r1 = r [ 1 ] return react_interface ( r0 . composition , r1 . composition , filtered_entries , pd , grand_pd , ) @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Gets the iterable used to generate reactions\"\"\" _ = open_combos # unused argument return product ( combos , [ None ]) @staticmethod def _rxn_iter_length ( combos , open_combos ): _ = open_combos return len ( combos ) __init__ ( precursors = None , targets = None , exclusive_precursors = True , exclusive_targets = False , filter_by_chemsys = None , max_num_constraints = 1 , calculate_e_above_hulls = False , quiet = False ) Parameters: Name Type Description Default precursors Optional [ List [ str ]] Optional formulas of precursors. None targets Optional [ List [ str ]] Optional formulas of targets; only reactions which make these targets will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) required exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/minimize.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Args: precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . _build_pd = True MinimizeGrandPotentialEnumerator Bases: MinimizeGibbsEnumerator Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded. Source code in rxn_network/enumerators/minimize.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MinimizeGrandPotentialEnumerator ( MinimizeGibbsEnumerator ): \"\"\" Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded. \"\"\" CHUNK_SIZE = 10000 def __init__ ( self , open_elem : Element , mu : float , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , quiet : bool = False , ): \"\"\" Args: open_elem: The element to be considered as open mu: The chemical potential of the open element precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . open_elem = Element ( open_elem ) self . open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ] self . mu = mu self . chempots = { self . open_elem : self . mu } self . _build_grand_pd = True @staticmethod def _react_function ( reactants , products , filtered_entries = None , pd = None , grand_pd = None , ** kwargs ): \"\"\"Same as the MinimizeGibbsEnumerator react function, but with ability to specify open element and grand potential phase diagram\"\"\" r = list ( reactants ) r0 = r [ 0 ] if len ( r ) == 1 : r1 = r [ 0 ] else : r1 = r [ 1 ] open_elem = list ( grand_pd . chempots . keys ())[ 0 ] for reactant in r : elems = reactant . composition . elements if len ( elems ) == 1 and elems [ 0 ] == open_elem : # skip if reactant = open_e return [] return react_interface ( r0 . composition , r1 . composition , filtered_entries , pd , grand_pd = grand_pd , ) __init__ ( open_elem , mu , precursors = None , targets = None , exclusive_precursors = True , exclusive_targets = False , filter_by_chemsys = None , max_num_constraints = 1 , quiet = False ) Parameters: Name Type Description Default open_elem Element The element to be considered as open required mu float The chemical potential of the open element required precursors Optional [ List [ str ]] Optional formulas of precursors. None targets Optional [ List [ str ]] Optional formulas of targets; only reactions which make these targets will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) required exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/minimize.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , open_elem : Element , mu : float , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , quiet : bool = False , ): \"\"\" Args: open_elem: The element to be considered as open mu: The chemical potential of the open element precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . open_elem = Element ( open_elem ) self . open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ] self . mu = mu self . chempots = { self . open_elem : self . mu } self . _build_grand_pd = True react_interface ( r1 , r2 , filtered_entries , pd , grand_pd = None ) Simple API for InterfacialReactivity module from pymatgen. Source code in rxn_network/enumerators/minimize.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def react_interface ( r1 , r2 , filtered_entries , pd , grand_pd = None ): \"\"\"Simple API for InterfacialReactivity module from pymatgen.\"\"\" chempots = None if grand_pd : interface = GrandPotentialInterfacialReactivity ( r1 , r2 , grand_pd , pd_non_grand = pd , norm = True , include_no_mixing_energy = True , use_hull_energy = True , ) chempots = grand_pd . chempots else : interface = InterfacialReactivity ( r1 , r2 , pd , use_hull_energy = True , ) rxns = [] for _ , _ , _ , rxn , _ in interface . get_kinks (): rxn = get_computed_rxn ( rxn , filtered_entries , chempots ) rxns . append ( rxn ) return rxns","title":"Minimize"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGibbsEnumerator","text":"Bases: BasicEnumerator Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded. Source code in rxn_network/enumerators/minimize.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 class MinimizeGibbsEnumerator ( BasicEnumerator ): \"\"\" Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded. \"\"\" CHUNK_SIZE = 10000 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Args: precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . _build_pd = True @staticmethod def _react_function ( reactants , products , filtered_entries = None , pd = None , grand_pd = None , ** kwargs ): \"\"\"React method for MinimizeGibbsEnumerator, which uses the interfacial reaction approach (see _react_interface())\"\"\" r = list ( reactants ) r0 = r [ 0 ] if len ( r ) == 1 : r1 = r [ 0 ] else : r1 = r [ 1 ] return react_interface ( r0 . composition , r1 . composition , filtered_entries , pd , grand_pd , ) @staticmethod def _get_rxn_iterable ( combos , open_combos ): \"\"\"Gets the iterable used to generate reactions\"\"\" _ = open_combos # unused argument return product ( combos , [ None ]) @staticmethod def _rxn_iter_length ( combos , open_combos ): _ = open_combos return len ( combos )","title":"MinimizeGibbsEnumerator"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGibbsEnumerator.__init__","text":"Parameters: Name Type Description Default precursors Optional [ List [ str ]] Optional formulas of precursors. None targets Optional [ List [ str ]] Optional formulas of targets; only reactions which make these targets will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) required exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/minimize.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 def __init__ ( self , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints : int = 1 , calculate_e_above_hulls : bool = False , quiet : bool = False , ): \"\"\" Args: precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator\"]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . _build_pd = True","title":"__init__()"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGrandPotentialEnumerator","text":"Bases: MinimizeGibbsEnumerator Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded. Source code in rxn_network/enumerators/minimize.py 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class MinimizeGrandPotentialEnumerator ( MinimizeGibbsEnumerator ): \"\"\" Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded. \"\"\" CHUNK_SIZE = 10000 def __init__ ( self , open_elem : Element , mu : float , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , quiet : bool = False , ): \"\"\" Args: open_elem: The element to be considered as open mu: The chemical potential of the open element precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . open_elem = Element ( open_elem ) self . open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ] self . mu = mu self . chempots = { self . open_elem : self . mu } self . _build_grand_pd = True @staticmethod def _react_function ( reactants , products , filtered_entries = None , pd = None , grand_pd = None , ** kwargs ): \"\"\"Same as the MinimizeGibbsEnumerator react function, but with ability to specify open element and grand potential phase diagram\"\"\" r = list ( reactants ) r0 = r [ 0 ] if len ( r ) == 1 : r1 = r [ 0 ] else : r1 = r [ 1 ] open_elem = list ( grand_pd . chempots . keys ())[ 0 ] for reactant in r : elems = reactant . composition . elements if len ( elems ) == 1 and elems [ 0 ] == open_elem : # skip if reactant = open_e return [] return react_interface ( r0 . composition , r1 . composition , filtered_entries , pd , grand_pd = grand_pd , )","title":"MinimizeGrandPotentialEnumerator"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGrandPotentialEnumerator.__init__","text":"Parameters: Name Type Description Default open_elem Element The element to be considered as open required mu float The chemical potential of the open element required precursors Optional [ List [ str ]] Optional formulas of precursors. None targets Optional [ List [ str ]] Optional formulas of targets; only reactions which make these targets will be enumerated. None calculators Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) required exclusive_precursors bool Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. True exclusive_targets bool Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. False quiet bool Whether to run in quiet mode (no progress bar). Defaults to False. False Source code in rxn_network/enumerators/minimize.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 def __init__ ( self , open_elem : Element , mu : float , precursors : Optional [ List [ str ]] = None , targets : Optional [ List [ str ]] = None , exclusive_precursors : bool = True , exclusive_targets : bool = False , filter_by_chemsys : Optional [ str ] = None , max_num_constraints = 1 , quiet : bool = False , ): \"\"\" Args: open_elem: The element to be considered as open mu: The chemical potential of the open element precursors: Optional formulas of precursors. targets: Optional formulas of targets; only reactions which make these targets will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) exclusive_precursors: Whether to consider only reactions that have reactants which are a subset of the provided list of precursors. Defaults to True. exclusive_targets: Whether to consider only reactions that make the provided target directly (i.e. with no byproducts). Defualts to False. quiet: Whether to run in quiet mode (no progress bar). Defaults to False. \"\"\" super () . __init__ ( precursors = precursors , targets = targets , exclusive_precursors = exclusive_precursors , exclusive_targets = exclusive_targets , filter_by_chemsys = filter_by_chemsys , quiet = quiet , ) self . open_elem = Element ( open_elem ) self . open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ] self . mu = mu self . chempots = { self . open_elem : self . mu } self . _build_grand_pd = True","title":"__init__()"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.react_interface","text":"Simple API for InterfacialReactivity module from pymatgen. Source code in rxn_network/enumerators/minimize.py 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 def react_interface ( r1 , r2 , filtered_entries , pd , grand_pd = None ): \"\"\"Simple API for InterfacialReactivity module from pymatgen.\"\"\" chempots = None if grand_pd : interface = GrandPotentialInterfacialReactivity ( r1 , r2 , grand_pd , pd_non_grand = pd , norm = True , include_no_mixing_energy = True , use_hull_energy = True , ) chempots = grand_pd . chempots else : interface = InterfacialReactivity ( r1 , r2 , pd , use_hull_energy = True , ) rxns = [] for _ , _ , _ , rxn , _ in interface . get_kinks (): rxn = get_computed_rxn ( rxn , filtered_entries , chempots ) rxns . append ( rxn ) return rxns","title":"react_interface()"},{"location":"reference/enumerators/utils/","text":"Utility functions used by the enumerator classes. get_computed_rxn ( rxn , entries , chempots = None ) Provided with a Reaction object and a list of possible entries, this function returns a new ComputedReaction object containing a selection of those entries. Parameters: Name Type Description Default rxn Reaction Reaction object required entries GibbsEntrySet Iterable of entries required Returns: Type Description ComputedReaction A ComputedReaction object transformed from a normal Reaction object Source code in rxn_network/enumerators/utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_computed_rxn ( rxn : Reaction , entries : GibbsEntrySet , chempots = None ) -> ComputedReaction : \"\"\" Provided with a Reaction object and a list of possible entries, this function returns a new ComputedReaction object containing a selection of those entries. Args: rxn: Reaction object entries: Iterable of entries Returns: A ComputedReaction object transformed from a normal Reaction object \"\"\" reactant_entries = [ entries . get_min_entry_by_formula ( r . reduced_formula ) for r in rxn . reactants ] product_entries = [ entries . get_min_entry_by_formula ( p . reduced_formula ) for p in rxn . products ] if chempots : rxn = OpenComputedReaction . balance ( reactant_entries , product_entries , chempots ) else : rxn = ComputedReaction . balance ( reactant_entries , product_entries ) return rxn get_elems_set ( entries ) Returns chemical system as a set of element names, for set of entries. Parameters: Name Type Description Default entries Iterable [ Entry ] An iterable of entry-like objects required Returns: Type Description Set [ str ] Set of element names (strings). Source code in rxn_network/enumerators/utils.py 16 17 18 19 20 21 22 23 24 25 26 def get_elems_set ( entries : Iterable [ Entry ]) -> Set [ str ]: \"\"\" Returns chemical system as a set of element names, for set of entries. Args: entries: An iterable of entry-like objects Returns: Set of element names (strings). \"\"\" return { str ( elem ) for e in entries for elem in e . composition . elements } get_rxn_info ( rxn ) Utility function to get basic reaction information from a ComputedReaction object. Used in enumerators. Parameters: Name Type Description Default rxn ComputedReaction ComputedReaction object required Returns: Type Description Tuple of reaction information (entry indices, coefficients, data) Source code in rxn_network/enumerators/utils.py 132 133 134 135 136 137 138 139 140 141 142 143 def get_rxn_info ( rxn : ComputedReaction ): \"\"\" Utility function to get basic reaction information from a ComputedReaction object. Used in enumerators. Args: rxn: ComputedReaction object Returns: Tuple of reaction information (entry indices, coefficients, data) \"\"\" return [ e . data [ \"idx\" ] for e in rxn . entries ], list ( rxn . coefficients ), rxn . data get_total_chemsys_str ( entries , open_elems = None ) Returns chemical system string for set of entries, with optional open element. Parameters: Name Type Description Default entries Iterable [ Entry ] An iterable of entry-like objects required open_elem optional open element to include in chemical system required Source code in rxn_network/enumerators/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_total_chemsys_str ( entries : Iterable [ Entry ], open_elems : Optional [ Iterable [ Union [ Element ]]] = None ) -> str : \"\"\" Returns chemical system string for set of entries, with optional open element. Args: entries: An iterable of entry-like objects open_elem: optional open element to include in chemical system \"\"\" elements = { elem for entry in entries for elem in entry . composition . elements } if open_elems : elements . update ( list ( open_elems )) return \"-\" . join ( sorted ([ str ( e ) for e in elements ])) group_by_chemsys ( combos , open_elems = None ) Groups entry combinations by chemical system, with optional open element. Parameters: Name Type Description Default combos Iterable [ Tuple [ Entry ]] Iterable of entry combinations required open_elem optional open element to include in chemical system grouping required Returns: Type Description dict Dictionary of entry combos grouped by chemical system Source code in rxn_network/enumerators/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def group_by_chemsys ( combos : Iterable [ Tuple [ Entry ]], open_elems : Optional [ Iterable [ Element ]] = None ) -> dict : \"\"\" Groups entry combinations by chemical system, with optional open element. Args: combos: Iterable of entry combinations open_elem: optional open element to include in chemical system grouping Returns: Dictionary of entry combos grouped by chemical system \"\"\" combo_dict : Dict [ str , List [ Tuple [ Entry ]]] = {} for combo in combos : key = get_total_chemsys_str ( combo , open_elems ) if key in combo_dict : combo_dict [ key ] . append ( combo ) else : combo_dict [ key ] = [ combo ] return combo_dict stabilize_entries ( pd , entries_to_adjust , tol = 1e-06 ) Simple method for stabilizing entries by decreasing their energy to be on the hull. WARNING: This method is not guaranteed to work simultaneously for all entries due to the fact that stabilization of one entry may destabilize others. Use with caution. Parameters: Name Type Description Default pd PhaseDiagram PhaseDiagram object required entries_to_adjust Iterable [ Entry ] Iterable of entries requiring energies to be adjusted required tol float Numerical tolerance to ensure that the energy of the entry is below the hull 1e-06 Returns: Type Description List [ Entry ] A list of new entries with energies adjusted to be on the hull Source code in rxn_network/enumerators/utils.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def stabilize_entries ( pd : PhaseDiagram , entries_to_adjust : Iterable [ Entry ], tol : float = 1e-6 ) -> List [ Entry ]: \"\"\" Simple method for stabilizing entries by decreasing their energy to be on the hull. WARNING: This method is not guaranteed to work *simultaneously* for all entries due to the fact that stabilization of one entry may destabilize others. Use with caution. Args: pd: PhaseDiagram object entries_to_adjust: Iterable of entries requiring energies to be adjusted tol: Numerical tolerance to ensure that the energy of the entry is below the hull Returns: A list of new entries with energies adjusted to be on the hull \"\"\" indices = [ pd . all_entries . index ( entry ) for entry in entries_to_adjust ] new_entries = [] for _ , entry in zip ( indices , entries_to_adjust ): e_above_hull = pd . get_e_above_hull ( entry ) entry_dict = entry . to_dict () entry_dict [ \"energy\" ] = entry . uncorrected_energy + ( e_above_hull * entry . composition . num_atoms - tol ) new_entry = ComputedEntry . from_dict ( entry_dict ) new_entries . append ( new_entry ) return new_entries","title":"Utils"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_computed_rxn","text":"Provided with a Reaction object and a list of possible entries, this function returns a new ComputedReaction object containing a selection of those entries. Parameters: Name Type Description Default rxn Reaction Reaction object required entries GibbsEntrySet Iterable of entries required Returns: Type Description ComputedReaction A ComputedReaction object transformed from a normal Reaction object Source code in rxn_network/enumerators/utils.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 def get_computed_rxn ( rxn : Reaction , entries : GibbsEntrySet , chempots = None ) -> ComputedReaction : \"\"\" Provided with a Reaction object and a list of possible entries, this function returns a new ComputedReaction object containing a selection of those entries. Args: rxn: Reaction object entries: Iterable of entries Returns: A ComputedReaction object transformed from a normal Reaction object \"\"\" reactant_entries = [ entries . get_min_entry_by_formula ( r . reduced_formula ) for r in rxn . reactants ] product_entries = [ entries . get_min_entry_by_formula ( p . reduced_formula ) for p in rxn . products ] if chempots : rxn = OpenComputedReaction . balance ( reactant_entries , product_entries , chempots ) else : rxn = ComputedReaction . balance ( reactant_entries , product_entries ) return rxn","title":"get_computed_rxn()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_elems_set","text":"Returns chemical system as a set of element names, for set of entries. Parameters: Name Type Description Default entries Iterable [ Entry ] An iterable of entry-like objects required Returns: Type Description Set [ str ] Set of element names (strings). Source code in rxn_network/enumerators/utils.py 16 17 18 19 20 21 22 23 24 25 26 def get_elems_set ( entries : Iterable [ Entry ]) -> Set [ str ]: \"\"\" Returns chemical system as a set of element names, for set of entries. Args: entries: An iterable of entry-like objects Returns: Set of element names (strings). \"\"\" return { str ( elem ) for e in entries for elem in e . composition . elements }","title":"get_elems_set()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_rxn_info","text":"Utility function to get basic reaction information from a ComputedReaction object. Used in enumerators. Parameters: Name Type Description Default rxn ComputedReaction ComputedReaction object required Returns: Type Description Tuple of reaction information (entry indices, coefficients, data) Source code in rxn_network/enumerators/utils.py 132 133 134 135 136 137 138 139 140 141 142 143 def get_rxn_info ( rxn : ComputedReaction ): \"\"\" Utility function to get basic reaction information from a ComputedReaction object. Used in enumerators. Args: rxn: ComputedReaction object Returns: Tuple of reaction information (entry indices, coefficients, data) \"\"\" return [ e . data [ \"idx\" ] for e in rxn . entries ], list ( rxn . coefficients ), rxn . data","title":"get_rxn_info()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_total_chemsys_str","text":"Returns chemical system string for set of entries, with optional open element. Parameters: Name Type Description Default entries Iterable [ Entry ] An iterable of entry-like objects required open_elem optional open element to include in chemical system required Source code in rxn_network/enumerators/utils.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def get_total_chemsys_str ( entries : Iterable [ Entry ], open_elems : Optional [ Iterable [ Union [ Element ]]] = None ) -> str : \"\"\" Returns chemical system string for set of entries, with optional open element. Args: entries: An iterable of entry-like objects open_elem: optional open element to include in chemical system \"\"\" elements = { elem for entry in entries for elem in entry . composition . elements } if open_elems : elements . update ( list ( open_elems )) return \"-\" . join ( sorted ([ str ( e ) for e in elements ]))","title":"get_total_chemsys_str()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.group_by_chemsys","text":"Groups entry combinations by chemical system, with optional open element. Parameters: Name Type Description Default combos Iterable [ Tuple [ Entry ]] Iterable of entry combinations required open_elem optional open element to include in chemical system grouping required Returns: Type Description dict Dictionary of entry combos grouped by chemical system Source code in rxn_network/enumerators/utils.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def group_by_chemsys ( combos : Iterable [ Tuple [ Entry ]], open_elems : Optional [ Iterable [ Element ]] = None ) -> dict : \"\"\" Groups entry combinations by chemical system, with optional open element. Args: combos: Iterable of entry combinations open_elem: optional open element to include in chemical system grouping Returns: Dictionary of entry combos grouped by chemical system \"\"\" combo_dict : Dict [ str , List [ Tuple [ Entry ]]] = {} for combo in combos : key = get_total_chemsys_str ( combo , open_elems ) if key in combo_dict : combo_dict [ key ] . append ( combo ) else : combo_dict [ key ] = [ combo ] return combo_dict","title":"group_by_chemsys()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.stabilize_entries","text":"Simple method for stabilizing entries by decreasing their energy to be on the hull. WARNING: This method is not guaranteed to work simultaneously for all entries due to the fact that stabilization of one entry may destabilize others. Use with caution. Parameters: Name Type Description Default pd PhaseDiagram PhaseDiagram object required entries_to_adjust Iterable [ Entry ] Iterable of entries requiring energies to be adjusted required tol float Numerical tolerance to ensure that the energy of the entry is below the hull 1e-06 Returns: Type Description List [ Entry ] A list of new entries with energies adjusted to be on the hull Source code in rxn_network/enumerators/utils.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 def stabilize_entries ( pd : PhaseDiagram , entries_to_adjust : Iterable [ Entry ], tol : float = 1e-6 ) -> List [ Entry ]: \"\"\" Simple method for stabilizing entries by decreasing their energy to be on the hull. WARNING: This method is not guaranteed to work *simultaneously* for all entries due to the fact that stabilization of one entry may destabilize others. Use with caution. Args: pd: PhaseDiagram object entries_to_adjust: Iterable of entries requiring energies to be adjusted tol: Numerical tolerance to ensure that the energy of the entry is below the hull Returns: A list of new entries with energies adjusted to be on the hull \"\"\" indices = [ pd . all_entries . index ( entry ) for entry in entries_to_adjust ] new_entries = [] for _ , entry in zip ( indices , entries_to_adjust ): e_above_hull = pd . get_e_above_hull ( entry ) entry_dict = entry . to_dict () entry_dict [ \"energy\" ] = entry . uncorrected_energy + ( e_above_hull * entry . composition . num_atoms - tol ) new_entry = ComputedEntry . from_dict ( entry_dict ) new_entries . append ( new_entry ) return new_entries","title":"stabilize_entries()"},{"location":"reference/flows/core/","text":"","title":"Core"},{"location":"reference/jobs/core/","text":"Core jobs for reaction-network creation and analysis. GetEntrySetMaker dataclass Bases: Maker Maker to create job for acquiring and processing entries to be used in reaction enumeration or network building. Args (A list of argumnets provided to the dataclass) name: Name of the job. entry_db_name: Name of the entry database store to use. If none is available, will automatically use MPRester to acquire entries. temperature: Temperature to use for computing thermodynamic properties. include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. include_freed_data: Whether to include FREED data in the entry set. e_above_hull: Energy above hull to use for filtering entries. include_polymorphs: Whether to include polymorphs in the entry set. formulas_to_include: List of formulas to include in the entry set. calculate_e_above_hulls: Whether to calculate e_above_hulls for all entries in the entry set. MP_API_KEY: API key for Materials Project. Note: if not provided, MPRester will automatically look for an environment variable. Source code in rxn_network/jobs/core.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @dataclass class GetEntrySetMaker ( Maker ): \"\"\" Maker to create job for acquiring and processing entries to be used in reaction enumeration or network building. Args (A list of argumnets provided to the dataclass) name: Name of the job. entry_db_name: Name of the entry database store to use. If none is available, will automatically use MPRester to acquire entries. temperature: Temperature to use for computing thermodynamic properties. include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. include_freed_data: Whether to include FREED data in the entry set. e_above_hull: Energy above hull to use for filtering entries. include_polymorphs: Whether to include polymorphs in the entry set. formulas_to_include: List of formulas to include in the entry set. calculate_e_above_hulls: Whether to calculate e_above_hulls for all entries in the entry set. MP_API_KEY: API key for Materials Project. Note: if not provided, MPRester will automatically look for an environment variable. \"\"\" name : str = \"get_and_process_entries\" entry_db_name : str = \"entries_db\" temperature : int = 300 include_nist_data : bool = True include_barin_data : bool = False include_freed_data : bool = False e_above_hull : float = 0.0 include_polymorphs : bool = False formulas_to_include : list = field ( default_factory = list ) calculate_e_above_hulls : bool = True MP_API_KEY : Optional [ str ] = None property_data : Optional [ List [ str ]] = None @job ( entries = \"entries\" , output_schema = EntrySetDocument ) def make ( self , chemsys ): entry_db = SETTINGS . JOB_STORE . additional_stores . get ( self . entry_db_name ) property_data = self . property_data if property_data is None : property_data = [ \"theoretical\" ] elif \"theoretical\" not in property_data : property_data . append ( \"theoretical\" ) if entry_db : entries = get_all_entries_in_chemsys ( entry_db , chemsys , inc_structure = True , compatible_only = True , property_data = property_data , use_premade_entries = False , ) else : from mp_api.client import MPRester if self . MP_API_KEY : with MPRester ( self . MP_API_KEY ) as mpr : entries = mpr . get_entries_in_chemsys ( elements = chemsys ) else : with MPRester () as mpr : # let MPRester look for env variable entries = mpr . get_entries_in_chemsys ( elements = chemsys ) entries = process_entries ( entries , temperature = self . temperature , include_nist_data = self . include_nist_data , include_barin_data = self . include_barin_data , include_freed_data = self . include_freed_data , e_above_hull = self . e_above_hull , include_polymorphs = self . include_polymorphs , formulas_to_include = self . formulas_to_include , calculate_e_above_hulls = self . calculate_e_above_hulls , ) doc = EntrySetDocument ( entries = entries , e_above_hull = self . e_above_hull , include_polymorphs = self . include_polymorphs , formulas_to_include = self . formulas_to_include , ) doc . task_label = self . name return doc NetworkMaker dataclass Bases: Maker Maker for generating reaction networks and performing pathfinding from a set of previously enumerated reactions. Source code in rxn_network/jobs/core.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 @dataclass class NetworkMaker ( Maker ): \"\"\" Maker for generating reaction networks and performing pathfinding from a set of previously enumerated reactions. \"\"\" name : str = \"build_and_analyze_network\" cost_function : CostFunction = field ( default_factory = Softplus ) precursors : Optional [ List [ str ]] = None targets : Optional [ List [ str ]] = None calculate_pathways : Optional [ int ] = 10 open_elem : Optional [ Element ] = None chempot : float = 0.0 @job ( network = \"network\" , output_schema = NetworkTaskDocument ) def make ( self , rxn_sets : Iterable [ ReactionSet ], ): all_rxns = ReactionSet . from_rxns ( [ rxn for rxn_set in rxn_sets for rxn in rxn_set . get_rxns ()], open_elem = self . open_elem , chempot = self . chempot , ) all_rxns = all_rxns . filter_duplicates () rn = ReactionNetwork ( all_rxns , cost_function = self . cost_function ) rn . build () paths = None if self . precursors : rn . set_precursors ( self . precursors ) if self . targets : rn . set_target ( self . targets [ 0 ]) if self . calculate_pathways and self . targets : paths = rn . find_pathways ( self . targets , k = self . calculate_pathways ) data = { \"network\" : rn , \"paths\" : paths , \"k\" : self . calculate_pathways , \"precursors\" : self . precursors , \"targets\" : self . targets , } doc = NetworkTaskDocument ( ** data ) doc . task_label = self . name return doc PathwaySolverMaker dataclass Bases: Maker Maker for solving balanced reaction pathways from a set of (unbalanced) pathways returned as part of reaction network analysis. Source code in rxn_network/jobs/core.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 @dataclass class PathwaySolverMaker ( Maker ): \"\"\" Maker for solving balanced reaction pathways from a set of (unbalanced) pathways returned as part of reaction network analysis. \"\"\" name : str = \"solve pathways\" cost_function : CostFunction = field ( default_factory = Softplus ) precursors : List [ str ] = field ( default_factory = list ) targets : List [ str ] = field ( default_factory = list ) open_elem : Optional [ Element ] = None chempot : Optional [ float ] = None max_num_combos : int = 4 find_intermediate_rxns : bool = True intermediate_rxn_energy_cutoff : float = 0.0 use_basic_enumerator : bool = True use_minimize_enumerator : bool = False filter_interdependent : bool = True def __post_init__ ( self ): net_rxn = BasicReaction . balance ( [ Composition ( r ) for r in self . precursors ], [ Composition ( p ) for p in self . targets ], ) if not net_rxn . balanced : raise ValueError ( \"Can not balance pathways with specified precursors/targets. Please\" \" make sure a balanced net reaction can be written from the provided\" \" reactant and product formulas!\" ) self . net_rxn = net_rxn @job ( paths = \"paths\" , output_schema = PathwaySolverTaskDocument ) def make ( self , pathways , entries ): chempots = None if self . open_elem : chempots = { Element ( self . open_elem ): self . chempot } ps = PathwaySolver ( pathways = pathways , entries = entries , cost_function = self . cost_function , open_elem = self . open_elem , chempot = self . chempot , ) net_rxn = get_computed_rxn ( self . net_rxn , entries , chempots ) balanced_paths = ps . solve ( net_rxn = net_rxn , max_num_combos = self . max_num_combos , find_intermediate_rxns = self . find_intermediate_rxns , intermediate_rxn_energy_cutoff = self . intermediate_rxn_energy_cutoff , use_basic_enumerator = self . use_basic_enumerator , use_minimize_enumerator = self . use_minimize_enumerator , filter_interdependent = self . filter_interdependent , ) data = { \"solver\" : ps , \"balanced_paths\" : balanced_paths , \"precursors\" : self . precursors , \"targets\" : self . targets , \"net_rxn\" : net_rxn , \"max_num_combos\" : self . max_num_combos , \"find_intermediate_rxns\" : self . find_intermediate_rxns , \"intermediate_rxn_energy_cutoff\" : self . intermediate_rxn_energy_cutoff , \"use_basic_enumerator\" : self . use_basic_enumerator , \"use_minimize_enumerator\" : self . use_minimize_enumerator , \"filter_interdependent\" : self . filter_interdependent , } doc = PathwaySolverTaskDocument ( ** data ) doc . task_label = self . name return doc ReactionEnumerationMaker dataclass Bases: Maker Maker to create job for enumerating reactions from a set of entries. Source code in rxn_network/jobs/core.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @dataclass class ReactionEnumerationMaker ( Maker ): \"\"\" Maker to create job for enumerating reactions from a set of entries. \"\"\" name : str = \"enumerate_reactions\" @job ( rxns = \"rxns\" , output_schema = EnumeratorTaskDocument ) def make ( self , enumerators , entries ): data = {} logger . info ( \"Running enumerators...\" ) data [ \"rxns\" ] = run_enumerators ( enumerators , entries ) data . update ( self . _get_metadata ( enumerators , entries )) logger . info ( \"Building task document...\" ) enumerator_task = EnumeratorTaskDocument ( ** data ) enumerator_task . task_label = self . name return enumerator_task def _get_metadata ( self , enumerators , entries ): chemsys = \"-\" . join ( entries . chemsys ) targets = { target for enumerator in enumerators for target in enumerator . targets } added_elements = None added_chemsys = None if targets : added_elements , added_chemsys = get_added_elem_data ( entries , targets ) metadata = { \"elements\" : [ Element ( e ) for e in chemsys . split ( \"-\" )], \"chemsys\" : chemsys , \"enumerators\" : [ e . as_dict () for e in enumerators ], \"targets\" : list ( sorted ( targets )), \"added_elements\" : added_elements , \"added_chemsys\" : added_chemsys , } return metadata","title":"Core"},{"location":"reference/jobs/core/#rxn_network.jobs.core.GetEntrySetMaker","text":"Bases: Maker Maker to create job for acquiring and processing entries to be used in reaction enumeration or network building. Args (A list of argumnets provided to the dataclass) name: Name of the job. entry_db_name: Name of the entry database store to use. If none is available, will automatically use MPRester to acquire entries. temperature: Temperature to use for computing thermodynamic properties. include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. include_freed_data: Whether to include FREED data in the entry set. e_above_hull: Energy above hull to use for filtering entries. include_polymorphs: Whether to include polymorphs in the entry set. formulas_to_include: List of formulas to include in the entry set. calculate_e_above_hulls: Whether to calculate e_above_hulls for all entries in the entry set. MP_API_KEY: API key for Materials Project. Note: if not provided, MPRester will automatically look for an environment variable. Source code in rxn_network/jobs/core.py 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 @dataclass class GetEntrySetMaker ( Maker ): \"\"\" Maker to create job for acquiring and processing entries to be used in reaction enumeration or network building. Args (A list of argumnets provided to the dataclass) name: Name of the job. entry_db_name: Name of the entry database store to use. If none is available, will automatically use MPRester to acquire entries. temperature: Temperature to use for computing thermodynamic properties. include_nist_data: Whether to include NIST data in the entry set. include_barin_data: Whether to include Barin data in the entry set. include_freed_data: Whether to include FREED data in the entry set. e_above_hull: Energy above hull to use for filtering entries. include_polymorphs: Whether to include polymorphs in the entry set. formulas_to_include: List of formulas to include in the entry set. calculate_e_above_hulls: Whether to calculate e_above_hulls for all entries in the entry set. MP_API_KEY: API key for Materials Project. Note: if not provided, MPRester will automatically look for an environment variable. \"\"\" name : str = \"get_and_process_entries\" entry_db_name : str = \"entries_db\" temperature : int = 300 include_nist_data : bool = True include_barin_data : bool = False include_freed_data : bool = False e_above_hull : float = 0.0 include_polymorphs : bool = False formulas_to_include : list = field ( default_factory = list ) calculate_e_above_hulls : bool = True MP_API_KEY : Optional [ str ] = None property_data : Optional [ List [ str ]] = None @job ( entries = \"entries\" , output_schema = EntrySetDocument ) def make ( self , chemsys ): entry_db = SETTINGS . JOB_STORE . additional_stores . get ( self . entry_db_name ) property_data = self . property_data if property_data is None : property_data = [ \"theoretical\" ] elif \"theoretical\" not in property_data : property_data . append ( \"theoretical\" ) if entry_db : entries = get_all_entries_in_chemsys ( entry_db , chemsys , inc_structure = True , compatible_only = True , property_data = property_data , use_premade_entries = False , ) else : from mp_api.client import MPRester if self . MP_API_KEY : with MPRester ( self . MP_API_KEY ) as mpr : entries = mpr . get_entries_in_chemsys ( elements = chemsys ) else : with MPRester () as mpr : # let MPRester look for env variable entries = mpr . get_entries_in_chemsys ( elements = chemsys ) entries = process_entries ( entries , temperature = self . temperature , include_nist_data = self . include_nist_data , include_barin_data = self . include_barin_data , include_freed_data = self . include_freed_data , e_above_hull = self . e_above_hull , include_polymorphs = self . include_polymorphs , formulas_to_include = self . formulas_to_include , calculate_e_above_hulls = self . calculate_e_above_hulls , ) doc = EntrySetDocument ( entries = entries , e_above_hull = self . e_above_hull , include_polymorphs = self . include_polymorphs , formulas_to_include = self . formulas_to_include , ) doc . task_label = self . name return doc","title":"GetEntrySetMaker"},{"location":"reference/jobs/core/#rxn_network.jobs.core.NetworkMaker","text":"Bases: Maker Maker for generating reaction networks and performing pathfinding from a set of previously enumerated reactions. Source code in rxn_network/jobs/core.py 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 @dataclass class NetworkMaker ( Maker ): \"\"\" Maker for generating reaction networks and performing pathfinding from a set of previously enumerated reactions. \"\"\" name : str = \"build_and_analyze_network\" cost_function : CostFunction = field ( default_factory = Softplus ) precursors : Optional [ List [ str ]] = None targets : Optional [ List [ str ]] = None calculate_pathways : Optional [ int ] = 10 open_elem : Optional [ Element ] = None chempot : float = 0.0 @job ( network = \"network\" , output_schema = NetworkTaskDocument ) def make ( self , rxn_sets : Iterable [ ReactionSet ], ): all_rxns = ReactionSet . from_rxns ( [ rxn for rxn_set in rxn_sets for rxn in rxn_set . get_rxns ()], open_elem = self . open_elem , chempot = self . chempot , ) all_rxns = all_rxns . filter_duplicates () rn = ReactionNetwork ( all_rxns , cost_function = self . cost_function ) rn . build () paths = None if self . precursors : rn . set_precursors ( self . precursors ) if self . targets : rn . set_target ( self . targets [ 0 ]) if self . calculate_pathways and self . targets : paths = rn . find_pathways ( self . targets , k = self . calculate_pathways ) data = { \"network\" : rn , \"paths\" : paths , \"k\" : self . calculate_pathways , \"precursors\" : self . precursors , \"targets\" : self . targets , } doc = NetworkTaskDocument ( ** data ) doc . task_label = self . name return doc","title":"NetworkMaker"},{"location":"reference/jobs/core/#rxn_network.jobs.core.PathwaySolverMaker","text":"Bases: Maker Maker for solving balanced reaction pathways from a set of (unbalanced) pathways returned as part of reaction network analysis. Source code in rxn_network/jobs/core.py 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 @dataclass class PathwaySolverMaker ( Maker ): \"\"\" Maker for solving balanced reaction pathways from a set of (unbalanced) pathways returned as part of reaction network analysis. \"\"\" name : str = \"solve pathways\" cost_function : CostFunction = field ( default_factory = Softplus ) precursors : List [ str ] = field ( default_factory = list ) targets : List [ str ] = field ( default_factory = list ) open_elem : Optional [ Element ] = None chempot : Optional [ float ] = None max_num_combos : int = 4 find_intermediate_rxns : bool = True intermediate_rxn_energy_cutoff : float = 0.0 use_basic_enumerator : bool = True use_minimize_enumerator : bool = False filter_interdependent : bool = True def __post_init__ ( self ): net_rxn = BasicReaction . balance ( [ Composition ( r ) for r in self . precursors ], [ Composition ( p ) for p in self . targets ], ) if not net_rxn . balanced : raise ValueError ( \"Can not balance pathways with specified precursors/targets. Please\" \" make sure a balanced net reaction can be written from the provided\" \" reactant and product formulas!\" ) self . net_rxn = net_rxn @job ( paths = \"paths\" , output_schema = PathwaySolverTaskDocument ) def make ( self , pathways , entries ): chempots = None if self . open_elem : chempots = { Element ( self . open_elem ): self . chempot } ps = PathwaySolver ( pathways = pathways , entries = entries , cost_function = self . cost_function , open_elem = self . open_elem , chempot = self . chempot , ) net_rxn = get_computed_rxn ( self . net_rxn , entries , chempots ) balanced_paths = ps . solve ( net_rxn = net_rxn , max_num_combos = self . max_num_combos , find_intermediate_rxns = self . find_intermediate_rxns , intermediate_rxn_energy_cutoff = self . intermediate_rxn_energy_cutoff , use_basic_enumerator = self . use_basic_enumerator , use_minimize_enumerator = self . use_minimize_enumerator , filter_interdependent = self . filter_interdependent , ) data = { \"solver\" : ps , \"balanced_paths\" : balanced_paths , \"precursors\" : self . precursors , \"targets\" : self . targets , \"net_rxn\" : net_rxn , \"max_num_combos\" : self . max_num_combos , \"find_intermediate_rxns\" : self . find_intermediate_rxns , \"intermediate_rxn_energy_cutoff\" : self . intermediate_rxn_energy_cutoff , \"use_basic_enumerator\" : self . use_basic_enumerator , \"use_minimize_enumerator\" : self . use_minimize_enumerator , \"filter_interdependent\" : self . filter_interdependent , } doc = PathwaySolverTaskDocument ( ** data ) doc . task_label = self . name return doc","title":"PathwaySolverMaker"},{"location":"reference/jobs/core/#rxn_network.jobs.core.ReactionEnumerationMaker","text":"Bases: Maker Maker to create job for enumerating reactions from a set of entries. Source code in rxn_network/jobs/core.py 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 @dataclass class ReactionEnumerationMaker ( Maker ): \"\"\" Maker to create job for enumerating reactions from a set of entries. \"\"\" name : str = \"enumerate_reactions\" @job ( rxns = \"rxns\" , output_schema = EnumeratorTaskDocument ) def make ( self , enumerators , entries ): data = {} logger . info ( \"Running enumerators...\" ) data [ \"rxns\" ] = run_enumerators ( enumerators , entries ) data . update ( self . _get_metadata ( enumerators , entries )) logger . info ( \"Building task document...\" ) enumerator_task = EnumeratorTaskDocument ( ** data ) enumerator_task . task_label = self . name return enumerator_task def _get_metadata ( self , enumerators , entries ): chemsys = \"-\" . join ( entries . chemsys ) targets = { target for enumerator in enumerators for target in enumerator . targets } added_elements = None added_chemsys = None if targets : added_elements , added_chemsys = get_added_elem_data ( entries , targets ) metadata = { \"elements\" : [ Element ( e ) for e in chemsys . split ( \"-\" )], \"chemsys\" : chemsys , \"enumerators\" : [ e . as_dict () for e in enumerators ], \"targets\" : list ( sorted ( targets )), \"added_elements\" : added_elements , \"added_chemsys\" : added_chemsys , } return metadata","title":"ReactionEnumerationMaker"},{"location":"reference/network/entry/","text":"Entry objects used in a Network. These network entry objects hold multiple entries and can be used as data for a node in the graph. DummyEntry Bases: NetworkEntry A Dummy Entry that doesn't hold any info. This maybe useful for serving as an empty node to facilitate pathfinding to all nodes, etc. Source code in rxn_network/network/entry.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class DummyEntry ( NetworkEntry ): \"\"\" A Dummy Entry that doesn't hold any info. This maybe useful for serving as an empty node to facilitate pathfinding to all nodes, etc. \"\"\" def __init__ ( self ): # pylint: disable=super-init-not-called \"\"\"Dummy node doesn't need any parameters\"\"\" @property def entries ( self ): \"\"\"No entries in DummyEntry\"\"\" return [] @property def chemsys ( self ): \"\"\"No Chemsys to DummyEntry\"\"\" return \"\" @property def description ( self ): \"\"\"DummyEntry is always of type Dummy\"\"\" return NetworkEntryType . Dummy def __repr__ ( self ): return \"Dummy Node\" def __eq__ ( self , other ): return self is other def __hash__ ( self ): return hash ( \"Dummy\" ) __init__ () Dummy node doesn't need any parameters Source code in rxn_network/network/entry.py 83 84 def __init__ ( self ): # pylint: disable=super-init-not-called \"\"\"Dummy node doesn't need any parameters\"\"\" chemsys () property No Chemsys to DummyEntry Source code in rxn_network/network/entry.py 91 92 93 94 @property def chemsys ( self ): \"\"\"No Chemsys to DummyEntry\"\"\" return \"\" description () property DummyEntry is always of type Dummy Source code in rxn_network/network/entry.py 96 97 98 99 @property def description ( self ): \"\"\"DummyEntry is always of type Dummy\"\"\" return NetworkEntryType . Dummy entries () property No entries in DummyEntry Source code in rxn_network/network/entry.py 86 87 88 89 @property def entries ( self ): \"\"\"No entries in DummyEntry\"\"\" return [] NetworkEntry Bases: MSONable Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network. Source code in rxn_network/network/entry.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class NetworkEntry ( MSONable ): \"\"\" Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network. \"\"\" def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of Entry-like objects description: Node type (e.g., Precursors, Target... see NetworkEntryType class) \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description def as_dict ( self ): \"\"\"MSONable dict representation\"\"\" return { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ , \"entries\" : list ( self . entries ), \"description\" : self . description . value , } @classmethod def from_dict ( cls , d ): \"\"\"Load from MSONable dict\"\"\" return cls ( MontyDecoder () . process_decoded ( d [ \"entries\" ]), NetworkEntryType ( d [ \"description\" ]), ) def __repr__ ( self ): formulas = [ entry . composition . reduced_formula for entry in self . entries ] formulas . sort () return f \" { self . description . name } : { ',' . join ( formulas ) } \" def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): if self . description == other . description : if self . chemsys == other . chemsys : return self . entries == other . entries return False def __hash__ ( self ): return hash (( self . description , frozenset ( self . entries ))) __init__ ( entries , description ) Parameters: Name Type Description Default entries List [ Entry ] list of Entry-like objects required description NetworkEntryType Node type (e.g., Precursors, Target... see NetworkEntryType class) required Source code in rxn_network/network/entry.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of Entry-like objects description: Node type (e.g., Precursors, Target... see NetworkEntryType class) \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description as_dict () MSONable dict representation Source code in rxn_network/network/entry.py 44 45 46 47 48 49 50 51 def as_dict ( self ): \"\"\"MSONable dict representation\"\"\" return { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ , \"entries\" : list ( self . entries ), \"description\" : self . description . value , } from_dict ( d ) classmethod Load from MSONable dict Source code in rxn_network/network/entry.py 53 54 55 56 57 58 59 @classmethod def from_dict ( cls , d ): \"\"\"Load from MSONable dict\"\"\" return cls ( MontyDecoder () . process_decoded ( d [ \"entries\" ]), NetworkEntryType ( d [ \"description\" ]), ) NetworkEntryType Bases: Enum Describes the Network Entry Type Source code in rxn_network/network/entry.py 13 14 15 16 17 18 19 20 class NetworkEntryType ( Enum ): \"\"\"Describes the Network Entry Type\"\"\" Precursors = auto () Reactants = auto () Products = auto () Target = auto () Dummy = auto ()","title":"Entry"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry","text":"Bases: NetworkEntry A Dummy Entry that doesn't hold any info. This maybe useful for serving as an empty node to facilitate pathfinding to all nodes, etc. Source code in rxn_network/network/entry.py 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 class DummyEntry ( NetworkEntry ): \"\"\" A Dummy Entry that doesn't hold any info. This maybe useful for serving as an empty node to facilitate pathfinding to all nodes, etc. \"\"\" def __init__ ( self ): # pylint: disable=super-init-not-called \"\"\"Dummy node doesn't need any parameters\"\"\" @property def entries ( self ): \"\"\"No entries in DummyEntry\"\"\" return [] @property def chemsys ( self ): \"\"\"No Chemsys to DummyEntry\"\"\" return \"\" @property def description ( self ): \"\"\"DummyEntry is always of type Dummy\"\"\" return NetworkEntryType . Dummy def __repr__ ( self ): return \"Dummy Node\" def __eq__ ( self , other ): return self is other def __hash__ ( self ): return hash ( \"Dummy\" )","title":"DummyEntry"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.__init__","text":"Dummy node doesn't need any parameters Source code in rxn_network/network/entry.py 83 84 def __init__ ( self ): # pylint: disable=super-init-not-called \"\"\"Dummy node doesn't need any parameters\"\"\"","title":"__init__()"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.chemsys","text":"No Chemsys to DummyEntry Source code in rxn_network/network/entry.py 91 92 93 94 @property def chemsys ( self ): \"\"\"No Chemsys to DummyEntry\"\"\" return \"\"","title":"chemsys()"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.description","text":"DummyEntry is always of type Dummy Source code in rxn_network/network/entry.py 96 97 98 99 @property def description ( self ): \"\"\"DummyEntry is always of type Dummy\"\"\" return NetworkEntryType . Dummy","title":"description()"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.entries","text":"No entries in DummyEntry Source code in rxn_network/network/entry.py 86 87 88 89 @property def entries ( self ): \"\"\"No entries in DummyEntry\"\"\" return []","title":"entries()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry","text":"Bases: MSONable Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network. Source code in rxn_network/network/entry.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 class NetworkEntry ( MSONable ): \"\"\" Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network. \"\"\" def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of Entry-like objects description: Node type (e.g., Precursors, Target... see NetworkEntryType class) \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description def as_dict ( self ): \"\"\"MSONable dict representation\"\"\" return { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ , \"entries\" : list ( self . entries ), \"description\" : self . description . value , } @classmethod def from_dict ( cls , d ): \"\"\"Load from MSONable dict\"\"\" return cls ( MontyDecoder () . process_decoded ( d [ \"entries\" ]), NetworkEntryType ( d [ \"description\" ]), ) def __repr__ ( self ): formulas = [ entry . composition . reduced_formula for entry in self . entries ] formulas . sort () return f \" { self . description . name } : { ',' . join ( formulas ) } \" def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): if self . description == other . description : if self . chemsys == other . chemsys : return self . entries == other . entries return False def __hash__ ( self ): return hash (( self . description , frozenset ( self . entries )))","title":"NetworkEntry"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry.__init__","text":"Parameters: Name Type Description Default entries List [ Entry ] list of Entry-like objects required description NetworkEntryType Node type (e.g., Precursors, Target... see NetworkEntryType class) required Source code in rxn_network/network/entry.py 29 30 31 32 33 34 35 36 37 38 39 40 41 42 def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of Entry-like objects description: Node type (e.g., Precursors, Target... see NetworkEntryType class) \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description","title":"__init__()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry.as_dict","text":"MSONable dict representation Source code in rxn_network/network/entry.py 44 45 46 47 48 49 50 51 def as_dict ( self ): \"\"\"MSONable dict representation\"\"\" return { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ , \"entries\" : list ( self . entries ), \"description\" : self . description . value , }","title":"as_dict()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry.from_dict","text":"Load from MSONable dict Source code in rxn_network/network/entry.py 53 54 55 56 57 58 59 @classmethod def from_dict ( cls , d ): \"\"\"Load from MSONable dict\"\"\" return cls ( MontyDecoder () . process_decoded ( d [ \"entries\" ]), NetworkEntryType ( d [ \"description\" ]), )","title":"from_dict()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntryType","text":"Bases: Enum Describes the Network Entry Type Source code in rxn_network/network/entry.py 13 14 15 16 17 18 19 20 class NetworkEntryType ( Enum ): \"\"\"Describes the Network Entry Type\"\"\" Precursors = auto () Reactants = auto () Products = auto () Target = auto () Dummy = auto ()","title":"NetworkEntryType"},{"location":"reference/network/network/","text":"Implementation of reaction network interface. Graph Bases: PyDiGraph Thin wrapper around rx.PyDiGraph to allow for serialization. Source code in rxn_network/network/network.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Graph ( PyDiGraph ): \"\"\" Thin wrapper around rx.PyDiGraph to allow for serialization. \"\"\" def as_dict ( self ): \"\"\"Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information\"\"\" d = { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ } d [ \"nodes\" ] = [ n . as_dict () for n in self . nodes ()] d [ \"node_indices\" ] = list ( self . node_indices ()) d [ \"edges\" ] = [ ( * e , obj . as_dict () if hasattr ( obj , \"as_dict\" ) else obj ) for e , obj in zip ( self . edge_list (), self . edges ()) ] return d @classmethod def from_dict ( cls , d ): \"\"\"Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information)\"\"\" nodes = MontyDecoder () . process_decoded ( d [ \"nodes\" ]) node_indices = MontyDecoder () . process_decoded ( d [ \"node_indices\" ]) edges = [( e [ 0 ], e [ 1 ], MontyDecoder () . process_decoded ( e [ 2 ])) for e in d [ \"edges\" ]] nodes = dict ( zip ( nodes , node_indices )) graph = cls () new_indices = graph . add_nodes_from ( list ( nodes . keys ())) mapping = { nodes [ node ]: idx for idx , node in zip ( new_indices , nodes . keys ())} new_mapping = [] for edge in edges : new_mapping . append (( mapping [ edge [ 0 ]], mapping [ edge [ 1 ]], edge [ 2 ])) graph . add_edges_from ( new_mapping ) return graph as_dict () Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information Source code in rxn_network/network/network.py 29 30 31 32 33 34 35 36 37 38 39 40 41 def as_dict ( self ): \"\"\"Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information\"\"\" d = { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ } d [ \"nodes\" ] = [ n . as_dict () for n in self . nodes ()] d [ \"node_indices\" ] = list ( self . node_indices ()) d [ \"edges\" ] = [ ( * e , obj . as_dict () if hasattr ( obj , \"as_dict\" ) else obj ) for e , obj in zip ( self . edge_list (), self . edges ()) ] return d from_dict ( d ) classmethod Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information) Source code in rxn_network/network/network.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @classmethod def from_dict ( cls , d ): \"\"\"Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information)\"\"\" nodes = MontyDecoder () . process_decoded ( d [ \"nodes\" ]) node_indices = MontyDecoder () . process_decoded ( d [ \"node_indices\" ]) edges = [( e [ 0 ], e [ 1 ], MontyDecoder () . process_decoded ( e [ 2 ])) for e in d [ \"edges\" ]] nodes = dict ( zip ( nodes , node_indices )) graph = cls () new_indices = graph . add_nodes_from ( list ( nodes . keys ())) mapping = { nodes [ node ]: idx for idx , node in zip ( new_indices , nodes . keys ())} new_mapping = [] for edge in edges : new_mapping . append (( mapping [ edge [ 0 ]], mapping [ edge [ 1 ]], edge [ 2 ])) graph . add_edges_from ( new_mapping ) return graph ReactionNetwork Bases: Network Main reaction network class for building graph networks and performing pathfinding. Graphs are built using rustworkx. Source code in rxn_network/network/network.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class ReactionNetwork ( Network ): \"\"\" Main reaction network class for building graph networks and performing pathfinding. Graphs are built using rustworkx. \"\"\" def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction = field ( default_factory = Softplus ), ): \"\"\" Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Args: rxns: Reaction set of reactions enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( rxns = rxns , cost_function = cost_function ) def build ( self ): \"\"\" In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" self . logger . info ( \"Building graph from reactions...\" ) g = Graph () nodes , edges = get_rxn_nodes_and_edges ( self . rxns ) edges . extend ( get_loopback_edges ( nodes )) g . add_nodes_from ( nodes ) g . add_edges_from ( edges ) self . _g = g def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : self . set_target ( target ) print ( f \"Paths to { self . target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _k_shortest_paths ( k = k ) paths . extend ( pathways ) paths = PathwaySet . from_paths ( paths ) return paths def set_precursors ( self , precursors : Iterable [ Union [ Entry , str ]]): \"\"\" In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Args: precursors: iterable of Entries (or reduced formulas) of precursors Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting precursors!\" ) precursors = { p if isinstance ( p , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( p ) for p in precursors } if precursors == self . precursors : return if not all ( p in self . entries for p in precursors ): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) if self . precursors : # remove old precursors for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Precursors . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old precursors node not found in graph!\" ) precursors_node = g . add_node ( precursors_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): edges_to_add . append (( precursors_node , node , \"precursor_edge\" )) elif entry . description . value == NetworkEntryType . Products . value : for node2 in g . node_indices (): entry2 = g . get_node_data ( node2 ) if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): edges_to_add . append (( node , node2 , \"loopback_edge\" )) g . add_edges_from ( edges_to_add ) self . _precursors = precursors def set_target ( self , target : Union [ Entry , str ]): \"\"\" In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Args: target: Entry, or string of reduced formula, of target Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting target!\" ) target = ( target if isinstance ( target , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( target ) ) if target == self . target : return if target not in self . entries : raise ValueError ( \"Target is not included in network!\" ) if self . target : for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Target . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old target node not found in graph!\" ) target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) target_node = g . add_node ( target_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type != NetworkEntryType . Products . value : continue if target in entry . entries : edges_to_add . append (( node , target_node , \"target_edge\" )) g . add_edges_from ( edges_to_add ) self . _target = target def _k_shortest_paths ( self , k ): \"\"\"Wrapper for finding the k shortest paths using Yen's algorithm. Returns BasicPathway objects\"\"\" g = self . _g paths = [] precursors_node = g . find_node_by_weight ( NetworkEntry ( self . precursors , NetworkEntryType . Precursors ) ) target_node = g . find_node_by_weight ( NetworkEntry ([ self . target ], NetworkEntryType . Target ) ) for path in yens_ksp ( g , self . cost_function , k , precursors_node , target_node ): paths . append ( self . _path_from_graph ( g , path , self . cost_function )) for path in paths : print ( path , \" \\n \" ) return paths @staticmethod def _path_from_graph ( g , path , cf ): \"\"\"Gets a BasicPathway object from a shortest path found in the network\"\"\" rxns = [] costs = [] for step , node in enumerate ( path ): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Products . value ): e = g . get_edge_data ( path [ step - 1 ], node ) rxns . append ( e ) costs . append ( get_edge_weight ( e , cf )) return BasicPathway ( reactions = rxns , costs = costs ) @property def graph ( self ): \"\"\"Returns the Graph object\"\"\" return self . _g @property def chemsys ( self ) -> str : \"\"\"Returns a string of the chemical system of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys )) def as_dict ( self ) -> dict : \"\"\"Return MSONable dict\"\"\" d = super () . as_dict () d [ \"precursors\" ] = list ( self . precursors ) if self . precursors else None d [ \"target\" ] = self . target d [ \"graph\" ] = self . graph . as_dict () return d @classmethod def from_dict ( cls , d ): \"\"\"Instantiate object from MSONable dict\"\"\" precursors = d . pop ( \"precursors\" , None ) target = d . pop ( \"target\" , None ) graph = d . pop ( \"graph\" , None ) rn = super () . from_dict ( d ) rn . _precursors = precursors # pylint: disable=protected-access rn . _target = target # pylint: disable=protected-access rn . _g = MontyDecoder () . process_decoded ( # pylint: disable=protected-access graph ) return rn def __repr__ ( self ): return ( \"ReactionNetwork for chemical system: \" f \" { self . chemsys } , \" f \"with Graph: { str ( self . _g ) } \" ) __init__ ( rxns , cost_function = field ( default_factory = Softplus )) Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Parameters: Name Type Description Default rxns ReactionSet Reaction set of reactions required enumerators iterable of enumerators which will be called during the build of the network required cost_function CostFunction the function used to calculate the cost of each reaction edge field(default_factory=Softplus) open_elem Optional name of an element that is kept open during reaction required chempot Optional associated chemical potential of open element required Source code in rxn_network/network/network.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction = field ( default_factory = Softplus ), ): \"\"\" Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Args: rxns: Reaction set of reactions enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( rxns = rxns , cost_function = cost_function ) as_dict () Return MSONable dict Source code in rxn_network/network/network.py 309 310 311 312 313 314 315 def as_dict ( self ) -> dict : \"\"\"Return MSONable dict\"\"\" d = super () . as_dict () d [ \"precursors\" ] = list ( self . precursors ) if self . precursors else None d [ \"target\" ] = self . target d [ \"graph\" ] = self . graph . as_dict () return d build () In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: Type Description None Source code in rxn_network/network/network.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def build ( self ): \"\"\" In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" self . logger . info ( \"Building graph from reactions...\" ) g = Graph () nodes , edges = get_rxn_nodes_and_edges ( self . rxns ) edges . extend ( get_loopback_edges ( nodes )) g . add_nodes_from ( nodes ) g . add_edges_from ( edges ) self . _g = g chemsys () property Returns a string of the chemical system of the network Source code in rxn_network/network/network.py 304 305 306 307 @property def chemsys ( self ) -> str : \"\"\"Returns a string of the chemical system of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys )) find_pathways ( targets , k = 15 ) Find the k-shortest paths to a provided list of 1 or more targets. Parameters: Name Type Description Default targets List [ str ] List of the formulas of each target required k float Number of shortest paths to find for each target 15 Returns: Type Description List [ BasicPathway ] List of BasicPathway objects to all provided targets. Source code in rxn_network/network/network.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : self . set_target ( target ) print ( f \"Paths to { self . target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _k_shortest_paths ( k = k ) paths . extend ( pathways ) paths = PathwaySet . from_paths ( paths ) return paths from_dict ( d ) classmethod Instantiate object from MSONable dict Source code in rxn_network/network/network.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @classmethod def from_dict ( cls , d ): \"\"\"Instantiate object from MSONable dict\"\"\" precursors = d . pop ( \"precursors\" , None ) target = d . pop ( \"target\" , None ) graph = d . pop ( \"graph\" , None ) rn = super () . from_dict ( d ) rn . _precursors = precursors # pylint: disable=protected-access rn . _target = target # pylint: disable=protected-access rn . _g = MontyDecoder () . process_decoded ( # pylint: disable=protected-access graph ) return rn graph () property Returns the Graph object Source code in rxn_network/network/network.py 299 300 301 302 @property def graph ( self ): \"\"\"Returns the Graph object\"\"\" return self . _g set_precursors ( precursors ) In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Parameters: Name Type Description Default precursors Iterable [ Union [ Entry , str ]] iterable of Entries (or reduced formulas) of precursors required Returns: Type Description None Source code in rxn_network/network/network.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def set_precursors ( self , precursors : Iterable [ Union [ Entry , str ]]): \"\"\" In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Args: precursors: iterable of Entries (or reduced formulas) of precursors Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting precursors!\" ) precursors = { p if isinstance ( p , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( p ) for p in precursors } if precursors == self . precursors : return if not all ( p in self . entries for p in precursors ): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) if self . precursors : # remove old precursors for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Precursors . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old precursors node not found in graph!\" ) precursors_node = g . add_node ( precursors_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): edges_to_add . append (( precursors_node , node , \"precursor_edge\" )) elif entry . description . value == NetworkEntryType . Products . value : for node2 in g . node_indices (): entry2 = g . get_node_data ( node2 ) if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): edges_to_add . append (( node , node2 , \"loopback_edge\" )) g . add_edges_from ( edges_to_add ) self . _precursors = precursors set_target ( target ) In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Parameters: Name Type Description Default target Union [ Entry , str ] Entry, or string of reduced formula, of target required Returns: Type Description None Source code in rxn_network/network/network.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def set_target ( self , target : Union [ Entry , str ]): \"\"\" In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Args: target: Entry, or string of reduced formula, of target Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting target!\" ) target = ( target if isinstance ( target , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( target ) ) if target == self . target : return if target not in self . entries : raise ValueError ( \"Target is not included in network!\" ) if self . target : for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Target . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old target node not found in graph!\" ) target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) target_node = g . add_node ( target_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type != NetworkEntryType . Products . value : continue if target in entry . entries : edges_to_add . append (( node , target_node , \"target_edge\" )) g . add_edges_from ( edges_to_add ) self . _target = target get_loopback_edges ( nodes ) Given a list of nodes to check, this function finds and returns loopback edges (i.e., edges that connect a product node to its equivalent reactant node) Parameters: Name Type Description Default nodes List of vertices from which to find loopback edges required Returns: Type Description A list of tuples of the form (source_idx, target_idx, cost=0, rxn=None, type=\"loopback\") Source code in rxn_network/network/network.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def get_loopback_edges ( nodes ): \"\"\" Given a list of nodes to check, this function finds and returns loopback edges (i.e., edges that connect a product node to its equivalent reactant node) Args: nodes: List of vertices from which to find loopback edges Returns: A list of tuples of the form (source_idx, target_idx, cost=0, rxn=None, type=\"loopback\") \"\"\" edges = [] for idx1 , p in enumerate ( nodes ): if p . description . value != NetworkEntryType . Products . value : continue for idx2 , r in enumerate ( nodes ): if r . description . value != NetworkEntryType . Reactants . value : continue if p . entries == r . entries : edges . append (( idx1 , idx2 , \"loopback_edge\" )) return edges get_rxn_nodes_and_edges ( rxns ) Given a reaction set, return a list of nodes and edges for constructing the reaction network. Parameters: Name Type Description Default rxns ReactionSet a list of enumerated ComputedReaction objects to build a network from. required Returns: Type Description A tuple consisting of (nodes, edges) where nodes is a list of NetworkEntry objects and edges is a list of tuples of the form (source_idx, target_idx). Source code in rxn_network/network/network.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def get_rxn_nodes_and_edges ( rxns : ReactionSet ): \"\"\" Given a reaction set, return a list of nodes and edges for constructing the reaction network. Args: rxns: a list of enumerated ComputedReaction objects to build a network from. Returns: A tuple consisting of (nodes, edges) where nodes is a list of NetworkEntry objects and edges is a list of tuples of the form (source_idx, target_idx). \"\"\" nodes , edges = [], [] for rxn in tqdm ( rxns ): reactant_node = NetworkEntry ( rxn . reactant_entries , NetworkEntryType . Reactants ) product_node = NetworkEntry ( rxn . product_entries , NetworkEntryType . Products ) if reactant_node not in nodes : nodes . append ( reactant_node ) reactant_idx = len ( nodes ) - 1 else : reactant_idx = nodes . index ( reactant_node ) if product_node not in nodes : nodes . append ( product_node ) product_idx = len ( nodes ) - 1 else : product_idx = nodes . index ( product_node ) edges . append (( reactant_idx , product_idx , rxn )) return nodes , edges yens_ksp ( g , cf , num_k , precursors_node , target_node ) Yen's Algorithm for k-shortest paths, adopted for rustworkx. This implementation was inspired by the igraph implementation by Antonin Lenfant. Reference Jin Y. Yen, \"Finding the K Shortest Loopless Paths n a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Parameters: Name Type Description Default g rx . PyGraph the rustworkx PyGraph object required num_k int number of k shortest paths that should be found. required precursors_node int the index of the node representing the precursors. required target_node int the index of the node representing the targets. required Returns: Type Description List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). Source code in rxn_network/network/network.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def yens_ksp ( g : rx . PyGraph , cf : CostFunction , num_k : int , precursors_node : int , target_node : int , ): \"\"\" Yen's Algorithm for k-shortest paths, adopted for rustworkx. This implementation was inspired by the igraph implementation by Antonin Lenfant. Reference: Jin Y. Yen, \"Finding the K Shortest Loopless Paths n a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Args: g: the rustworkx PyGraph object num_k: number of k shortest paths that should be found. precursors_node: the index of the node representing the precursors. target_node: the index of the node representing the targets. Returns: List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). \"\"\" def path_cost ( nodes ): \"\"\"Calculates path cost given a list of nodes\"\"\" cost = 0 for j in range ( len ( nodes ) - 1 ): cost += get_edge_weight ( g . get_edge_data ( nodes [ j ], nodes [ j + 1 ]), cf ) return cost def get_edge_weight_with_cf ( edge_obj ): return get_edge_weight ( edge_obj , cf ) g = g . copy () path = rx . dijkstra_shortest_paths ( g , precursors_node , target_node , weight_fn = get_edge_weight_with_cf ) if not path : return [] path = list ( path [ target_node ]) a = [ path ] a_costs = [ path_cost ( path )] b = PriorityQueue () # type: ignore for k in range ( 1 , num_k ): try : prev_path = a [ k - 1 ] except IndexError : print ( f \"Identified only k= { k - 1 } paths before exiting. \\n \" ) break for i in range ( len ( prev_path ) - 1 ): spur_node = prev_path [ i ] root_path = prev_path [: i ] removed_edges = [] for path in a : if len ( path ) - 1 > i and root_path == path [: i ]: try : e = g . get_edge_data ( path [ i ], path [ i + 1 ]) except rx . NoEdgeBetweenNodes : continue g . remove_edge ( path [ i ], path [ i + 1 ]) removed_edges . append (( path [ i ], path [ i + 1 ], e )) spur_path = rx . dijkstra_shortest_paths ( g , spur_node , target_node , weight_fn = get_edge_weight_with_cf ) g . add_edges_from ( removed_edges ) if spur_path : total_path = list ( root_path ) + list ( spur_path [ target_node ]) total_path_cost = path_cost ( total_path ) b . put (( total_path_cost , total_path )) while True : try : cost_ , path_ = b . get ( block = False ) except Empty : break if path_ not in a : a . append ( path_ ) a_costs . append ( cost_ ) break return a","title":"Network"},{"location":"reference/network/network/#rxn_network.network.network.Graph","text":"Bases: PyDiGraph Thin wrapper around rx.PyDiGraph to allow for serialization. Source code in rxn_network/network/network.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 class Graph ( PyDiGraph ): \"\"\" Thin wrapper around rx.PyDiGraph to allow for serialization. \"\"\" def as_dict ( self ): \"\"\"Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information\"\"\" d = { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ } d [ \"nodes\" ] = [ n . as_dict () for n in self . nodes ()] d [ \"node_indices\" ] = list ( self . node_indices ()) d [ \"edges\" ] = [ ( * e , obj . as_dict () if hasattr ( obj , \"as_dict\" ) else obj ) for e , obj in zip ( self . edge_list (), self . edges ()) ] return d @classmethod def from_dict ( cls , d ): \"\"\"Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information)\"\"\" nodes = MontyDecoder () . process_decoded ( d [ \"nodes\" ]) node_indices = MontyDecoder () . process_decoded ( d [ \"node_indices\" ]) edges = [( e [ 0 ], e [ 1 ], MontyDecoder () . process_decoded ( e [ 2 ])) for e in d [ \"edges\" ]] nodes = dict ( zip ( nodes , node_indices )) graph = cls () new_indices = graph . add_nodes_from ( list ( nodes . keys ())) mapping = { nodes [ node ]: idx for idx , node in zip ( new_indices , nodes . keys ())} new_mapping = [] for edge in edges : new_mapping . append (( mapping [ edge [ 0 ]], mapping [ edge [ 1 ]], edge [ 2 ])) graph . add_edges_from ( new_mapping ) return graph","title":"Graph"},{"location":"reference/network/network/#rxn_network.network.network.Graph.as_dict","text":"Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information Source code in rxn_network/network/network.py 29 30 31 32 33 34 35 36 37 38 39 40 41 def as_dict ( self ): \"\"\"Represents the PyDiGraph object as a serializable dictionary (see monty package, MSONable, for more information\"\"\" d = { \"@module\" : self . __class__ . __module__ , \"@class\" : self . __class__ . __name__ } d [ \"nodes\" ] = [ n . as_dict () for n in self . nodes ()] d [ \"node_indices\" ] = list ( self . node_indices ()) d [ \"edges\" ] = [ ( * e , obj . as_dict () if hasattr ( obj , \"as_dict\" ) else obj ) for e , obj in zip ( self . edge_list (), self . edges ()) ] return d","title":"as_dict()"},{"location":"reference/network/network/#rxn_network.network.network.Graph.from_dict","text":"Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information) Source code in rxn_network/network/network.py 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 @classmethod def from_dict ( cls , d ): \"\"\"Instantiates a Graph object from a dictionary (see monty package, MSONable, for more information)\"\"\" nodes = MontyDecoder () . process_decoded ( d [ \"nodes\" ]) node_indices = MontyDecoder () . process_decoded ( d [ \"node_indices\" ]) edges = [( e [ 0 ], e [ 1 ], MontyDecoder () . process_decoded ( e [ 2 ])) for e in d [ \"edges\" ]] nodes = dict ( zip ( nodes , node_indices )) graph = cls () new_indices = graph . add_nodes_from ( list ( nodes . keys ())) mapping = { nodes [ node ]: idx for idx , node in zip ( new_indices , nodes . keys ())} new_mapping = [] for edge in edges : new_mapping . append (( mapping [ edge [ 0 ]], mapping [ edge [ 1 ]], edge [ 2 ])) graph . add_edges_from ( new_mapping ) return graph","title":"from_dict()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork","text":"Bases: Network Main reaction network class for building graph networks and performing pathfinding. Graphs are built using rustworkx. Source code in rxn_network/network/network.py 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 class ReactionNetwork ( Network ): \"\"\" Main reaction network class for building graph networks and performing pathfinding. Graphs are built using rustworkx. \"\"\" def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction = field ( default_factory = Softplus ), ): \"\"\" Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Args: rxns: Reaction set of reactions enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( rxns = rxns , cost_function = cost_function ) def build ( self ): \"\"\" In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" self . logger . info ( \"Building graph from reactions...\" ) g = Graph () nodes , edges = get_rxn_nodes_and_edges ( self . rxns ) edges . extend ( get_loopback_edges ( nodes )) g . add_nodes_from ( nodes ) g . add_edges_from ( edges ) self . _g = g def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : self . set_target ( target ) print ( f \"Paths to { self . target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _k_shortest_paths ( k = k ) paths . extend ( pathways ) paths = PathwaySet . from_paths ( paths ) return paths def set_precursors ( self , precursors : Iterable [ Union [ Entry , str ]]): \"\"\" In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Args: precursors: iterable of Entries (or reduced formulas) of precursors Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting precursors!\" ) precursors = { p if isinstance ( p , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( p ) for p in precursors } if precursors == self . precursors : return if not all ( p in self . entries for p in precursors ): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) if self . precursors : # remove old precursors for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Precursors . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old precursors node not found in graph!\" ) precursors_node = g . add_node ( precursors_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): edges_to_add . append (( precursors_node , node , \"precursor_edge\" )) elif entry . description . value == NetworkEntryType . Products . value : for node2 in g . node_indices (): entry2 = g . get_node_data ( node2 ) if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): edges_to_add . append (( node , node2 , \"loopback_edge\" )) g . add_edges_from ( edges_to_add ) self . _precursors = precursors def set_target ( self , target : Union [ Entry , str ]): \"\"\" In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Args: target: Entry, or string of reduced formula, of target Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting target!\" ) target = ( target if isinstance ( target , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( target ) ) if target == self . target : return if target not in self . entries : raise ValueError ( \"Target is not included in network!\" ) if self . target : for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Target . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old target node not found in graph!\" ) target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) target_node = g . add_node ( target_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type != NetworkEntryType . Products . value : continue if target in entry . entries : edges_to_add . append (( node , target_node , \"target_edge\" )) g . add_edges_from ( edges_to_add ) self . _target = target def _k_shortest_paths ( self , k ): \"\"\"Wrapper for finding the k shortest paths using Yen's algorithm. Returns BasicPathway objects\"\"\" g = self . _g paths = [] precursors_node = g . find_node_by_weight ( NetworkEntry ( self . precursors , NetworkEntryType . Precursors ) ) target_node = g . find_node_by_weight ( NetworkEntry ([ self . target ], NetworkEntryType . Target ) ) for path in yens_ksp ( g , self . cost_function , k , precursors_node , target_node ): paths . append ( self . _path_from_graph ( g , path , self . cost_function )) for path in paths : print ( path , \" \\n \" ) return paths @staticmethod def _path_from_graph ( g , path , cf ): \"\"\"Gets a BasicPathway object from a shortest path found in the network\"\"\" rxns = [] costs = [] for step , node in enumerate ( path ): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Products . value ): e = g . get_edge_data ( path [ step - 1 ], node ) rxns . append ( e ) costs . append ( get_edge_weight ( e , cf )) return BasicPathway ( reactions = rxns , costs = costs ) @property def graph ( self ): \"\"\"Returns the Graph object\"\"\" return self . _g @property def chemsys ( self ) -> str : \"\"\"Returns a string of the chemical system of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys )) def as_dict ( self ) -> dict : \"\"\"Return MSONable dict\"\"\" d = super () . as_dict () d [ \"precursors\" ] = list ( self . precursors ) if self . precursors else None d [ \"target\" ] = self . target d [ \"graph\" ] = self . graph . as_dict () return d @classmethod def from_dict ( cls , d ): \"\"\"Instantiate object from MSONable dict\"\"\" precursors = d . pop ( \"precursors\" , None ) target = d . pop ( \"target\" , None ) graph = d . pop ( \"graph\" , None ) rn = super () . from_dict ( d ) rn . _precursors = precursors # pylint: disable=protected-access rn . _target = target # pylint: disable=protected-access rn . _g = MontyDecoder () . process_decoded ( # pylint: disable=protected-access graph ) return rn def __repr__ ( self ): return ( \"ReactionNetwork for chemical system: \" f \" { self . chemsys } , \" f \"with Graph: { str ( self . _g ) } \" )","title":"ReactionNetwork"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.__init__","text":"Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Parameters: Name Type Description Default rxns ReactionSet Reaction set of reactions required enumerators iterable of enumerators which will be called during the build of the network required cost_function CostFunction the function used to calculate the cost of each reaction edge field(default_factory=Softplus) open_elem Optional name of an element that is kept open during reaction required chempot Optional associated chemical potential of open element required Source code in rxn_network/network/network.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 def __init__ ( self , rxns : ReactionSet , cost_function : CostFunction = field ( default_factory = Softplus ), ): \"\"\" Initialize a ReactionNetwork object for a set of reactions. Note: the precursors and target are not set by default. You must call set_precursors() and set_target() in place. Args: rxns: Reaction set of reactions enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( rxns = rxns , cost_function = cost_function )","title":"__init__()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.as_dict","text":"Return MSONable dict Source code in rxn_network/network/network.py 309 310 311 312 313 314 315 def as_dict ( self ) -> dict : \"\"\"Return MSONable dict\"\"\" d = super () . as_dict () d [ \"precursors\" ] = list ( self . precursors ) if self . precursors else None d [ \"target\" ] = self . target d [ \"graph\" ] = self . graph . as_dict () return d","title":"as_dict()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.build","text":"In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: Type Description None Source code in rxn_network/network/network.py 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 def build ( self ): \"\"\" In-place method. Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" self . logger . info ( \"Building graph from reactions...\" ) g = Graph () nodes , edges = get_rxn_nodes_and_edges ( self . rxns ) edges . extend ( get_loopback_edges ( nodes )) g . add_nodes_from ( nodes ) g . add_edges_from ( edges ) self . _g = g","title":"build()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.chemsys","text":"Returns a string of the chemical system of the network Source code in rxn_network/network/network.py 304 305 306 307 @property def chemsys ( self ) -> str : \"\"\"Returns a string of the chemical system of the network\"\"\" return \"-\" . join ( sorted ( self . entries . chemsys ))","title":"chemsys()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.find_pathways","text":"Find the k-shortest paths to a provided list of 1 or more targets. Parameters: Name Type Description Default targets List [ str ] List of the formulas of each target required k float Number of shortest paths to find for each target 15 Returns: Type Description List [ BasicPathway ] List of BasicPathway objects to all provided targets. Source code in rxn_network/network/network.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : self . set_target ( target ) print ( f \"Paths to { self . target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _k_shortest_paths ( k = k ) paths . extend ( pathways ) paths = PathwaySet . from_paths ( paths ) return paths","title":"find_pathways()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.from_dict","text":"Instantiate object from MSONable dict Source code in rxn_network/network/network.py 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 @classmethod def from_dict ( cls , d ): \"\"\"Instantiate object from MSONable dict\"\"\" precursors = d . pop ( \"precursors\" , None ) target = d . pop ( \"target\" , None ) graph = d . pop ( \"graph\" , None ) rn = super () . from_dict ( d ) rn . _precursors = precursors # pylint: disable=protected-access rn . _target = target # pylint: disable=protected-access rn . _g = MontyDecoder () . process_decoded ( # pylint: disable=protected-access graph ) return rn","title":"from_dict()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.graph","text":"Returns the Graph object Source code in rxn_network/network/network.py 299 300 301 302 @property def graph ( self ): \"\"\"Returns the Graph object\"\"\" return self . _g","title":"graph()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.set_precursors","text":"In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Parameters: Name Type Description Default precursors Iterable [ Union [ Entry , str ]] iterable of Entries (or reduced formulas) of precursors required Returns: Type Description None Source code in rxn_network/network/network.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 def set_precursors ( self , precursors : Iterable [ Union [ Entry , str ]]): \"\"\" In-place method. Sets the precursors of the network. Removes all references to previous precursors. If entries are provided, will use the entries to set the precursors. If strings are provided, will automatically find minimum-energy entries with matching reduced_formula. Args: precursors: iterable of Entries (or reduced formulas) of precursors Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting precursors!\" ) precursors = { p if isinstance ( p , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( p ) for p in precursors } if precursors == self . precursors : return if not all ( p in self . entries for p in precursors ): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) if self . precursors : # remove old precursors for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Precursors . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old precursors node not found in graph!\" ) precursors_node = g . add_node ( precursors_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): edges_to_add . append (( precursors_node , node , \"precursor_edge\" )) elif entry . description . value == NetworkEntryType . Products . value : for node2 in g . node_indices (): entry2 = g . get_node_data ( node2 ) if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): edges_to_add . append (( node , node2 , \"loopback_edge\" )) g . add_edges_from ( edges_to_add ) self . _precursors = precursors","title":"set_precursors()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.set_target","text":"In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Parameters: Name Type Description Default target Union [ Entry , str ] Entry, or string of reduced formula, of target required Returns: Type Description None Source code in rxn_network/network/network.py 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 def set_target ( self , target : Union [ Entry , str ]): \"\"\" In-place method. If entry is provided, will use that entry to set the target. If string is provided, will automatically find minimum-energy entry with matching reduced_formula. Args: target: Entry, or string of reduced formula, of target Returns: None \"\"\" g = self . _g if not g : raise ValueError ( \"Must call build() before setting target!\" ) target = ( target if isinstance ( target , ( Entry , ExperimentalReferenceEntry )) else self . entries . get_min_entry_by_formula ( target ) ) if target == self . target : return if target not in self . entries : raise ValueError ( \"Target is not included in network!\" ) if self . target : for node in g . node_indices (): if ( g . get_node_data ( node ) . description . value == NetworkEntryType . Target . value ): g . remove_node ( node ) break else : raise ValueError ( \"Old target node not found in graph!\" ) target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) target_node = g . add_node ( target_entry ) edges_to_add = [] for node in g . node_indices (): entry = g . get_node_data ( node ) entry_type = entry . description . value if entry_type != NetworkEntryType . Products . value : continue if target in entry . entries : edges_to_add . append (( node , target_node , \"target_edge\" )) g . add_edges_from ( edges_to_add ) self . _target = target","title":"set_target()"},{"location":"reference/network/network/#rxn_network.network.network.get_loopback_edges","text":"Given a list of nodes to check, this function finds and returns loopback edges (i.e., edges that connect a product node to its equivalent reactant node) Parameters: Name Type Description Default nodes List of vertices from which to find loopback edges required Returns: Type Description A list of tuples of the form (source_idx, target_idx, cost=0, rxn=None, type=\"loopback\") Source code in rxn_network/network/network.py 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 def get_loopback_edges ( nodes ): \"\"\" Given a list of nodes to check, this function finds and returns loopback edges (i.e., edges that connect a product node to its equivalent reactant node) Args: nodes: List of vertices from which to find loopback edges Returns: A list of tuples of the form (source_idx, target_idx, cost=0, rxn=None, type=\"loopback\") \"\"\" edges = [] for idx1 , p in enumerate ( nodes ): if p . description . value != NetworkEntryType . Products . value : continue for idx2 , r in enumerate ( nodes ): if r . description . value != NetworkEntryType . Reactants . value : continue if p . entries == r . entries : edges . append (( idx1 , idx2 , \"loopback_edge\" )) return edges","title":"get_loopback_edges()"},{"location":"reference/network/network/#rxn_network.network.network.get_rxn_nodes_and_edges","text":"Given a reaction set, return a list of nodes and edges for constructing the reaction network. Parameters: Name Type Description Default rxns ReactionSet a list of enumerated ComputedReaction objects to build a network from. required Returns: Type Description A tuple consisting of (nodes, edges) where nodes is a list of NetworkEntry objects and edges is a list of tuples of the form (source_idx, target_idx). Source code in rxn_network/network/network.py 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 def get_rxn_nodes_and_edges ( rxns : ReactionSet ): \"\"\" Given a reaction set, return a list of nodes and edges for constructing the reaction network. Args: rxns: a list of enumerated ComputedReaction objects to build a network from. Returns: A tuple consisting of (nodes, edges) where nodes is a list of NetworkEntry objects and edges is a list of tuples of the form (source_idx, target_idx). \"\"\" nodes , edges = [], [] for rxn in tqdm ( rxns ): reactant_node = NetworkEntry ( rxn . reactant_entries , NetworkEntryType . Reactants ) product_node = NetworkEntry ( rxn . product_entries , NetworkEntryType . Products ) if reactant_node not in nodes : nodes . append ( reactant_node ) reactant_idx = len ( nodes ) - 1 else : reactant_idx = nodes . index ( reactant_node ) if product_node not in nodes : nodes . append ( product_node ) product_idx = len ( nodes ) - 1 else : product_idx = nodes . index ( product_node ) edges . append (( reactant_idx , product_idx , rxn )) return nodes , edges","title":"get_rxn_nodes_and_edges()"},{"location":"reference/network/network/#rxn_network.network.network.yens_ksp","text":"Yen's Algorithm for k-shortest paths, adopted for rustworkx. This implementation was inspired by the igraph implementation by Antonin Lenfant. Reference Jin Y. Yen, \"Finding the K Shortest Loopless Paths n a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Parameters: Name Type Description Default g rx . PyGraph the rustworkx PyGraph object required num_k int number of k shortest paths that should be found. required precursors_node int the index of the node representing the precursors. required target_node int the index of the node representing the targets. required Returns: Type Description List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). Source code in rxn_network/network/network.py 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 def yens_ksp ( g : rx . PyGraph , cf : CostFunction , num_k : int , precursors_node : int , target_node : int , ): \"\"\" Yen's Algorithm for k-shortest paths, adopted for rustworkx. This implementation was inspired by the igraph implementation by Antonin Lenfant. Reference: Jin Y. Yen, \"Finding the K Shortest Loopless Paths n a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Args: g: the rustworkx PyGraph object num_k: number of k shortest paths that should be found. precursors_node: the index of the node representing the precursors. target_node: the index of the node representing the targets. Returns: List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). \"\"\" def path_cost ( nodes ): \"\"\"Calculates path cost given a list of nodes\"\"\" cost = 0 for j in range ( len ( nodes ) - 1 ): cost += get_edge_weight ( g . get_edge_data ( nodes [ j ], nodes [ j + 1 ]), cf ) return cost def get_edge_weight_with_cf ( edge_obj ): return get_edge_weight ( edge_obj , cf ) g = g . copy () path = rx . dijkstra_shortest_paths ( g , precursors_node , target_node , weight_fn = get_edge_weight_with_cf ) if not path : return [] path = list ( path [ target_node ]) a = [ path ] a_costs = [ path_cost ( path )] b = PriorityQueue () # type: ignore for k in range ( 1 , num_k ): try : prev_path = a [ k - 1 ] except IndexError : print ( f \"Identified only k= { k - 1 } paths before exiting. \\n \" ) break for i in range ( len ( prev_path ) - 1 ): spur_node = prev_path [ i ] root_path = prev_path [: i ] removed_edges = [] for path in a : if len ( path ) - 1 > i and root_path == path [: i ]: try : e = g . get_edge_data ( path [ i ], path [ i + 1 ]) except rx . NoEdgeBetweenNodes : continue g . remove_edge ( path [ i ], path [ i + 1 ]) removed_edges . append (( path [ i ], path [ i + 1 ], e )) spur_path = rx . dijkstra_shortest_paths ( g , spur_node , target_node , weight_fn = get_edge_weight_with_cf ) g . add_edges_from ( removed_edges ) if spur_path : total_path = list ( root_path ) + list ( spur_path [ target_node ]) total_path_cost = path_cost ( total_path ) b . put (( total_path_cost , total_path )) while True : try : cost_ , path_ = b . get ( block = False ) except Empty : break if path_ not in a : a . append ( path_ ) a_costs . append ( cost_ ) break return a","title":"yens_ksp()"},{"location":"reference/network/visualize/","text":"Functions for visualizing/plotting reaction networks. plot_network ( graph , vertex_cmap_name = 'jet' , ** kwargs ) Plots a reaction network using rustworkx visualization tools (i.e., mpl_draw) Parameters: Name Type Description Default graph rx . PyGraph a rustworkx PyGraph object required vertex_cmap_name str the name of . Defaults to \"jet\". 'jet' **kwargs keyword arguments to pass to mpl_draw {} Source code in rxn_network/network/visualize.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def plot_network ( graph : rx . PyGraph , vertex_cmap_name : str = \"jet\" , ** kwargs ): \"\"\" Plots a reaction network using rustworkx visualization tools (i.e., mpl_draw) Args: graph: a rustworkx PyGraph object vertex_cmap_name: the name of . Defaults to \"jet\". **kwargs: keyword arguments to pass to mpl_draw \"\"\" g = graph . copy () node_names = [ e . chemsys for e in g . nodes ()] color_func_v = _get_cmap_string ( vertex_cmap_name , domain = sorted ( node_names )) vertex_colors = [ color_func_v ( chemsys ) for chemsys in node_names ] return mpl_draw ( g , node_size = 2 , width = 0.2 , arrow_size = 3 , node_color = vertex_colors , alpha = 0.8 , ** kwargs )","title":"Visualize"},{"location":"reference/network/visualize/#rxn_network.network.visualize.plot_network","text":"Plots a reaction network using rustworkx visualization tools (i.e., mpl_draw) Parameters: Name Type Description Default graph rx . PyGraph a rustworkx PyGraph object required vertex_cmap_name str the name of . Defaults to \"jet\". 'jet' **kwargs keyword arguments to pass to mpl_draw {} Source code in rxn_network/network/visualize.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def plot_network ( graph : rx . PyGraph , vertex_cmap_name : str = \"jet\" , ** kwargs ): \"\"\" Plots a reaction network using rustworkx visualization tools (i.e., mpl_draw) Args: graph: a rustworkx PyGraph object vertex_cmap_name: the name of . Defaults to \"jet\". **kwargs: keyword arguments to pass to mpl_draw \"\"\" g = graph . copy () node_names = [ e . chemsys for e in g . nodes ()] color_func_v = _get_cmap_string ( vertex_cmap_name , domain = sorted ( node_names )) vertex_colors = [ color_func_v ( chemsys ) for chemsys in node_names ] return mpl_draw ( g , node_size = 2 , width = 0.2 , arrow_size = 3 , node_color = vertex_colors , alpha = 0.8 , ** kwargs )","title":"plot_network()"},{"location":"reference/pathways/balanced/","text":"Implements a class for storing balanced reaction pathways. BalancedPathway Bases: BasicPathway Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes costs for each reaction. Source code in rxn_network/pathways/balanced.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class BalancedPathway ( BasicPathway ): \"\"\" Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes costs for each reaction. \"\"\" def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : List [ float ], balanced : bool = False , ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. coefficients: list of coefficients to balance each of these reactions, respectively costs: list of corresponding costs for each reaction. balanced: whether or not the reaction pathway is balanced. Defaults to False. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) self . balanced = balanced def __eq__ ( self , other ): if super () . __eq__ ( other ): return np . allclose ( self . costs , other . costs ) return False def __hash__ ( self ): return hash (( tuple ( self . reactions ), tuple ( self . coefficients ))) @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. \"\"\" def comp_matrix ( self ) -> np . ndarray : \"\"\" Internal method for getting the composition matrix used in the balancing procedure. Returns: An array representing the composition matrix for a reaction \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] ) def get_coeff_vector_for_rxn ( self , rxn ) -> np . ndarray : \"\"\" Internal method for getting the net reaction coefficients vector. Args: rxn: Reaction object to get coefficients for Returns: An array representing the reaction coefficients vector \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] ) def contains_interdependent_rxns ( self , precursors : List [ Composition ]) -> bool : \"\"\" Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Args: precursors: List of precursor compositions \"\"\" precursors_set = set ( precursors ) interdependent = False rxns = set ( self . reactions ) num_rxns = len ( rxns ) if num_rxns == 1 : return False for combo in limited_powerset ( rxns , num_rxns ): size = len ( combo ) if ( any ( set ( rxn . reactants ) . issubset ( precursors_set ) for rxn in combo ) or size == 1 ): continue other_comp = { c for rxn in ( rxns - set ( combo )) for c in rxn . compositions } unique_reactants = [] unique_products = [] for rxn in combo : unique_reactants . append ( set ( rxn . reactants ) - precursors_set ) unique_products . append ( set ( rxn . products ) - precursors_set ) overlap = [ False ] * size for i in range ( size ): for j in range ( size ): if i == j : continue overlapping_phases = unique_reactants [ i ] & unique_products [ j ] if overlapping_phases and ( overlapping_phases not in other_comp ): overlap [ i ] = True if all ( overlap ): interdependent = True return interdependent @property def average_cost ( self ) -> float : \"\"\"Returns the mean cost of the pathway\"\"\" return np . dot ( self . coefficients , self . costs ) / sum ( self . coefficients ) def __repr__ ( self ): path_info = \"\" for rxn in self . reactions : path_info += f \" { rxn } (dG = { round ( rxn . energy_per_atom , 3 ) } eV/atom) \\n \" path_info += f \"Average Cost: { round ( self . average_cost , 3 ) } \" return path_info __init__ ( reactions , coefficients , costs , balanced = False ) Parameters: Name Type Description Default reactions List [ Reaction ] list of ComputedReaction objects which occur along path. required coefficients List [ float ] list of coefficients to balance each of these reactions, respectively required costs List [ float ] list of corresponding costs for each reaction. required balanced bool whether or not the reaction pathway is balanced. Defaults to False. False Source code in rxn_network/pathways/balanced.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : List [ float ], balanced : bool = False , ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. coefficients: list of coefficients to balance each of these reactions, respectively costs: list of corresponding costs for each reaction. balanced: whether or not the reaction pathway is balanced. Defaults to False. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) self . balanced = balanced average_cost () property Returns the mean cost of the pathway Source code in rxn_network/pathways/balanced.py 150 151 152 153 @property def average_cost ( self ) -> float : \"\"\"Returns the mean cost of the pathway\"\"\" return np . dot ( self . coefficients , self . costs ) / sum ( self . coefficients ) balance ( pathway_sets , net_reaction , tol = 1e-06 ) classmethod TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. Source code in rxn_network/pathways/balanced.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. \"\"\" comp_matrix () Internal method for getting the composition matrix used in the balancing procedure. Returns: Type Description np . ndarray An array representing the composition matrix for a reaction Source code in rxn_network/pathways/balanced.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def comp_matrix ( self ) -> np . ndarray : \"\"\" Internal method for getting the composition matrix used in the balancing procedure. Returns: An array representing the composition matrix for a reaction \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] ) contains_interdependent_rxns ( precursors ) Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Parameters: Name Type Description Default precursors List [ Composition ] List of precursor compositions required Source code in rxn_network/pathways/balanced.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def contains_interdependent_rxns ( self , precursors : List [ Composition ]) -> bool : \"\"\" Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Args: precursors: List of precursor compositions \"\"\" precursors_set = set ( precursors ) interdependent = False rxns = set ( self . reactions ) num_rxns = len ( rxns ) if num_rxns == 1 : return False for combo in limited_powerset ( rxns , num_rxns ): size = len ( combo ) if ( any ( set ( rxn . reactants ) . issubset ( precursors_set ) for rxn in combo ) or size == 1 ): continue other_comp = { c for rxn in ( rxns - set ( combo )) for c in rxn . compositions } unique_reactants = [] unique_products = [] for rxn in combo : unique_reactants . append ( set ( rxn . reactants ) - precursors_set ) unique_products . append ( set ( rxn . products ) - precursors_set ) overlap = [ False ] * size for i in range ( size ): for j in range ( size ): if i == j : continue overlapping_phases = unique_reactants [ i ] & unique_products [ j ] if overlapping_phases and ( overlapping_phases not in other_comp ): overlap [ i ] = True if all ( overlap ): interdependent = True return interdependent get_coeff_vector_for_rxn ( rxn ) Internal method for getting the net reaction coefficients vector. Parameters: Name Type Description Default rxn Reaction object to get coefficients for required Returns: Type Description np . ndarray An array representing the reaction coefficients vector Source code in rxn_network/pathways/balanced.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def get_coeff_vector_for_rxn ( self , rxn ) -> np . ndarray : \"\"\" Internal method for getting the net reaction coefficients vector. Args: rxn: Reaction object to get coefficients for Returns: An array representing the reaction coefficients vector \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] )","title":"Balanced"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway","text":"Bases: BasicPathway Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes costs for each reaction. Source code in rxn_network/pathways/balanced.py 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 class BalancedPathway ( BasicPathway ): \"\"\" Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes costs for each reaction. \"\"\" def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : List [ float ], balanced : bool = False , ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. coefficients: list of coefficients to balance each of these reactions, respectively costs: list of corresponding costs for each reaction. balanced: whether or not the reaction pathway is balanced. Defaults to False. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) self . balanced = balanced def __eq__ ( self , other ): if super () . __eq__ ( other ): return np . allclose ( self . costs , other . costs ) return False def __hash__ ( self ): return hash (( tuple ( self . reactions ), tuple ( self . coefficients ))) @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. \"\"\" def comp_matrix ( self ) -> np . ndarray : \"\"\" Internal method for getting the composition matrix used in the balancing procedure. Returns: An array representing the composition matrix for a reaction \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] ) def get_coeff_vector_for_rxn ( self , rxn ) -> np . ndarray : \"\"\" Internal method for getting the net reaction coefficients vector. Args: rxn: Reaction object to get coefficients for Returns: An array representing the reaction coefficients vector \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] ) def contains_interdependent_rxns ( self , precursors : List [ Composition ]) -> bool : \"\"\" Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Args: precursors: List of precursor compositions \"\"\" precursors_set = set ( precursors ) interdependent = False rxns = set ( self . reactions ) num_rxns = len ( rxns ) if num_rxns == 1 : return False for combo in limited_powerset ( rxns , num_rxns ): size = len ( combo ) if ( any ( set ( rxn . reactants ) . issubset ( precursors_set ) for rxn in combo ) or size == 1 ): continue other_comp = { c for rxn in ( rxns - set ( combo )) for c in rxn . compositions } unique_reactants = [] unique_products = [] for rxn in combo : unique_reactants . append ( set ( rxn . reactants ) - precursors_set ) unique_products . append ( set ( rxn . products ) - precursors_set ) overlap = [ False ] * size for i in range ( size ): for j in range ( size ): if i == j : continue overlapping_phases = unique_reactants [ i ] & unique_products [ j ] if overlapping_phases and ( overlapping_phases not in other_comp ): overlap [ i ] = True if all ( overlap ): interdependent = True return interdependent @property def average_cost ( self ) -> float : \"\"\"Returns the mean cost of the pathway\"\"\" return np . dot ( self . coefficients , self . costs ) / sum ( self . coefficients ) def __repr__ ( self ): path_info = \"\" for rxn in self . reactions : path_info += f \" { rxn } (dG = { round ( rxn . energy_per_atom , 3 ) } eV/atom) \\n \" path_info += f \"Average Cost: { round ( self . average_cost , 3 ) } \" return path_info","title":"BalancedPathway"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.__init__","text":"Parameters: Name Type Description Default reactions List [ Reaction ] list of ComputedReaction objects which occur along path. required coefficients List [ float ] list of coefficients to balance each of these reactions, respectively required costs List [ float ] list of corresponding costs for each reaction. required balanced bool whether or not the reaction pathway is balanced. Defaults to False. False Source code in rxn_network/pathways/balanced.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : List [ float ], balanced : bool = False , ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. coefficients: list of coefficients to balance each of these reactions, respectively costs: list of corresponding costs for each reaction. balanced: whether or not the reaction pathway is balanced. Defaults to False. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) self . balanced = balanced","title":"__init__()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.average_cost","text":"Returns the mean cost of the pathway Source code in rxn_network/pathways/balanced.py 150 151 152 153 @property def average_cost ( self ) -> float : \"\"\"Returns the mean cost of the pathway\"\"\" return np . dot ( self . coefficients , self . costs ) / sum ( self . coefficients )","title":"average_cost()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.balance","text":"TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. Source code in rxn_network/pathways/balanced.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction. NOTE: Currently, to automatically balance and create a BalancedPathway object, you must use the PathwaySolver class. \"\"\"","title":"balance()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.comp_matrix","text":"Internal method for getting the composition matrix used in the balancing procedure. Returns: Type Description np . ndarray An array representing the composition matrix for a reaction Source code in rxn_network/pathways/balanced.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def comp_matrix ( self ) -> np . ndarray : \"\"\" Internal method for getting the composition matrix used in the balancing procedure. Returns: An array representing the composition matrix for a reaction \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] )","title":"comp_matrix()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.contains_interdependent_rxns","text":"Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Parameters: Name Type Description Default precursors List [ Composition ] List of precursor compositions required Source code in rxn_network/pathways/balanced.py 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 def contains_interdependent_rxns ( self , precursors : List [ Composition ]) -> bool : \"\"\" Whether or not the pathway contains interdependent reactions, given a list of provided precursors. Args: precursors: List of precursor compositions \"\"\" precursors_set = set ( precursors ) interdependent = False rxns = set ( self . reactions ) num_rxns = len ( rxns ) if num_rxns == 1 : return False for combo in limited_powerset ( rxns , num_rxns ): size = len ( combo ) if ( any ( set ( rxn . reactants ) . issubset ( precursors_set ) for rxn in combo ) or size == 1 ): continue other_comp = { c for rxn in ( rxns - set ( combo )) for c in rxn . compositions } unique_reactants = [] unique_products = [] for rxn in combo : unique_reactants . append ( set ( rxn . reactants ) - precursors_set ) unique_products . append ( set ( rxn . products ) - precursors_set ) overlap = [ False ] * size for i in range ( size ): for j in range ( size ): if i == j : continue overlapping_phases = unique_reactants [ i ] & unique_products [ j ] if overlapping_phases and ( overlapping_phases not in other_comp ): overlap [ i ] = True if all ( overlap ): interdependent = True return interdependent","title":"contains_interdependent_rxns()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.get_coeff_vector_for_rxn","text":"Internal method for getting the net reaction coefficients vector. Parameters: Name Type Description Default rxn Reaction object to get coefficients for required Returns: Type Description np . ndarray An array representing the reaction coefficients vector Source code in rxn_network/pathways/balanced.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 def get_coeff_vector_for_rxn ( self , rxn ) -> np . ndarray : \"\"\" Internal method for getting the net reaction coefficients vector. Args: rxn: Reaction object to get coefficients for Returns: An array representing the reaction coefficients vector \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] )","title":"get_coeff_vector_for_rxn()"},{"location":"reference/pathways/basic/","text":"Implements a class for storing (unbalanced/unconstrained) collection of reactions forming a reaction pathway. BasicPathway Bases: Pathway Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry Source code in rxn_network/pathways/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class BasicPathway ( Pathway ): \"\"\" Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry \"\"\" def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. costs: Optional list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs def __repr__ ( self ): path_info = \"\" for rxn in self . reactions : path_info += f \" { rxn } (dG = { round ( rxn . energy_per_atom , 3 ) } eV/atom) \\n \" path_info += f \"Total Cost: { round ( self . total_cost , 3 ) } \" return path_info def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return all ( other_rxn == rxn for other_rxn , rxn in zip ( other . reactions , self . reactions ) ) return False def __hash__ ( self ): return hash ( tuple ( self . reactions )) @property def reactions ( self ) -> List [ Reaction ]: \"\"\"A list of reactions contained in the reaction pathway\"\"\" return self . _reactions @property def total_cost ( self ) -> float : \"\"\"The sum of all costs associated with reactions in the pathway\"\"\" return sum ( self . costs ) @property def is_experimental ( self ) -> bool : \"\"\"Whether or not all reactions in the pathway are experimental\"\"\" return all ( e . is_experimental for e in self . entries ) __init__ ( reactions , costs = None ) Parameters: Name Type Description Default reactions List [ Reaction ] list of ComputedReaction objects which occur along path. required costs Optional [ List [ float ]] Optional list of corresponding costs for each reaction. None Source code in rxn_network/pathways/basic.py 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. costs: Optional list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs is_experimental () property Whether or not all reactions in the pathway are experimental Source code in rxn_network/pathways/basic.py 63 64 65 66 @property def is_experimental ( self ) -> bool : \"\"\"Whether or not all reactions in the pathway are experimental\"\"\" return all ( e . is_experimental for e in self . entries ) reactions () property A list of reactions contained in the reaction pathway Source code in rxn_network/pathways/basic.py 53 54 55 56 @property def reactions ( self ) -> List [ Reaction ]: \"\"\"A list of reactions contained in the reaction pathway\"\"\" return self . _reactions total_cost () property The sum of all costs associated with reactions in the pathway Source code in rxn_network/pathways/basic.py 58 59 60 61 @property def total_cost ( self ) -> float : \"\"\"The sum of all costs associated with reactions in the pathway\"\"\" return sum ( self . costs )","title":"Basic"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway","text":"Bases: Pathway Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry Source code in rxn_network/pathways/basic.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class BasicPathway ( Pathway ): \"\"\" Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry \"\"\" def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. costs: Optional list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs def __repr__ ( self ): path_info = \"\" for rxn in self . reactions : path_info += f \" { rxn } (dG = { round ( rxn . energy_per_atom , 3 ) } eV/atom) \\n \" path_info += f \"Total Cost: { round ( self . total_cost , 3 ) } \" return path_info def __eq__ ( self , other ): if isinstance ( other , self . __class__ ): return all ( other_rxn == rxn for other_rxn , rxn in zip ( other . reactions , self . reactions ) ) return False def __hash__ ( self ): return hash ( tuple ( self . reactions )) @property def reactions ( self ) -> List [ Reaction ]: \"\"\"A list of reactions contained in the reaction pathway\"\"\" return self . _reactions @property def total_cost ( self ) -> float : \"\"\"The sum of all costs associated with reactions in the pathway\"\"\" return sum ( self . costs ) @property def is_experimental ( self ) -> bool : \"\"\"Whether or not all reactions in the pathway are experimental\"\"\" return all ( e . is_experimental for e in self . entries )","title":"BasicPathway"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway.__init__","text":"Parameters: Name Type Description Default reactions List [ Reaction ] list of ComputedReaction objects which occur along path. required costs Optional [ List [ float ]] Optional list of corresponding costs for each reaction. None Source code in rxn_network/pathways/basic.py 18 19 20 21 22 23 24 25 26 27 28 29 30 def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions: list of ComputedReaction objects which occur along path. costs: Optional list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs","title":"__init__()"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway.is_experimental","text":"Whether or not all reactions in the pathway are experimental Source code in rxn_network/pathways/basic.py 63 64 65 66 @property def is_experimental ( self ) -> bool : \"\"\"Whether or not all reactions in the pathway are experimental\"\"\" return all ( e . is_experimental for e in self . entries )","title":"is_experimental()"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway.reactions","text":"A list of reactions contained in the reaction pathway Source code in rxn_network/pathways/basic.py 53 54 55 56 @property def reactions ( self ) -> List [ Reaction ]: \"\"\"A list of reactions contained in the reaction pathway\"\"\" return self . _reactions","title":"reactions()"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway.total_cost","text":"The sum of all costs associated with reactions in the pathway Source code in rxn_network/pathways/basic.py 58 59 60 61 @property def total_cost ( self ) -> float : \"\"\"The sum of all costs associated with reactions in the pathway\"\"\" return sum ( self . costs )","title":"total_cost()"},{"location":"reference/pathways/pathway_set/","text":"Implements a class for conveniently and efficiently storing sets of Pathway-based objects which share entries/reactions. PathwaySet Bases: MSONable A lightweight class for storing large sets of Pathway objects. Automatically represents a set of pathways as a (non-rectangular) 2D array of indices corresponding to reactions within a reaction set. This is useful for dumping reaction pathway data to a database. Source code in rxn_network/pathways/pathway_set.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class PathwaySet ( MSONable ): \"\"\" A lightweight class for storing large sets of Pathway objects. Automatically represents a set of pathways as a (non-rectangular) 2D array of indices corresponding to reactions within a reaction set. This is useful for dumping reaction pathway data to a database. \"\"\" def __init__ ( self , reaction_set : ReactionSet , indices : Union [ np . ndarray , List [ List [ int ]]], coefficients : Union [ np . ndarray , List [ List [ float ]]], costs : Union [ np . ndarray , List [ List [ float ]]], ): \"\"\" Args: reaction_set: The reaction set containing all reactions in the pathways. indices: A list of lists of indices corresponding to reactions in the reaction set coefficients: A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. costs: A list of costs for each pathway. \"\"\" self . reaction_set = reaction_set self . indices = indices self . coefficients = coefficients self . costs = costs @lru_cache ( 1 ) def get_paths ( self , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. \"\"\" paths = [] rxns = list ( self . reaction_set . get_rxns ()) for indices , coefficients , costs in zip ( self . indices , self . coefficients , self . costs , ): reactions = [ rxns [ i ] for i in indices ] if coefficients is not None : path = BalancedPathway ( reactions = reactions , coefficients = coefficients , costs = costs ) else : path = BasicPathway ( reactions = reactions , costs = costs ) paths . append ( path ) return paths @classmethod def from_paths ( cls , paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> \"PathwaySet\" : \"\"\" Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Args: paths: List of Pathway objects \"\"\" indices , coefficients , costs = [], [], [] reaction_set = cls . _get_reaction_set ( paths ) rxns = list ( reaction_set . get_rxns ()) for path in paths : indices . append ([ rxns . index ( r ) for r in path . reactions ]) coefficients . append ( getattr ( path , \"coefficients\" , None )) costs . append ( path . costs ) return cls ( reaction_set = reaction_set , indices = indices , coefficients = coefficients , # type: ignore costs = costs , ) @staticmethod def _get_reaction_set ( paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> ReactionSet : \"\"\" Returns a reaction set built from a list of paths. Args: paths: List of Pathway objects \"\"\" return ReactionSet . from_rxns ([ rxn for path in paths for rxn in path . reactions ]) def __iter__ ( self ): \"\"\" Iterates over the PathwaySet. \"\"\" return iter ( self . get_paths ()) def __len__ ( self ): \"\"\" Returns the number of pathways in the PathwaySet. \"\"\" return len ( self . indices ) __init__ ( reaction_set , indices , coefficients , costs ) Parameters: Name Type Description Default reaction_set ReactionSet The reaction set containing all reactions in the pathways. required indices Union [ np . ndarray , List [ List [ int ]]] A list of lists of indices corresponding to reactions in the reaction set required coefficients Union [ np . ndarray , List [ List [ float ]]] A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. required costs Union [ np . ndarray , List [ List [ float ]]] A list of costs for each pathway. required Source code in rxn_network/pathways/pathway_set.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , reaction_set : ReactionSet , indices : Union [ np . ndarray , List [ List [ int ]]], coefficients : Union [ np . ndarray , List [ List [ float ]]], costs : Union [ np . ndarray , List [ List [ float ]]], ): \"\"\" Args: reaction_set: The reaction set containing all reactions in the pathways. indices: A list of lists of indices corresponding to reactions in the reaction set coefficients: A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. costs: A list of costs for each pathway. \"\"\" self . reaction_set = reaction_set self . indices = indices self . coefficients = coefficients self . costs = costs __iter__ () Iterates over the PathwaySet. Source code in rxn_network/pathways/pathway_set.py 119 120 121 122 123 def __iter__ ( self ): \"\"\" Iterates over the PathwaySet. \"\"\" return iter ( self . get_paths ()) __len__ () Returns the number of pathways in the PathwaySet. Source code in rxn_network/pathways/pathway_set.py 125 126 127 128 129 def __len__ ( self ): \"\"\" Returns the number of pathways in the PathwaySet. \"\"\" return len ( self . indices ) from_paths ( paths ) classmethod Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default paths List [ Union [ ComputedReaction , OpenComputedReaction ]] List of Pathway objects required Source code in rxn_network/pathways/pathway_set.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def from_paths ( cls , paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> \"PathwaySet\" : \"\"\" Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Args: paths: List of Pathway objects \"\"\" indices , coefficients , costs = [], [], [] reaction_set = cls . _get_reaction_set ( paths ) rxns = list ( reaction_set . get_rxns ()) for path in paths : indices . append ([ rxns . index ( r ) for r in path . reactions ]) coefficients . append ( getattr ( path , \"coefficients\" , None )) costs . append ( path . costs ) return cls ( reaction_set = reaction_set , indices = indices , coefficients = coefficients , # type: ignore costs = costs , ) get_paths () cached Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. Source code in rxn_network/pathways/pathway_set.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @lru_cache ( 1 ) def get_paths ( self , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. \"\"\" paths = [] rxns = list ( self . reaction_set . get_rxns ()) for indices , coefficients , costs in zip ( self . indices , self . coefficients , self . costs , ): reactions = [ rxns [ i ] for i in indices ] if coefficients is not None : path = BalancedPathway ( reactions = reactions , coefficients = coefficients , costs = costs ) else : path = BasicPathway ( reactions = reactions , costs = costs ) paths . append ( path ) return paths","title":"Pathway Set"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet","text":"Bases: MSONable A lightweight class for storing large sets of Pathway objects. Automatically represents a set of pathways as a (non-rectangular) 2D array of indices corresponding to reactions within a reaction set. This is useful for dumping reaction pathway data to a database. Source code in rxn_network/pathways/pathway_set.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 class PathwaySet ( MSONable ): \"\"\" A lightweight class for storing large sets of Pathway objects. Automatically represents a set of pathways as a (non-rectangular) 2D array of indices corresponding to reactions within a reaction set. This is useful for dumping reaction pathway data to a database. \"\"\" def __init__ ( self , reaction_set : ReactionSet , indices : Union [ np . ndarray , List [ List [ int ]]], coefficients : Union [ np . ndarray , List [ List [ float ]]], costs : Union [ np . ndarray , List [ List [ float ]]], ): \"\"\" Args: reaction_set: The reaction set containing all reactions in the pathways. indices: A list of lists of indices corresponding to reactions in the reaction set coefficients: A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. costs: A list of costs for each pathway. \"\"\" self . reaction_set = reaction_set self . indices = indices self . coefficients = coefficients self . costs = costs @lru_cache ( 1 ) def get_paths ( self , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. \"\"\" paths = [] rxns = list ( self . reaction_set . get_rxns ()) for indices , coefficients , costs in zip ( self . indices , self . coefficients , self . costs , ): reactions = [ rxns [ i ] for i in indices ] if coefficients is not None : path = BalancedPathway ( reactions = reactions , coefficients = coefficients , costs = costs ) else : path = BasicPathway ( reactions = reactions , costs = costs ) paths . append ( path ) return paths @classmethod def from_paths ( cls , paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> \"PathwaySet\" : \"\"\" Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Args: paths: List of Pathway objects \"\"\" indices , coefficients , costs = [], [], [] reaction_set = cls . _get_reaction_set ( paths ) rxns = list ( reaction_set . get_rxns ()) for path in paths : indices . append ([ rxns . index ( r ) for r in path . reactions ]) coefficients . append ( getattr ( path , \"coefficients\" , None )) costs . append ( path . costs ) return cls ( reaction_set = reaction_set , indices = indices , coefficients = coefficients , # type: ignore costs = costs , ) @staticmethod def _get_reaction_set ( paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> ReactionSet : \"\"\" Returns a reaction set built from a list of paths. Args: paths: List of Pathway objects \"\"\" return ReactionSet . from_rxns ([ rxn for path in paths for rxn in path . reactions ]) def __iter__ ( self ): \"\"\" Iterates over the PathwaySet. \"\"\" return iter ( self . get_paths ()) def __len__ ( self ): \"\"\" Returns the number of pathways in the PathwaySet. \"\"\" return len ( self . indices )","title":"PathwaySet"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet.__init__","text":"Parameters: Name Type Description Default reaction_set ReactionSet The reaction set containing all reactions in the pathways. required indices Union [ np . ndarray , List [ List [ int ]]] A list of lists of indices corresponding to reactions in the reaction set required coefficients Union [ np . ndarray , List [ List [ float ]]] A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. required costs Union [ np . ndarray , List [ List [ float ]]] A list of costs for each pathway. required Source code in rxn_network/pathways/pathway_set.py 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 def __init__ ( self , reaction_set : ReactionSet , indices : Union [ np . ndarray , List [ List [ int ]]], coefficients : Union [ np . ndarray , List [ List [ float ]]], costs : Union [ np . ndarray , List [ List [ float ]]], ): \"\"\" Args: reaction_set: The reaction set containing all reactions in the pathways. indices: A list of lists of indices corresponding to reactions in the reaction set coefficients: A list of coefficients representing the multiplicities (how much of) each reaction in the pathway. costs: A list of costs for each pathway. \"\"\" self . reaction_set = reaction_set self . indices = indices self . coefficients = coefficients self . costs = costs","title":"__init__()"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet.__iter__","text":"Iterates over the PathwaySet. Source code in rxn_network/pathways/pathway_set.py 119 120 121 122 123 def __iter__ ( self ): \"\"\" Iterates over the PathwaySet. \"\"\" return iter ( self . get_paths ())","title":"__iter__()"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet.__len__","text":"Returns the number of pathways in the PathwaySet. Source code in rxn_network/pathways/pathway_set.py 125 126 127 128 129 def __len__ ( self ): \"\"\" Returns the number of pathways in the PathwaySet. \"\"\" return len ( self . indices )","title":"__len__()"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet.from_paths","text":"Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default paths List [ Union [ ComputedReaction , OpenComputedReaction ]] List of Pathway objects required Source code in rxn_network/pathways/pathway_set.py 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 @classmethod def from_paths ( cls , paths : List [ Union [ ComputedReaction , OpenComputedReaction ]], ) -> \"PathwaySet\" : \"\"\" Initiate a PathwaySet object from a list of paths. Including a list of unique entries saves some computation time. Args: paths: List of Pathway objects \"\"\" indices , coefficients , costs = [], [], [] reaction_set = cls . _get_reaction_set ( paths ) rxns = list ( reaction_set . get_rxns ()) for path in paths : indices . append ([ rxns . index ( r ) for r in path . reactions ]) coefficients . append ( getattr ( path , \"coefficients\" , None )) costs . append ( path . costs ) return cls ( reaction_set = reaction_set , indices = indices , coefficients = coefficients , # type: ignore costs = costs , )","title":"from_paths()"},{"location":"reference/pathways/pathway_set/#rxn_network.pathways.pathway_set.PathwaySet.get_paths","text":"Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. Source code in rxn_network/pathways/pathway_set.py 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @lru_cache ( 1 ) def get_paths ( self , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of BalancedPathway objects represented by the PathwaySet. Cached for efficiency. \"\"\" paths = [] rxns = list ( self . reaction_set . get_rxns ()) for indices , coefficients , costs in zip ( self . indices , self . coefficients , self . costs , ): reactions = [ rxns [ i ] for i in indices ] if coefficients is not None : path = BalancedPathway ( reactions = reactions , coefficients = coefficients , costs = costs ) else : path = BasicPathway ( reactions = reactions , costs = costs ) paths . append ( path ) return paths","title":"get_paths()"},{"location":"reference/pathways/plotting/","text":"This module contains functions for plotting experimental reaction pathway data. PathwayPlotter Bases: MSONable Helper class for plotting a reaction pathway and the corresponding energy cascade. Note This class is far from complete and is not intended yet for general use. Source code in rxn_network/pathways/plotting.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class PathwayPlotter ( MSONable ): \"\"\" Helper class for plotting a reaction pathway and the corresponding energy cascade. Note: This class is far from complete and is not intended yet for general use. \"\"\" def __init__ ( self , phase_amounts : Dict [ str , List [ float ]], temps : List [ float ], apply_smoothing : bool = True , ): \"\"\" Args: phase_amounts: Dicts with format {phase: [amounts]} temps: list of temperatures apply_smoothing: Whether to smooth the data. Default is True. \"\"\" self . _phase_amounts = phase_amounts self . _temps = temps self . _apply_smoothing = apply_smoothing self . _formulas = list ( phase_amounts . keys ()) self . _df = self . _get_phase_df () self . _num_atoms_df = self . _get_num_atoms_df () def plot_pathway ( self ): \"\"\" Returns a plot of the pathway by calling DataFrame.plot(). \"\"\" return self . df . plot () def plot_energy_cascade ( self , entries ): \"\"\" Returns a plot of the energy cascade given a list of entries. Args: entries: List of entries or GibbsEntrySet. \"\"\" energies = self . _get_energies ( entries ) energies_df = pandas . DataFrame ( energies ) . T ground_state_energies = energies_df . pop ( \"ground_state\" ) gibbs_arr = ( self . df . values * energies_df . values / self . num_atoms_df . sum ( axis = 1 ) . values . reshape ( - 1 , 1 ) ) g_df = pandas . DataFrame ( gibbs_arr , columns = self . df . columns , index = self . df . index ) total_g = g_df . sum ( axis = 1 ) total_g = total_g - ground_state_energies plot = total_g . plot ( backend = \"matplotlib\" , style = \"o\" ) plt . xlabel ( \"Temperature (K)\" , { \"size\" : 11 }) plt . ylabel ( r \"Gibbs Free Energy, $G$ (eV/atom)\" , { \"size\" : 11 }) return plot def _get_energies ( self , entries ): \"\"\" Interal method: returns a list of energies for each phase \"\"\" all_energies = {} formulas = self . df . columns . to_list () compositions = self . compositions for temp in tqdm ( self . df . index ): all_energies [ temp ] = {} gibbs_entries = GibbsEntrySet . from_computed_entries ( entries , temp ) pd = PhaseDiagram ( gibbs_entries ) ground_state_energy = pd . get_hull_energy ( compositions [ temp ]) all_energies [ temp ][ \"ground_state\" ] = ground_state_energy for f in formulas : comp = Composition ( f ) . reduced_composition energy = ( pd . get_form_energy_per_atom ( gibbs_entries . get_min_entry_by_formula ( comp . formula ) ) * comp . num_atoms ) all_energies [ temp ][ f ] = energy return all_energies def _get_phase_df ( self ): \"\"\" Returns a dataframe of phase amounts \"\"\" phase_df = pandas . DataFrame ( self . _phase_amounts , index = self . _temps ) if self . _apply_smoothing : phase_df = phase_df . apply ( median_filter , axis = 0 , size = 3 ) return phase_df def _get_num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" el_dict = { str ( e ): [] for e in self . elems } for idx , f in enumerate ( self . df . columns ): comp = Composition ( f ) col = self . df . iloc [:, idx ] for el in el_dict . keys (): el_dict [ el ] . append (( col * comp . get_el_amt_dict ()[ el ]) . fillna ( 0 )) for el in el_dict : el_dict [ el ] = sum ( el_dict [ el ]) el_df = pandas . DataFrame ( el_dict ) return el_df @property def elems ( self ): \"\"\" Returns a list of elements in the pathway \"\"\" return list ({ e for f in self . formulas for e in Composition ( f ) . elements }) @property def num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" return self . _num_atoms_df @property def formulas ( self ): \"\"\" Returns a list of formulas in the pathway \"\"\" return self . _formulas @property def df ( self ): \"\"\" Returns a dataframe of the pathway \"\"\" return self . _df @property def compositions ( self ): \"\"\" Returns the composition of the pathway \"\"\" comps = [ Composition ( i ) . fractional_composition for i in self . num_atoms_df . to_dict ( # pylint: disable=not-an-iterable \"records\" ) ] return pandas . Series ( comps , index = self . num_atoms_df . index ) __init__ ( phase_amounts , temps , apply_smoothing = True ) Parameters: Name Type Description Default phase_amounts Dict [ str , List [ float ]] Dicts with format {phase: [amounts]} required temps List [ float ] list of temperatures required apply_smoothing bool Whether to smooth the data. Default is True. True Source code in rxn_network/pathways/plotting.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , phase_amounts : Dict [ str , List [ float ]], temps : List [ float ], apply_smoothing : bool = True , ): \"\"\" Args: phase_amounts: Dicts with format {phase: [amounts]} temps: list of temperatures apply_smoothing: Whether to smooth the data. Default is True. \"\"\" self . _phase_amounts = phase_amounts self . _temps = temps self . _apply_smoothing = apply_smoothing self . _formulas = list ( phase_amounts . keys ()) self . _df = self . _get_phase_df () self . _num_atoms_df = self . _get_num_atoms_df () compositions () property Returns the composition of the pathway Source code in rxn_network/pathways/plotting.py 170 171 172 173 174 175 176 177 178 179 180 181 @property def compositions ( self ): \"\"\" Returns the composition of the pathway \"\"\" comps = [ Composition ( i ) . fractional_composition for i in self . num_atoms_df . to_dict ( # pylint: disable=not-an-iterable \"records\" ) ] return pandas . Series ( comps , index = self . num_atoms_df . index ) df () property Returns a dataframe of the pathway Source code in rxn_network/pathways/plotting.py 163 164 165 166 167 168 @property def df ( self ): \"\"\" Returns a dataframe of the pathway \"\"\" return self . _df elems () property Returns a list of elements in the pathway Source code in rxn_network/pathways/plotting.py 142 143 144 145 146 147 @property def elems ( self ): \"\"\" Returns a list of elements in the pathway \"\"\" return list ({ e for f in self . formulas for e in Composition ( f ) . elements }) formulas () property Returns a list of formulas in the pathway Source code in rxn_network/pathways/plotting.py 156 157 158 159 160 161 @property def formulas ( self ): \"\"\" Returns a list of formulas in the pathway \"\"\" return self . _formulas num_atoms_df () property Returns a dataframe of the number of atoms in each phase Source code in rxn_network/pathways/plotting.py 149 150 151 152 153 154 @property def num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" return self . _num_atoms_df plot_energy_cascade ( entries ) Returns a plot of the energy cascade given a list of entries. Parameters: Name Type Description Default entries List of entries or GibbsEntrySet. required Source code in rxn_network/pathways/plotting.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def plot_energy_cascade ( self , entries ): \"\"\" Returns a plot of the energy cascade given a list of entries. Args: entries: List of entries or GibbsEntrySet. \"\"\" energies = self . _get_energies ( entries ) energies_df = pandas . DataFrame ( energies ) . T ground_state_energies = energies_df . pop ( \"ground_state\" ) gibbs_arr = ( self . df . values * energies_df . values / self . num_atoms_df . sum ( axis = 1 ) . values . reshape ( - 1 , 1 ) ) g_df = pandas . DataFrame ( gibbs_arr , columns = self . df . columns , index = self . df . index ) total_g = g_df . sum ( axis = 1 ) total_g = total_g - ground_state_energies plot = total_g . plot ( backend = \"matplotlib\" , style = \"o\" ) plt . xlabel ( \"Temperature (K)\" , { \"size\" : 11 }) plt . ylabel ( r \"Gibbs Free Energy, $G$ (eV/atom)\" , { \"size\" : 11 }) return plot plot_pathway () Returns a plot of the pathway by calling DataFrame.plot(). Source code in rxn_network/pathways/plotting.py 47 48 49 50 51 def plot_pathway ( self ): \"\"\" Returns a plot of the pathway by calling DataFrame.plot(). \"\"\" return self . df . plot ()","title":"Plotting"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter","text":"Bases: MSONable Helper class for plotting a reaction pathway and the corresponding energy cascade. Note This class is far from complete and is not intended yet for general use. Source code in rxn_network/pathways/plotting.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 class PathwayPlotter ( MSONable ): \"\"\" Helper class for plotting a reaction pathway and the corresponding energy cascade. Note: This class is far from complete and is not intended yet for general use. \"\"\" def __init__ ( self , phase_amounts : Dict [ str , List [ float ]], temps : List [ float ], apply_smoothing : bool = True , ): \"\"\" Args: phase_amounts: Dicts with format {phase: [amounts]} temps: list of temperatures apply_smoothing: Whether to smooth the data. Default is True. \"\"\" self . _phase_amounts = phase_amounts self . _temps = temps self . _apply_smoothing = apply_smoothing self . _formulas = list ( phase_amounts . keys ()) self . _df = self . _get_phase_df () self . _num_atoms_df = self . _get_num_atoms_df () def plot_pathway ( self ): \"\"\" Returns a plot of the pathway by calling DataFrame.plot(). \"\"\" return self . df . plot () def plot_energy_cascade ( self , entries ): \"\"\" Returns a plot of the energy cascade given a list of entries. Args: entries: List of entries or GibbsEntrySet. \"\"\" energies = self . _get_energies ( entries ) energies_df = pandas . DataFrame ( energies ) . T ground_state_energies = energies_df . pop ( \"ground_state\" ) gibbs_arr = ( self . df . values * energies_df . values / self . num_atoms_df . sum ( axis = 1 ) . values . reshape ( - 1 , 1 ) ) g_df = pandas . DataFrame ( gibbs_arr , columns = self . df . columns , index = self . df . index ) total_g = g_df . sum ( axis = 1 ) total_g = total_g - ground_state_energies plot = total_g . plot ( backend = \"matplotlib\" , style = \"o\" ) plt . xlabel ( \"Temperature (K)\" , { \"size\" : 11 }) plt . ylabel ( r \"Gibbs Free Energy, $G$ (eV/atom)\" , { \"size\" : 11 }) return plot def _get_energies ( self , entries ): \"\"\" Interal method: returns a list of energies for each phase \"\"\" all_energies = {} formulas = self . df . columns . to_list () compositions = self . compositions for temp in tqdm ( self . df . index ): all_energies [ temp ] = {} gibbs_entries = GibbsEntrySet . from_computed_entries ( entries , temp ) pd = PhaseDiagram ( gibbs_entries ) ground_state_energy = pd . get_hull_energy ( compositions [ temp ]) all_energies [ temp ][ \"ground_state\" ] = ground_state_energy for f in formulas : comp = Composition ( f ) . reduced_composition energy = ( pd . get_form_energy_per_atom ( gibbs_entries . get_min_entry_by_formula ( comp . formula ) ) * comp . num_atoms ) all_energies [ temp ][ f ] = energy return all_energies def _get_phase_df ( self ): \"\"\" Returns a dataframe of phase amounts \"\"\" phase_df = pandas . DataFrame ( self . _phase_amounts , index = self . _temps ) if self . _apply_smoothing : phase_df = phase_df . apply ( median_filter , axis = 0 , size = 3 ) return phase_df def _get_num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" el_dict = { str ( e ): [] for e in self . elems } for idx , f in enumerate ( self . df . columns ): comp = Composition ( f ) col = self . df . iloc [:, idx ] for el in el_dict . keys (): el_dict [ el ] . append (( col * comp . get_el_amt_dict ()[ el ]) . fillna ( 0 )) for el in el_dict : el_dict [ el ] = sum ( el_dict [ el ]) el_df = pandas . DataFrame ( el_dict ) return el_df @property def elems ( self ): \"\"\" Returns a list of elements in the pathway \"\"\" return list ({ e for f in self . formulas for e in Composition ( f ) . elements }) @property def num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" return self . _num_atoms_df @property def formulas ( self ): \"\"\" Returns a list of formulas in the pathway \"\"\" return self . _formulas @property def df ( self ): \"\"\" Returns a dataframe of the pathway \"\"\" return self . _df @property def compositions ( self ): \"\"\" Returns the composition of the pathway \"\"\" comps = [ Composition ( i ) . fractional_composition for i in self . num_atoms_df . to_dict ( # pylint: disable=not-an-iterable \"records\" ) ] return pandas . Series ( comps , index = self . num_atoms_df . index )","title":"PathwayPlotter"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.__init__","text":"Parameters: Name Type Description Default phase_amounts Dict [ str , List [ float ]] Dicts with format {phase: [amounts]} required temps List [ float ] list of temperatures required apply_smoothing bool Whether to smooth the data. Default is True. True Source code in rxn_network/pathways/plotting.py 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 def __init__ ( self , phase_amounts : Dict [ str , List [ float ]], temps : List [ float ], apply_smoothing : bool = True , ): \"\"\" Args: phase_amounts: Dicts with format {phase: [amounts]} temps: list of temperatures apply_smoothing: Whether to smooth the data. Default is True. \"\"\" self . _phase_amounts = phase_amounts self . _temps = temps self . _apply_smoothing = apply_smoothing self . _formulas = list ( phase_amounts . keys ()) self . _df = self . _get_phase_df () self . _num_atoms_df = self . _get_num_atoms_df ()","title":"__init__()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.compositions","text":"Returns the composition of the pathway Source code in rxn_network/pathways/plotting.py 170 171 172 173 174 175 176 177 178 179 180 181 @property def compositions ( self ): \"\"\" Returns the composition of the pathway \"\"\" comps = [ Composition ( i ) . fractional_composition for i in self . num_atoms_df . to_dict ( # pylint: disable=not-an-iterable \"records\" ) ] return pandas . Series ( comps , index = self . num_atoms_df . index )","title":"compositions()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.df","text":"Returns a dataframe of the pathway Source code in rxn_network/pathways/plotting.py 163 164 165 166 167 168 @property def df ( self ): \"\"\" Returns a dataframe of the pathway \"\"\" return self . _df","title":"df()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.elems","text":"Returns a list of elements in the pathway Source code in rxn_network/pathways/plotting.py 142 143 144 145 146 147 @property def elems ( self ): \"\"\" Returns a list of elements in the pathway \"\"\" return list ({ e for f in self . formulas for e in Composition ( f ) . elements })","title":"elems()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.formulas","text":"Returns a list of formulas in the pathway Source code in rxn_network/pathways/plotting.py 156 157 158 159 160 161 @property def formulas ( self ): \"\"\" Returns a list of formulas in the pathway \"\"\" return self . _formulas","title":"formulas()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.num_atoms_df","text":"Returns a dataframe of the number of atoms in each phase Source code in rxn_network/pathways/plotting.py 149 150 151 152 153 154 @property def num_atoms_df ( self ): \"\"\" Returns a dataframe of the number of atoms in each phase \"\"\" return self . _num_atoms_df","title":"num_atoms_df()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.plot_energy_cascade","text":"Returns a plot of the energy cascade given a list of entries. Parameters: Name Type Description Default entries List of entries or GibbsEntrySet. required Source code in rxn_network/pathways/plotting.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def plot_energy_cascade ( self , entries ): \"\"\" Returns a plot of the energy cascade given a list of entries. Args: entries: List of entries or GibbsEntrySet. \"\"\" energies = self . _get_energies ( entries ) energies_df = pandas . DataFrame ( energies ) . T ground_state_energies = energies_df . pop ( \"ground_state\" ) gibbs_arr = ( self . df . values * energies_df . values / self . num_atoms_df . sum ( axis = 1 ) . values . reshape ( - 1 , 1 ) ) g_df = pandas . DataFrame ( gibbs_arr , columns = self . df . columns , index = self . df . index ) total_g = g_df . sum ( axis = 1 ) total_g = total_g - ground_state_energies plot = total_g . plot ( backend = \"matplotlib\" , style = \"o\" ) plt . xlabel ( \"Temperature (K)\" , { \"size\" : 11 }) plt . ylabel ( r \"Gibbs Free Energy, $G$ (eV/atom)\" , { \"size\" : 11 }) return plot","title":"plot_energy_cascade()"},{"location":"reference/pathways/plotting/#rxn_network.pathways.plotting.PathwayPlotter.plot_pathway","text":"Returns a plot of the pathway by calling DataFrame.plot(). Source code in rxn_network/pathways/plotting.py 47 48 49 50 51 def plot_pathway ( self ): \"\"\" Returns a plot of the pathway by calling DataFrame.plot(). \"\"\" return self . df . plot ()","title":"plot_pathway()"},{"location":"reference/pathways/solver/","text":"Implements a reaction pathway solver class which efficiently solves mass balance equations using matrix operations. PathwaySolver Bases: Solver Solver that implements an efficient method (using numba) for finding balanced reaction pathways from a list of graph-derived reaction pathways (i.e. a list of lists of reactions) Source code in rxn_network/pathways/solver.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class PathwaySolver ( Solver ): \"\"\" Solver that implements an efficient method (using numba) for finding balanced reaction pathways from a list of graph-derived reaction pathways (i.e. a list of lists of reactions) \"\"\" def __init__ ( self , pathways : PathwaySet , entries : GibbsEntrySet , cost_function : CostFunction , open_elem : str = None , chempot : float = None , chunk_size = 100000 , batch_size = None , ): \"\"\" Args: pathways: List of reaction pathways derived from the network. entries: GibbsEntrySet containing all entries in the network. cost_function: CostFunction object to use for the solver. open_elem: Element to use for pathways with an open element. chempot: Chemical potential to use for pathways with an open element. \"\"\" super () . __init__ ( pathways = deepcopy ( pathways )) self . _entries = entries self . cost_function = cost_function self . open_elem = Element ( open_elem ) if open_elem else None self . chempot = chempot self . chunk_size = chunk_size self . batch_size = batch_size def solve ( self , net_rxn : Union [ ComputedReaction , OpenComputedReaction ], max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , use_basic_enumerator : bool = True , use_minimize_enumerator : bool = False , filter_interdependent : bool = True , ) -> PathwaySet : \"\"\" Args: net_rxn: The reaction representing the total reaction from precursors to final targets. max_num_combos: The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. find_intermediate_rxns: Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. intermediate_rxn_energy_cutoff: An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. use_basic_enumerator: Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. use_minimize_enumerator: Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. filter_interdependent: Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. Returns: A list of BalancedPathway objects. \"\"\" if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) initialize_ray () entries_copy = deepcopy ( self . entries ) entries = entries_copy . entries_list num_entries = len ( entries ) reactions = deepcopy ( self . reactions ) costs = deepcopy ( self . costs ) precursors = deepcopy ( net_rxn . reactant_entries ) targets = deepcopy ( net_rxn . product_entries ) self . logger . info ( f \"Net reaction: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( targets , intermediate_rxn_energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns . get_rxns () ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = net_rxn . get_entry_idx_vector ( num_entries ) if net_rxn in reactions : reactions . remove ( net_rxn ) reaction_set = ray . put ( ReactionSet . from_rxns ( reactions )) entries = ray . put ( entries ) costs = ray . put ( costs ) num_entries = ray . put ( num_entries ) net_rxn_vector = ray . put ( net_rxn_vector ) open_elem = ray . put ( self . open_elem ) chempot = ray . put ( self . chempot ) num_rxns = len ( reactions ) batch_size = self . batch_size or ray . cluster_resources ()[ \"CPU\" ] - 1 num_combos = sum ( comb ( num_rxns , k ) for k in range ( 1 , max_num_combos + 1 )) num_batches = int (( num_combos // self . chunk_size + 1 ) // batch_size + 1 ) paths = [] paths_refs = [] batch_count = 1 for n in range ( 1 , max_num_combos + 1 ): for group in grouper ( combinations ( range ( num_rxns ), n ), self . chunk_size ): paths_refs . append ( _get_balanced_paths_ray . remote ( group , reaction_set , costs , entries , num_entries , net_rxn_vector , open_elem , chempot , ) ) if len ( paths_refs ) >= batch_size : for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = ( f \" { self . __class__ . __name__ } (Batch\" f \" { batch_count } / { num_batches } )\" ), ): paths . extend ( paths_ref ) batch_count += 1 paths_refs = [] for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = f \" { self . __class__ . __name__ } (Batch { batch_count } / { num_batches } )\" , ): paths . extend ( paths_ref ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return PathwaySet . from_paths ( filtered_paths ) def _find_intermediate_rxns ( self , targets , energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ): \"\"\" Method for finding intermediate reactions using enumerators and specified settings. \"\"\" intermediates = { e for rxn in self . reactions for e in rxn . entries } intermediates = GibbsEntrySet ( list ( intermediates ) + targets , ) target_formulas = [ e . composition . reduced_formula for e in targets ] ref_elems = { e for e in self . entries if e . is_element } intermediates = intermediates | ref_elems rxn_set = ReactionSet ( intermediates . entries_list , [], [], open_elem = self . open_elem , chempot = self . chempot , all_data = [], ) if use_basic_enumerator : be = BasicEnumerator ( targets = target_formulas , calculate_e_above_hulls = False ) rxn_set = rxn_set . add_rxn_set ( be . enumerate ( intermediates )) if self . open_elem : boe = BasicOpenEnumerator ( open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ], targets = target_formulas , calculate_e_above_hulls = False , ) rxn_set = rxn_set . add_rxn_set ( boe . enumerate ( intermediates )) if use_minimize_enumerator : mge = MinimizeGibbsEnumerator ( targets = target_formulas , calculate_e_above_hulls = False ) rxn_set = rxn_set . add_rxn_set ( mge . enumerate ( intermediates )) if self . open_elem : mgpe = MinimizeGrandPotentialEnumerator ( open_elem = self . open_elem , mu = self . chempot , targets = target_formulas , ) rxn_set . add_rxn_set ( mgpe . enumerate ( intermediates )) rxns = list ( filter ( lambda x : x . energy_per_atom < energy_cutoff , rxn_set )) rxns = [ r for r in rxns if all ( e in intermediates for e in r . entries )] num_rxns = len ( rxns ) rxns = ReactionSet . from_rxns ( rxns , filter_duplicates = True ) self . logger . info ( f \"Found { num_rxns } intermediate reactions! \\n \" ) return rxns @property def entries ( self ) -> GibbsEntrySet : \"\"\"Entry set used in solver\"\"\" return self . _entries __init__ ( pathways , entries , cost_function , open_elem = None , chempot = None , chunk_size = 100000 , batch_size = None ) Parameters: Name Type Description Default pathways PathwaySet List of reaction pathways derived from the network. required entries GibbsEntrySet GibbsEntrySet containing all entries in the network. required cost_function CostFunction CostFunction object to use for the solver. required open_elem str Element to use for pathways with an open element. None chempot float Chemical potential to use for pathways with an open element. None Source code in rxn_network/pathways/solver.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , pathways : PathwaySet , entries : GibbsEntrySet , cost_function : CostFunction , open_elem : str = None , chempot : float = None , chunk_size = 100000 , batch_size = None , ): \"\"\" Args: pathways: List of reaction pathways derived from the network. entries: GibbsEntrySet containing all entries in the network. cost_function: CostFunction object to use for the solver. open_elem: Element to use for pathways with an open element. chempot: Chemical potential to use for pathways with an open element. \"\"\" super () . __init__ ( pathways = deepcopy ( pathways )) self . _entries = entries self . cost_function = cost_function self . open_elem = Element ( open_elem ) if open_elem else None self . chempot = chempot self . chunk_size = chunk_size self . batch_size = batch_size entries () property Entry set used in solver Source code in rxn_network/pathways/solver.py 277 278 279 280 @property def entries ( self ) -> GibbsEntrySet : \"\"\"Entry set used in solver\"\"\" return self . _entries solve ( net_rxn , max_num_combos = 4 , find_intermediate_rxns = True , intermediate_rxn_energy_cutoff = 0.0 , use_basic_enumerator = True , use_minimize_enumerator = False , filter_interdependent = True ) Parameters: Name Type Description Default net_rxn Union [ ComputedReaction , OpenComputedReaction ] The reaction representing the total reaction from precursors to final targets. required max_num_combos int The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. 4 find_intermediate_rxns bool Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. True intermediate_rxn_energy_cutoff float An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. 0.0 use_basic_enumerator bool Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. True use_minimize_enumerator bool Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. False filter_interdependent bool Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. True Returns: Type Description PathwaySet A list of BalancedPathway objects. Source code in rxn_network/pathways/solver.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def solve ( self , net_rxn : Union [ ComputedReaction , OpenComputedReaction ], max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , use_basic_enumerator : bool = True , use_minimize_enumerator : bool = False , filter_interdependent : bool = True , ) -> PathwaySet : \"\"\" Args: net_rxn: The reaction representing the total reaction from precursors to final targets. max_num_combos: The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. find_intermediate_rxns: Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. intermediate_rxn_energy_cutoff: An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. use_basic_enumerator: Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. use_minimize_enumerator: Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. filter_interdependent: Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. Returns: A list of BalancedPathway objects. \"\"\" if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) initialize_ray () entries_copy = deepcopy ( self . entries ) entries = entries_copy . entries_list num_entries = len ( entries ) reactions = deepcopy ( self . reactions ) costs = deepcopy ( self . costs ) precursors = deepcopy ( net_rxn . reactant_entries ) targets = deepcopy ( net_rxn . product_entries ) self . logger . info ( f \"Net reaction: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( targets , intermediate_rxn_energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns . get_rxns () ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = net_rxn . get_entry_idx_vector ( num_entries ) if net_rxn in reactions : reactions . remove ( net_rxn ) reaction_set = ray . put ( ReactionSet . from_rxns ( reactions )) entries = ray . put ( entries ) costs = ray . put ( costs ) num_entries = ray . put ( num_entries ) net_rxn_vector = ray . put ( net_rxn_vector ) open_elem = ray . put ( self . open_elem ) chempot = ray . put ( self . chempot ) num_rxns = len ( reactions ) batch_size = self . batch_size or ray . cluster_resources ()[ \"CPU\" ] - 1 num_combos = sum ( comb ( num_rxns , k ) for k in range ( 1 , max_num_combos + 1 )) num_batches = int (( num_combos // self . chunk_size + 1 ) // batch_size + 1 ) paths = [] paths_refs = [] batch_count = 1 for n in range ( 1 , max_num_combos + 1 ): for group in grouper ( combinations ( range ( num_rxns ), n ), self . chunk_size ): paths_refs . append ( _get_balanced_paths_ray . remote ( group , reaction_set , costs , entries , num_entries , net_rxn_vector , open_elem , chempot , ) ) if len ( paths_refs ) >= batch_size : for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = ( f \" { self . __class__ . __name__ } (Batch\" f \" { batch_count } / { num_batches } )\" ), ): paths . extend ( paths_ref ) batch_count += 1 paths_refs = [] for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = f \" { self . __class__ . __name__ } (Batch { batch_count } / { num_batches } )\" , ): paths . extend ( paths_ref ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return PathwaySet . from_paths ( filtered_paths )","title":"Solver"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver","text":"Bases: Solver Solver that implements an efficient method (using numba) for finding balanced reaction pathways from a list of graph-derived reaction pathways (i.e. a list of lists of reactions) Source code in rxn_network/pathways/solver.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 class PathwaySolver ( Solver ): \"\"\" Solver that implements an efficient method (using numba) for finding balanced reaction pathways from a list of graph-derived reaction pathways (i.e. a list of lists of reactions) \"\"\" def __init__ ( self , pathways : PathwaySet , entries : GibbsEntrySet , cost_function : CostFunction , open_elem : str = None , chempot : float = None , chunk_size = 100000 , batch_size = None , ): \"\"\" Args: pathways: List of reaction pathways derived from the network. entries: GibbsEntrySet containing all entries in the network. cost_function: CostFunction object to use for the solver. open_elem: Element to use for pathways with an open element. chempot: Chemical potential to use for pathways with an open element. \"\"\" super () . __init__ ( pathways = deepcopy ( pathways )) self . _entries = entries self . cost_function = cost_function self . open_elem = Element ( open_elem ) if open_elem else None self . chempot = chempot self . chunk_size = chunk_size self . batch_size = batch_size def solve ( self , net_rxn : Union [ ComputedReaction , OpenComputedReaction ], max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , use_basic_enumerator : bool = True , use_minimize_enumerator : bool = False , filter_interdependent : bool = True , ) -> PathwaySet : \"\"\" Args: net_rxn: The reaction representing the total reaction from precursors to final targets. max_num_combos: The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. find_intermediate_rxns: Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. intermediate_rxn_energy_cutoff: An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. use_basic_enumerator: Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. use_minimize_enumerator: Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. filter_interdependent: Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. Returns: A list of BalancedPathway objects. \"\"\" if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) initialize_ray () entries_copy = deepcopy ( self . entries ) entries = entries_copy . entries_list num_entries = len ( entries ) reactions = deepcopy ( self . reactions ) costs = deepcopy ( self . costs ) precursors = deepcopy ( net_rxn . reactant_entries ) targets = deepcopy ( net_rxn . product_entries ) self . logger . info ( f \"Net reaction: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( targets , intermediate_rxn_energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns . get_rxns () ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = net_rxn . get_entry_idx_vector ( num_entries ) if net_rxn in reactions : reactions . remove ( net_rxn ) reaction_set = ray . put ( ReactionSet . from_rxns ( reactions )) entries = ray . put ( entries ) costs = ray . put ( costs ) num_entries = ray . put ( num_entries ) net_rxn_vector = ray . put ( net_rxn_vector ) open_elem = ray . put ( self . open_elem ) chempot = ray . put ( self . chempot ) num_rxns = len ( reactions ) batch_size = self . batch_size or ray . cluster_resources ()[ \"CPU\" ] - 1 num_combos = sum ( comb ( num_rxns , k ) for k in range ( 1 , max_num_combos + 1 )) num_batches = int (( num_combos // self . chunk_size + 1 ) // batch_size + 1 ) paths = [] paths_refs = [] batch_count = 1 for n in range ( 1 , max_num_combos + 1 ): for group in grouper ( combinations ( range ( num_rxns ), n ), self . chunk_size ): paths_refs . append ( _get_balanced_paths_ray . remote ( group , reaction_set , costs , entries , num_entries , net_rxn_vector , open_elem , chempot , ) ) if len ( paths_refs ) >= batch_size : for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = ( f \" { self . __class__ . __name__ } (Batch\" f \" { batch_count } / { num_batches } )\" ), ): paths . extend ( paths_ref ) batch_count += 1 paths_refs = [] for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = f \" { self . __class__ . __name__ } (Batch { batch_count } / { num_batches } )\" , ): paths . extend ( paths_ref ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return PathwaySet . from_paths ( filtered_paths ) def _find_intermediate_rxns ( self , targets , energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ): \"\"\" Method for finding intermediate reactions using enumerators and specified settings. \"\"\" intermediates = { e for rxn in self . reactions for e in rxn . entries } intermediates = GibbsEntrySet ( list ( intermediates ) + targets , ) target_formulas = [ e . composition . reduced_formula for e in targets ] ref_elems = { e for e in self . entries if e . is_element } intermediates = intermediates | ref_elems rxn_set = ReactionSet ( intermediates . entries_list , [], [], open_elem = self . open_elem , chempot = self . chempot , all_data = [], ) if use_basic_enumerator : be = BasicEnumerator ( targets = target_formulas , calculate_e_above_hulls = False ) rxn_set = rxn_set . add_rxn_set ( be . enumerate ( intermediates )) if self . open_elem : boe = BasicOpenEnumerator ( open_phases = [ Composition ( str ( self . open_elem )) . reduced_formula ], targets = target_formulas , calculate_e_above_hulls = False , ) rxn_set = rxn_set . add_rxn_set ( boe . enumerate ( intermediates )) if use_minimize_enumerator : mge = MinimizeGibbsEnumerator ( targets = target_formulas , calculate_e_above_hulls = False ) rxn_set = rxn_set . add_rxn_set ( mge . enumerate ( intermediates )) if self . open_elem : mgpe = MinimizeGrandPotentialEnumerator ( open_elem = self . open_elem , mu = self . chempot , targets = target_formulas , ) rxn_set . add_rxn_set ( mgpe . enumerate ( intermediates )) rxns = list ( filter ( lambda x : x . energy_per_atom < energy_cutoff , rxn_set )) rxns = [ r for r in rxns if all ( e in intermediates for e in r . entries )] num_rxns = len ( rxns ) rxns = ReactionSet . from_rxns ( rxns , filter_duplicates = True ) self . logger . info ( f \"Found { num_rxns } intermediate reactions! \\n \" ) return rxns @property def entries ( self ) -> GibbsEntrySet : \"\"\"Entry set used in solver\"\"\" return self . _entries","title":"PathwaySolver"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver.__init__","text":"Parameters: Name Type Description Default pathways PathwaySet List of reaction pathways derived from the network. required entries GibbsEntrySet GibbsEntrySet containing all entries in the network. required cost_function CostFunction CostFunction object to use for the solver. required open_elem str Element to use for pathways with an open element. None chempot float Chemical potential to use for pathways with an open element. None Source code in rxn_network/pathways/solver.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __init__ ( self , pathways : PathwaySet , entries : GibbsEntrySet , cost_function : CostFunction , open_elem : str = None , chempot : float = None , chunk_size = 100000 , batch_size = None , ): \"\"\" Args: pathways: List of reaction pathways derived from the network. entries: GibbsEntrySet containing all entries in the network. cost_function: CostFunction object to use for the solver. open_elem: Element to use for pathways with an open element. chempot: Chemical potential to use for pathways with an open element. \"\"\" super () . __init__ ( pathways = deepcopy ( pathways )) self . _entries = entries self . cost_function = cost_function self . open_elem = Element ( open_elem ) if open_elem else None self . chempot = chempot self . chunk_size = chunk_size self . batch_size = batch_size","title":"__init__()"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver.entries","text":"Entry set used in solver Source code in rxn_network/pathways/solver.py 277 278 279 280 @property def entries ( self ) -> GibbsEntrySet : \"\"\"Entry set used in solver\"\"\" return self . _entries","title":"entries()"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver.solve","text":"Parameters: Name Type Description Default net_rxn Union [ ComputedReaction , OpenComputedReaction ] The reaction representing the total reaction from precursors to final targets. required max_num_combos int The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. 4 find_intermediate_rxns bool Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. True intermediate_rxn_energy_cutoff float An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. 0.0 use_basic_enumerator bool Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. True use_minimize_enumerator bool Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. False filter_interdependent bool Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. True Returns: Type Description PathwaySet A list of BalancedPathway objects. Source code in rxn_network/pathways/solver.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 def solve ( self , net_rxn : Union [ ComputedReaction , OpenComputedReaction ], max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , use_basic_enumerator : bool = True , use_minimize_enumerator : bool = False , filter_interdependent : bool = True , ) -> PathwaySet : \"\"\" Args: net_rxn: The reaction representing the total reaction from precursors to final targets. max_num_combos: The maximum allowable size of the balanced reaction pathway. At values <=5, the solver will start to take a significant amount of time to run. find_intermediate_rxns: Whether to find intermediate reactions; crucial for finding pathways where intermediates react together, as these reactions may not occur in the graph-derived pathways. Defaults to True. intermediate_rxn_energy_cutoff: An energy cutoff by which to filter down intermediate reactions. This can be useful when there are a large number of possible intermediates. < 0 means allow only exergonic reactions. use_basic_enumerator: Whether to use the BasicEnumerator to find intermediate reactions. Defaults to True. use_minimize_enumerator: Whether to use the MinimizeGibbsEnumerator to find intermediate reactions. Defaults to False. filter_interdependent: Whether or not to filter out pathways where reaction steps are interdependent. Defaults to True. Returns: A list of BalancedPathway objects. \"\"\" if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) initialize_ray () entries_copy = deepcopy ( self . entries ) entries = entries_copy . entries_list num_entries = len ( entries ) reactions = deepcopy ( self . reactions ) costs = deepcopy ( self . costs ) precursors = deepcopy ( net_rxn . reactant_entries ) targets = deepcopy ( net_rxn . product_entries ) self . logger . info ( f \"Net reaction: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( targets , intermediate_rxn_energy_cutoff , use_basic_enumerator , use_minimize_enumerator , ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns . get_rxns () ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = net_rxn . get_entry_idx_vector ( num_entries ) if net_rxn in reactions : reactions . remove ( net_rxn ) reaction_set = ray . put ( ReactionSet . from_rxns ( reactions )) entries = ray . put ( entries ) costs = ray . put ( costs ) num_entries = ray . put ( num_entries ) net_rxn_vector = ray . put ( net_rxn_vector ) open_elem = ray . put ( self . open_elem ) chempot = ray . put ( self . chempot ) num_rxns = len ( reactions ) batch_size = self . batch_size or ray . cluster_resources ()[ \"CPU\" ] - 1 num_combos = sum ( comb ( num_rxns , k ) for k in range ( 1 , max_num_combos + 1 )) num_batches = int (( num_combos // self . chunk_size + 1 ) // batch_size + 1 ) paths = [] paths_refs = [] batch_count = 1 for n in range ( 1 , max_num_combos + 1 ): for group in grouper ( combinations ( range ( num_rxns ), n ), self . chunk_size ): paths_refs . append ( _get_balanced_paths_ray . remote ( group , reaction_set , costs , entries , num_entries , net_rxn_vector , open_elem , chempot , ) ) if len ( paths_refs ) >= batch_size : for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = ( f \" { self . __class__ . __name__ } (Batch\" f \" { batch_count } / { num_batches } )\" ), ): paths . extend ( paths_ref ) batch_count += 1 paths_refs = [] for paths_ref in tqdm ( to_iterator ( paths_refs ), total = len ( paths_refs ), desc = f \" { self . __class__ . __name__ } (Batch { batch_count } / { num_batches } )\" , ): paths . extend ( paths_ref ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return PathwaySet . from_paths ( filtered_paths )","title":"solve()"},{"location":"reference/reactions/basic/","text":"This module for defining chemical reaction objects was originally sourced from pymatgen and streamlined for the reaction-network code. BasicReaction Bases: Reaction An object representing a basic chemical reaction: compositions and their coefficients. Source code in rxn_network/reactions/basic.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 class BasicReaction ( Reaction ): \"\"\" An object representing a basic chemical reaction: compositions and their coefficients. \"\"\" def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data if data else {} self . lowest_num_errors = lowest_num_errors @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = list ( reactants + products ) coeffs , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactants , products ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , ) def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ) / 2 ) def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )] def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True ) def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def is_separable ( self , target : Composition ) -> bool : \"\"\" Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Args: target: Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. Returns: True if reaction is separable from target, False otherwise. \"\"\" identified_targets = [ c for c in self . compositions if c . reduced_composition == target . reduced_composition ] if len ( identified_targets ) == 0 : raise ValueError ( f \"Target composition { target } not in reaction { self } \" ) added_elems = set ( self . elements ) - set ( target . elements ) products = set ( deepcopy ( self . products )) for t in identified_targets : products . remove ( t ) separable = [ added_elems . issuperset ( comp . elements ) for comp in products ] found = all ( separable ) return found @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * c . num_atoms / self . num_atoms for c , coeff in self . reactant_coeffs . items () } @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : coeff * c . num_atoms / self . num_atoms for c , coeff in self . product_coeffs . items () } @cached_property def reactant_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . reactant_coeffs . values ()) return { c : coeff / total for c , coeff in self . reactant_coeffs . items ()} @cached_property def product_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of products in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . product_coeffs . values ()) return { c : coeff / total for c , coeff in self . product_coeffs . items ()} @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs ) @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Args: reactants: List of reactant formulas products: List of product formulas Returns: A BasicReaction object \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn @property def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" return list ( self . reactant_coeffs . keys ()) @property def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" return list ( self . product_coeffs . keys ()) @property def compositions ( self ) -> List [ Composition ]: \"\"\"List of composition objects for this reaction\"\"\" return self . _compositions @property def coefficients ( self ) -> np . ndarray : \"\"\"Array of reaction coefficients\"\"\" return self . _coefficients @cached_property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in this reaction\"\"\" return sum ( coeff * sum ( c [ el ] for el in self . elements ) for c , coeff in self . product_coeffs . items () ) @cached_property def energy ( self ) -> float : \"\"\"The energy of this reaction\"\"\" raise ValueError ( \"No energy for a basic reaction!\" ) @cached_property def energy_per_atom ( self ) -> float : \"\"\"The energy per atom of this reaction\"\"\" raise ValueError ( \"No energy per atom for a basic reaction!\" ) @cached_property def is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" return self . _get_is_identity () def _get_is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" if set ( self . reactants ) != set ( self . products ): return False if self . balanced is False : # if not balanced, can not check coefficients return True return all ( np . isclose ( self . reactant_coeffs [ c ] * - 1 , self . product_coeffs [ c ]) for c in self . reactant_coeffs ) @cached_property def chemical_system ( self ): \"\"\"Returns the chemical system as string in the form of A-B-C-...\"\"\" return \"-\" . join ( sorted ([ str ( el ) for el in self . elements ])) @property def normalized_repr ( self ): \"\"\" A normalized representation of the reaction. All factors are converted to lowest common factors. \"\"\" return self . normalized_repr_and_factor ()[ 0 ] @classmethod def _balance_coeffs ( cls , reactants : List [ Composition ], products : List [ Composition ] ) -> Tuple [ np . ndarray , Union [ int , float ], int ]: \"\"\" Balances the reaction and returns the new coefficient matrix \"\"\" compositions = reactants + products num_comp = len ( compositions ) all_elems = sorted ({ elem for c in compositions for elem in c . elements }) num_elems = len ( all_elems ) comp_matrix = np . array ([[ c [ el ] for el in all_elems ] for c in compositions ]) . T rank = np . linalg . matrix_rank ( comp_matrix ) diff = num_comp - rank num_constraints = diff if diff >= 2 else 1 # an error = a component changing sides or disappearing lowest_num_errors = np . inf first_product_idx = len ( reactants ) # start with simplest product constraints, work to more complex constraints product_constraints = chain . from_iterable ( [ combinations ( range ( first_product_idx , num_comp ), n_constr ) for n_constr in range ( num_constraints , 0 , - 1 ) ] ) reactant_constraints = chain . from_iterable ( [ combinations ( range ( 0 , first_product_idx ), n_constr ) for n_constr in range ( num_constraints , 0 , - 1 ) ] ) best_soln = np . zeros ( num_comp ) for constraints in chain ( product_constraints , reactant_constraints ): n_constr = len ( constraints ) comp_and_constraints = np . append ( comp_matrix , np . zeros (( n_constr , num_comp )), axis = 0 ) b = np . zeros (( num_elems + n_constr , 1 )) b [ - n_constr :] = 1 if min ( constraints ) >= first_product_idx else - 1 for num , idx in enumerate ( constraints ): comp_and_constraints [ num_elems + num , idx ] = 1 # arbitrarily fix coeff to 1 coeffs = np . matmul ( np . linalg . pinv ( comp_and_constraints ), b ) num_errors = 0 if np . allclose ( np . matmul ( comp_matrix , coeffs ), np . zeros (( num_elems , 1 ))): expected_signs = np . array ([ - 1 ] * len ( reactants ) + [ + 1 ] * len ( products )) num_errors = np . sum ( np . multiply ( expected_signs , coeffs . T ) < TOLERANCE ) if num_errors == 0 : lowest_num_errors = 0 best_soln = coeffs break if num_errors < lowest_num_errors : lowest_num_errors = num_errors best_soln = coeffs return np . squeeze ( best_soln ), lowest_num_errors , num_constraints @staticmethod def _from_coeff_dicts ( reactant_coeffs , product_coeffs ) -> \"BasicReaction\" : reactant_comps , r_coefs = zip ( * [( comp , - 1 * coeff ) for comp , coeff in reactant_coeffs . items ()] ) product_comps , p_coefs = zip ( * list ( product_coeffs . items ())) return BasicReaction ( reactant_comps + product_comps , r_coefs + p_coefs ) @staticmethod def _str_from_formulas ( coeffs , formulas , tol = TOLERANCE ) -> str : reactant_str = [] product_str = [] for amt , formula in zip ( coeffs , formulas ): if abs ( amt + 1 ) < tol : reactant_str . append ( formula ) elif abs ( amt - 1 ) < tol : product_str . append ( formula ) elif amt < - tol : reactant_str . append ( f \" { - amt : .4g } { formula } \" ) elif amt > tol : product_str . append ( f \" { amt : .4g } { formula } \" ) return \" + \" . join ( reactant_str ) + \" -> \" + \" + \" . join ( product_str ) @classmethod def _str_from_comp ( cls , coeffs , compositions , reduce = False ): r_coeffs = np . zeros ( len ( coeffs )) r_formulas = [] for i , ( amt , comp ) in enumerate ( zip ( coeffs , compositions )): formula , factor = comp . get_reduced_formula_and_factor () r_coeffs [ i ] = amt * factor r_formulas . append ( formula ) if reduce : factor = 1 / gcd_float ( np . abs ( r_coeffs )) r_coeffs *= factor else : factor = 1 return cls . _str_from_formulas ( r_coeffs , r_formulas ), factor def __eq__ ( self , other ): if self is other : return True if not self . chemical_system == other . chemical_system : return False if not len ( self . products ) == len ( other . products ): return False if not len ( self . reactants ) == len ( other . reactants ): return False if not np . allclose ( sorted ( self . coefficients ), sorted ( other . coefficients )): return False if not set ( self . reactants ) == set ( other . reactants ): return False if not set ( self . products ) == set ( other . products ): return False return True def __hash__ ( self ): return hash ( ( self . chemical_system , tuple ( sorted ( self . coefficients ))) ) # not checking here for reactions that are multiples (too expensive) def __str__ ( self ): return self . _str_from_comp ( self . coefficients , self . compositions )[ 0 ] def __repr__ ( self ): return self . __str__ () __init__ ( compositions , coefficients , balanced = None , data = None , lowest_num_errors = 0 ) A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Parameters: Name Type Description Default compositions List [ Composition ] List of composition objects (pymatgen). required coefficients Union [ List [ float ], np . ndarray ] List of coefficients, where negative coeff distinguishes a reactant. required balanced Optional [ bool ] Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). None data Optional [ Dict ] Optional corresponding data in dictionary format; often used to store various calculated parameters. None lowest_num_errors Union [ int , float ] the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors = 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). 0 Source code in rxn_network/reactions/basic.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data if data else {} self . lowest_num_errors = lowest_num_errors balance ( reactants , products , data = None ) classmethod Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactants List [ Composition ] List of reactants. required products List [ Composition ] List of products. required data Optional [ Dict ] Optional dictionary containing extra data about the reaction. None Source code in rxn_network/reactions/basic.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = list ( reactants + products ) coeffs , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactants , products ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , ) chemical_system () property cached Returns the chemical system as string in the form of A-B-C-... Source code in rxn_network/reactions/basic.py 402 403 404 405 @cached_property def chemical_system ( self ): \"\"\"Returns the chemical system as string in the form of A-B-C-...\"\"\" return \"-\" . join ( sorted ([ str ( el ) for el in self . elements ])) coefficients () property Array of reaction coefficients Source code in rxn_network/reactions/basic.py 363 364 365 366 @property def coefficients ( self ) -> np . ndarray : \"\"\"Array of reaction coefficients\"\"\" return self . _coefficients compositions () property List of composition objects for this reaction Source code in rxn_network/reactions/basic.py 358 359 360 361 @property def compositions ( self ) -> List [ Composition ]: \"\"\"List of composition objects for this reaction\"\"\" return self . _compositions copy () Returns a copy of the BasicReaction object Source code in rxn_network/reactions/basic.py 192 193 194 195 196 197 198 199 200 def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) energy () property cached The energy of this reaction Source code in rxn_network/reactions/basic.py 376 377 378 379 @cached_property def energy ( self ) -> float : \"\"\"The energy of this reaction\"\"\" raise ValueError ( \"No energy for a basic reaction!\" ) energy_per_atom () property cached The energy per atom of this reaction Source code in rxn_network/reactions/basic.py 381 382 383 384 @cached_property def energy_per_atom ( self ) -> float : \"\"\"The energy per atom of this reaction\"\"\" raise ValueError ( \"No energy per atom for a basic reaction!\" ) from_formulas ( reactants , products ) classmethod Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Parameters: Name Type Description Default reactants List [ str ] List of reactant formulas required products List [ str ] List of product formulas required Returns: Type Description BasicReaction A BasicReaction object Source code in rxn_network/reactions/basic.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Args: reactants: List of reactant formulas products: List of product formulas Returns: A BasicReaction object \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn from_string ( rxn_string ) classmethod Generates a balanced reaction from a string. The reaction must already be balanced. Parameters: Name Type Description Default rxn_string The reaction string. For example, \"4 Li + O2-> 2Li2O\" required Returns: Type Description BasicReaction BalancedReaction Source code in rxn_network/reactions/basic.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs ) get_coeff ( comp ) Returns coefficient for a particular composition Source code in rxn_network/reactions/basic.py 179 180 181 182 183 def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )] get_el_amount ( element ) Returns the amount of the element in the reaction. Parameters: Name Type Description Default element Element/Species Element in the reaction required Returns: Type Description float Amount of that element in the reaction. Source code in rxn_network/reactions/basic.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ) / 2 ) is_identity () property cached Returns True if the reaction has identical reactants and products Source code in rxn_network/reactions/basic.py 386 387 388 389 @cached_property def is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" return self . _get_is_identity () is_separable ( target ) Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Parameters: Name Type Description Default target Composition Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. required Returns: Type Description bool True if reaction is separable from target, False otherwise. Source code in rxn_network/reactions/basic.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def is_separable ( self , target : Composition ) -> bool : \"\"\" Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Args: target: Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. Returns: True if reaction is separable from target, False otherwise. \"\"\" identified_targets = [ c for c in self . compositions if c . reduced_composition == target . reduced_composition ] if len ( identified_targets ) == 0 : raise ValueError ( f \"Target composition { target } not in reaction { self } \" ) added_elems = set ( self . elements ) - set ( target . elements ) products = set ( deepcopy ( self . products )) for t in identified_targets : products . remove ( t ) separable = [ added_elems . issuperset ( comp . elements ) for comp in products ] found = all ( separable ) return found normalize_to ( comp , factor = 1 ) Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) normalize_to_element ( element , factor = 1 ) Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element/Species Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) normalized_repr () property A normalized representation of the reaction. All factors are converted to lowest common factors. Source code in rxn_network/reactions/basic.py 407 408 409 410 411 412 413 @property def normalized_repr ( self ): \"\"\" A normalized representation of the reaction. All factors are converted to lowest common factors. \"\"\" return self . normalized_repr_and_factor ()[ 0 ] normalized_repr_and_factor () Normalized representation for a reaction For example, 4 Li + 2 O -> 2Li2O becomes 2 Li + O -> Li2O Source code in rxn_network/reactions/basic.py 185 186 187 188 189 190 def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True ) num_atoms () property cached Total number of atoms in this reaction Source code in rxn_network/reactions/basic.py 368 369 370 371 372 373 374 @cached_property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in this reaction\"\"\" return sum ( coeff * sum ( c [ el ] for el in self . elements ) for c , coeff in self . product_coeffs . items () ) product_atomic_fractions () property cached Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 261 262 263 264 265 266 267 268 269 270 271 272 @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : coeff * c . num_atoms / self . num_atoms for c , coeff in self . product_coeffs . items () } product_molar_fractions () property cached Returns the molar mixing ratio of products in the reaction Source code in rxn_network/reactions/basic.py 286 287 288 289 290 291 292 293 294 295 296 @cached_property def product_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of products in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . product_coeffs . values ()) return { c : coeff / total for c , coeff in self . product_coeffs . items ()} products () property List of products for this reaction Source code in rxn_network/reactions/basic.py 353 354 355 356 @property def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" return list ( self . product_coeffs . keys ()) reactant_atomic_fractions () property cached Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 248 249 250 251 252 253 254 255 256 257 258 259 @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * c . num_atoms / self . num_atoms for c , coeff in self . reactant_coeffs . items () } reactant_molar_fractions () property cached Returns the molar mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 274 275 276 277 278 279 280 281 282 283 284 @cached_property def reactant_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . reactant_coeffs . values ()) return { c : coeff / total for c , coeff in self . reactant_coeffs . items ()} reactants () property List of reactants for this reaction Source code in rxn_network/reactions/basic.py 348 349 350 351 @property def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" return list ( self . reactant_coeffs . keys ()) reverse () Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. Source code in rxn_network/reactions/basic.py 202 203 204 205 206 207 208 209 210 211 212 213 def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"Basic"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction","text":"Bases: Reaction An object representing a basic chemical reaction: compositions and their coefficients. Source code in rxn_network/reactions/basic.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 543 544 545 546 547 548 549 550 551 552 553 554 555 class BasicReaction ( Reaction ): \"\"\" An object representing a basic chemical reaction: compositions and their coefficients. \"\"\" def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data if data else {} self . lowest_num_errors = lowest_num_errors @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = list ( reactants + products ) coeffs , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactants , products ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , ) def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ) / 2 ) def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )] def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True ) def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def is_separable ( self , target : Composition ) -> bool : \"\"\" Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Args: target: Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. Returns: True if reaction is separable from target, False otherwise. \"\"\" identified_targets = [ c for c in self . compositions if c . reduced_composition == target . reduced_composition ] if len ( identified_targets ) == 0 : raise ValueError ( f \"Target composition { target } not in reaction { self } \" ) added_elems = set ( self . elements ) - set ( target . elements ) products = set ( deepcopy ( self . products )) for t in identified_targets : products . remove ( t ) separable = [ added_elems . issuperset ( comp . elements ) for comp in products ] found = all ( separable ) return found @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * c . num_atoms / self . num_atoms for c , coeff in self . reactant_coeffs . items () } @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : coeff * c . num_atoms / self . num_atoms for c , coeff in self . product_coeffs . items () } @cached_property def reactant_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . reactant_coeffs . values ()) return { c : coeff / total for c , coeff in self . reactant_coeffs . items ()} @cached_property def product_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of products in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . product_coeffs . values ()) return { c : coeff / total for c , coeff in self . product_coeffs . items ()} @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs ) @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Args: reactants: List of reactant formulas products: List of product formulas Returns: A BasicReaction object \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn @property def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" return list ( self . reactant_coeffs . keys ()) @property def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" return list ( self . product_coeffs . keys ()) @property def compositions ( self ) -> List [ Composition ]: \"\"\"List of composition objects for this reaction\"\"\" return self . _compositions @property def coefficients ( self ) -> np . ndarray : \"\"\"Array of reaction coefficients\"\"\" return self . _coefficients @cached_property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in this reaction\"\"\" return sum ( coeff * sum ( c [ el ] for el in self . elements ) for c , coeff in self . product_coeffs . items () ) @cached_property def energy ( self ) -> float : \"\"\"The energy of this reaction\"\"\" raise ValueError ( \"No energy for a basic reaction!\" ) @cached_property def energy_per_atom ( self ) -> float : \"\"\"The energy per atom of this reaction\"\"\" raise ValueError ( \"No energy per atom for a basic reaction!\" ) @cached_property def is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" return self . _get_is_identity () def _get_is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" if set ( self . reactants ) != set ( self . products ): return False if self . balanced is False : # if not balanced, can not check coefficients return True return all ( np . isclose ( self . reactant_coeffs [ c ] * - 1 , self . product_coeffs [ c ]) for c in self . reactant_coeffs ) @cached_property def chemical_system ( self ): \"\"\"Returns the chemical system as string in the form of A-B-C-...\"\"\" return \"-\" . join ( sorted ([ str ( el ) for el in self . elements ])) @property def normalized_repr ( self ): \"\"\" A normalized representation of the reaction. All factors are converted to lowest common factors. \"\"\" return self . normalized_repr_and_factor ()[ 0 ] @classmethod def _balance_coeffs ( cls , reactants : List [ Composition ], products : List [ Composition ] ) -> Tuple [ np . ndarray , Union [ int , float ], int ]: \"\"\" Balances the reaction and returns the new coefficient matrix \"\"\" compositions = reactants + products num_comp = len ( compositions ) all_elems = sorted ({ elem for c in compositions for elem in c . elements }) num_elems = len ( all_elems ) comp_matrix = np . array ([[ c [ el ] for el in all_elems ] for c in compositions ]) . T rank = np . linalg . matrix_rank ( comp_matrix ) diff = num_comp - rank num_constraints = diff if diff >= 2 else 1 # an error = a component changing sides or disappearing lowest_num_errors = np . inf first_product_idx = len ( reactants ) # start with simplest product constraints, work to more complex constraints product_constraints = chain . from_iterable ( [ combinations ( range ( first_product_idx , num_comp ), n_constr ) for n_constr in range ( num_constraints , 0 , - 1 ) ] ) reactant_constraints = chain . from_iterable ( [ combinations ( range ( 0 , first_product_idx ), n_constr ) for n_constr in range ( num_constraints , 0 , - 1 ) ] ) best_soln = np . zeros ( num_comp ) for constraints in chain ( product_constraints , reactant_constraints ): n_constr = len ( constraints ) comp_and_constraints = np . append ( comp_matrix , np . zeros (( n_constr , num_comp )), axis = 0 ) b = np . zeros (( num_elems + n_constr , 1 )) b [ - n_constr :] = 1 if min ( constraints ) >= first_product_idx else - 1 for num , idx in enumerate ( constraints ): comp_and_constraints [ num_elems + num , idx ] = 1 # arbitrarily fix coeff to 1 coeffs = np . matmul ( np . linalg . pinv ( comp_and_constraints ), b ) num_errors = 0 if np . allclose ( np . matmul ( comp_matrix , coeffs ), np . zeros (( num_elems , 1 ))): expected_signs = np . array ([ - 1 ] * len ( reactants ) + [ + 1 ] * len ( products )) num_errors = np . sum ( np . multiply ( expected_signs , coeffs . T ) < TOLERANCE ) if num_errors == 0 : lowest_num_errors = 0 best_soln = coeffs break if num_errors < lowest_num_errors : lowest_num_errors = num_errors best_soln = coeffs return np . squeeze ( best_soln ), lowest_num_errors , num_constraints @staticmethod def _from_coeff_dicts ( reactant_coeffs , product_coeffs ) -> \"BasicReaction\" : reactant_comps , r_coefs = zip ( * [( comp , - 1 * coeff ) for comp , coeff in reactant_coeffs . items ()] ) product_comps , p_coefs = zip ( * list ( product_coeffs . items ())) return BasicReaction ( reactant_comps + product_comps , r_coefs + p_coefs ) @staticmethod def _str_from_formulas ( coeffs , formulas , tol = TOLERANCE ) -> str : reactant_str = [] product_str = [] for amt , formula in zip ( coeffs , formulas ): if abs ( amt + 1 ) < tol : reactant_str . append ( formula ) elif abs ( amt - 1 ) < tol : product_str . append ( formula ) elif amt < - tol : reactant_str . append ( f \" { - amt : .4g } { formula } \" ) elif amt > tol : product_str . append ( f \" { amt : .4g } { formula } \" ) return \" + \" . join ( reactant_str ) + \" -> \" + \" + \" . join ( product_str ) @classmethod def _str_from_comp ( cls , coeffs , compositions , reduce = False ): r_coeffs = np . zeros ( len ( coeffs )) r_formulas = [] for i , ( amt , comp ) in enumerate ( zip ( coeffs , compositions )): formula , factor = comp . get_reduced_formula_and_factor () r_coeffs [ i ] = amt * factor r_formulas . append ( formula ) if reduce : factor = 1 / gcd_float ( np . abs ( r_coeffs )) r_coeffs *= factor else : factor = 1 return cls . _str_from_formulas ( r_coeffs , r_formulas ), factor def __eq__ ( self , other ): if self is other : return True if not self . chemical_system == other . chemical_system : return False if not len ( self . products ) == len ( other . products ): return False if not len ( self . reactants ) == len ( other . reactants ): return False if not np . allclose ( sorted ( self . coefficients ), sorted ( other . coefficients )): return False if not set ( self . reactants ) == set ( other . reactants ): return False if not set ( self . products ) == set ( other . products ): return False return True def __hash__ ( self ): return hash ( ( self . chemical_system , tuple ( sorted ( self . coefficients ))) ) # not checking here for reactions that are multiples (too expensive) def __str__ ( self ): return self . _str_from_comp ( self . coefficients , self . compositions )[ 0 ] def __repr__ ( self ): return self . __str__ ()","title":"BasicReaction"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.__init__","text":"A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Parameters: Name Type Description Default compositions List [ Composition ] List of composition objects (pymatgen). required coefficients Union [ List [ float ], np . ndarray ] List of coefficients, where negative coeff distinguishes a reactant. required balanced Optional [ bool ] Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). None data Optional [ Dict ] Optional corresponding data in dictionary format; often used to store various calculated parameters. None lowest_num_errors Union [ int , float ] the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors = 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). 0 Source code in rxn_network/reactions/basic.py 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data if data else {} self . lowest_num_errors = lowest_num_errors","title":"__init__()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.balance","text":"Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactants List [ Composition ] List of reactants. required products List [ Composition ] List of products. required data Optional [ Dict ] Optional dictionary containing extra data about the reaction. None Source code in rxn_network/reactions/basic.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = list ( reactants + products ) coeffs , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactants , products ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , )","title":"balance()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.chemical_system","text":"Returns the chemical system as string in the form of A-B-C-... Source code in rxn_network/reactions/basic.py 402 403 404 405 @cached_property def chemical_system ( self ): \"\"\"Returns the chemical system as string in the form of A-B-C-...\"\"\" return \"-\" . join ( sorted ([ str ( el ) for el in self . elements ]))","title":"chemical_system()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.coefficients","text":"Array of reaction coefficients Source code in rxn_network/reactions/basic.py 363 364 365 366 @property def coefficients ( self ) -> np . ndarray : \"\"\"Array of reaction coefficients\"\"\" return self . _coefficients","title":"coefficients()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.compositions","text":"List of composition objects for this reaction Source code in rxn_network/reactions/basic.py 358 359 360 361 @property def compositions ( self ) -> List [ Composition ]: \"\"\"List of composition objects for this reaction\"\"\" return self . _compositions","title":"compositions()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.copy","text":"Returns a copy of the BasicReaction object Source code in rxn_network/reactions/basic.py 192 193 194 195 196 197 198 199 200 def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"copy()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.energy","text":"The energy of this reaction Source code in rxn_network/reactions/basic.py 376 377 378 379 @cached_property def energy ( self ) -> float : \"\"\"The energy of this reaction\"\"\" raise ValueError ( \"No energy for a basic reaction!\" )","title":"energy()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.energy_per_atom","text":"The energy per atom of this reaction Source code in rxn_network/reactions/basic.py 381 382 383 384 @cached_property def energy_per_atom ( self ) -> float : \"\"\"The energy per atom of this reaction\"\"\" raise ValueError ( \"No energy per atom for a basic reaction!\" )","title":"energy_per_atom()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.from_formulas","text":"Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Parameters: Name Type Description Default reactants List [ str ] List of reactant formulas required products List [ str ] List of product formulas required Returns: Type Description BasicReaction A BasicReaction object Source code in rxn_network/reactions/basic.py 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Initialize a reaction from a list of 1) reactant formulas and 2) product formulas. Args: reactants: List of reactant formulas products: List of product formulas Returns: A BasicReaction object \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn","title":"from_formulas()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.from_string","text":"Generates a balanced reaction from a string. The reaction must already be balanced. Parameters: Name Type Description Default rxn_string The reaction string. For example, \"4 Li + O2-> 2Li2O\" required Returns: Type Description BasicReaction BalancedReaction Source code in rxn_network/reactions/basic.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs )","title":"from_string()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.get_coeff","text":"Returns coefficient for a particular composition Source code in rxn_network/reactions/basic.py 179 180 181 182 183 def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )]","title":"get_coeff()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.get_el_amount","text":"Returns the amount of the element in the reaction. Parameters: Name Type Description Default element Element/Species Element in the reaction required Returns: Type Description float Amount of that element in the reaction. Source code in rxn_network/reactions/basic.py 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ) / 2 )","title":"get_el_amount()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.is_identity","text":"Returns True if the reaction has identical reactants and products Source code in rxn_network/reactions/basic.py 386 387 388 389 @cached_property def is_identity ( self ): \"\"\"Returns True if the reaction has identical reactants and products\"\"\" return self . _get_is_identity ()","title":"is_identity()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.is_separable","text":"Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Parameters: Name Type Description Default target Composition Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. required Returns: Type Description bool True if reaction is separable from target, False otherwise. Source code in rxn_network/reactions/basic.py 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 def is_separable ( self , target : Composition ) -> bool : \"\"\" Checks if the reaction forms byproducts which are separable from the target composition; i.e., byproducts do not contain any of the elements in the target phase. Args: target: Composition object of target; elements in this phase will be used to determine whether byproducts only contain added elements. Returns: True if reaction is separable from target, False otherwise. \"\"\" identified_targets = [ c for c in self . compositions if c . reduced_composition == target . reduced_composition ] if len ( identified_targets ) == 0 : raise ValueError ( f \"Target composition { target } not in reaction { self } \" ) added_elems = set ( self . elements ) - set ( target . elements ) products = set ( deepcopy ( self . products )) for t in identified_targets : products . remove ( t ) separable = [ added_elems . issuperset ( comp . elements ) for comp in products ] found = all ( separable ) return found","title":"is_separable()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalize_to","text":"Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs )","title":"normalize_to()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalize_to_element","text":"Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element/Species Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs )","title":"normalize_to_element()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalized_repr","text":"A normalized representation of the reaction. All factors are converted to lowest common factors. Source code in rxn_network/reactions/basic.py 407 408 409 410 411 412 413 @property def normalized_repr ( self ): \"\"\" A normalized representation of the reaction. All factors are converted to lowest common factors. \"\"\" return self . normalized_repr_and_factor ()[ 0 ]","title":"normalized_repr()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalized_repr_and_factor","text":"Normalized representation for a reaction For example, 4 Li + 2 O -> 2Li2O becomes 2 Li + O -> Li2O Source code in rxn_network/reactions/basic.py 185 186 187 188 189 190 def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True )","title":"normalized_repr_and_factor()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.num_atoms","text":"Total number of atoms in this reaction Source code in rxn_network/reactions/basic.py 368 369 370 371 372 373 374 @cached_property def num_atoms ( self ) -> float : \"\"\"Total number of atoms in this reaction\"\"\" return sum ( coeff * sum ( c [ el ] for el in self . elements ) for c , coeff in self . product_coeffs . items () )","title":"num_atoms()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.product_atomic_fractions","text":"Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 261 262 263 264 265 266 267 268 269 270 271 272 @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : coeff * c . num_atoms / self . num_atoms for c , coeff in self . product_coeffs . items () }","title":"product_atomic_fractions()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.product_molar_fractions","text":"Returns the molar mixing ratio of products in the reaction Source code in rxn_network/reactions/basic.py 286 287 288 289 290 291 292 293 294 295 296 @cached_property def product_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of products in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . product_coeffs . values ()) return { c : coeff / total for c , coeff in self . product_coeffs . items ()}","title":"product_molar_fractions()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.products","text":"List of products for this reaction Source code in rxn_network/reactions/basic.py 353 354 355 356 @property def products ( self ) -> List [ Composition ]: \"\"\"List of products for this reaction\"\"\" return list ( self . product_coeffs . keys ())","title":"products()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reactant_atomic_fractions","text":"Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 248 249 250 251 252 253 254 255 256 257 258 259 @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * c . num_atoms / self . num_atoms for c , coeff in self . reactant_coeffs . items () }","title":"reactant_atomic_fractions()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reactant_molar_fractions","text":"Returns the molar mixing ratio of reactants in the reaction Source code in rxn_network/reactions/basic.py 274 275 276 277 278 279 280 281 282 283 284 @cached_property def reactant_molar_fractions ( self ) -> dict : \"\"\" Returns the molar mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) total = sum ( self . reactant_coeffs . values ()) return { c : coeff / total for c , coeff in self . reactant_coeffs . items ()}","title":"reactant_molar_fractions()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reactants","text":"List of reactants for this reaction Source code in rxn_network/reactions/basic.py 348 349 350 351 @property def reactants ( self ) -> List [ Composition ]: \"\"\"List of reactants for this reaction\"\"\" return list ( self . reactant_coeffs . keys ())","title":"reactants()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reverse","text":"Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. Source code in rxn_network/reactions/basic.py 202 203 204 205 206 207 208 209 210 211 212 213 def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients . copy (), balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"reverse()"},{"location":"reference/reactions/computed/","text":"A reaction class that builds reactions based on ComputedEntry objects and provides information about reaction thermodynamics. ComputedReaction Bases: BasicReaction Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction. Source code in rxn_network/reactions/computed.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class ComputedReaction ( BasicReaction ): \"\"\" Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors ) @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ) -> \"ComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) def get_new_temperature ( self , new_temperature : float ): \"\"\" Returns a new reaction with the temperature changed. Args: new_temperature: New temperature in Kelvin \"\"\" try : new_entries = [ e . get_new_temperature ( new_temperature ) for e in self . entries ] except AttributeError as e : raise AttributeError ( \"One or more of the entries in the reaction is not associated with a\" \" temperature. Please use the GibbsComputedEntry class for all entries\" \" in the reaction.\" ) from e return ComputedReaction ( new_entries , self . coefficients , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def get_energy ( self ): \"\"\" \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @cached_property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @cached_property def energy_per_atom ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. \"\"\" return self . energy / self . num_atoms @cached_property def energy_uncertainty ( self ) -> float : \"\"\" Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. \"\"\" calc_energies : Dict [ Composition , ufloat ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () energy_ufloat = ufloat ( entry . energy , entry . correction_uncertainty ) calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), energy_ufloat / factor ) energy_with_uncertainty = sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) return energy_with_uncertainty . s # type: ignore @cached_property def energy_uncertainty_per_atom ( self ) -> float : \"\"\" Returns the energy_uncertainty divided by the total number of atoms in the reaction. \"\"\" return self . energy_uncertainty / self . num_atoms @property def entries ( self ) -> List [ ComputedEntry ]: \"\"\" Returns a copy of the entries \"\"\" return self . _entries def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors ) def reverse ( self ) -> \"ComputedReaction\" : \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors ) def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) def get_entry_idx_vector ( self , n ): indices = [ e . data . get ( \"idx\" ) for e in self . entries ] if None in indices : raise ValueError ( f \"Could not find index for one or more entries in reaction: { self } \" ) v = np . zeros ( n ) v [ indices ] = self . coefficients return v def __hash__ ( self ): return BasicReaction . __hash__ ( self ) def __eq__ ( self , other ): is_equal = BasicReaction . __eq__ ( self , other ) if is_equal : is_equal = np . isclose ( self . energy_per_atom , other . energy_per_atom ) return is_equal __init__ ( entries , coefficients , data = None , lowest_num_errors = 0 ) Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects. required coefficients Union [ np . ndarray , List [ float ]] List of reaction coefficients. required data Optional [ Dict ] Optional dict of data None lowest_num_errors Union [ int , float ] number of \"errors\" encountered during reaction balancing 0 Source code in rxn_network/reactions/computed.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors ) balance ( reactant_entries , product_entries , data = None ) classmethod Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Parameters: Name Type Description Default reactant_entries List [ ComputedEntry ] List of reactant entries required product_entries List [ ComputedEntry ] List of product entries required data Optional [ Dict ] Optional dict of data None Source code in rxn_network/reactions/computed.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ) -> \"ComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) copy () Returns a copy of the Reaction object Source code in rxn_network/reactions/computed.py 190 191 192 193 194 195 196 def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors ) energy () property cached Returns (float): The calculated reaction energy. Source code in rxn_network/reactions/computed.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @cached_property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) energy_per_atom () property cached Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. Source code in rxn_network/reactions/computed.py 143 144 145 146 147 148 149 150 @cached_property def energy_per_atom ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. \"\"\" return self . energy / self . num_atoms energy_uncertainty () property cached Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. Source code in rxn_network/reactions/computed.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @cached_property def energy_uncertainty ( self ) -> float : \"\"\" Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. \"\"\" calc_energies : Dict [ Composition , ufloat ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () energy_ufloat = ufloat ( entry . energy , entry . correction_uncertainty ) calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), energy_ufloat / factor ) energy_with_uncertainty = sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) return energy_with_uncertainty . s # type: ignore energy_uncertainty_per_atom () property cached Returns the energy_uncertainty divided by the total number of atoms in the reaction. Source code in rxn_network/reactions/computed.py 175 176 177 178 179 180 181 @cached_property def energy_uncertainty_per_atom ( self ) -> float : \"\"\" Returns the energy_uncertainty divided by the total number of atoms in the reaction. \"\"\" return self . energy_uncertainty / self . num_atoms entries () property Returns a copy of the entries Source code in rxn_network/reactions/computed.py 183 184 185 186 187 188 @property def entries ( self ) -> List [ ComputedEntry ]: \"\"\" Returns a copy of the entries \"\"\" return self . _entries get_new_temperature ( new_temperature ) Returns a new reaction with the temperature changed. Parameters: Name Type Description Default new_temperature float New temperature in Kelvin required Source code in rxn_network/reactions/computed.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_new_temperature ( self , new_temperature : float ): \"\"\" Returns a new reaction with the temperature changed. Args: new_temperature: New temperature in Kelvin \"\"\" try : new_entries = [ e . get_new_temperature ( new_temperature ) for e in self . entries ] except AttributeError as e : raise AttributeError ( \"One or more of the entries in the reaction is not associated with a\" \" temperature. Please use the GibbsComputedEntry class for all entries\" \" in the reaction.\" ) from e return ComputedReaction ( new_entries , self . coefficients , data = self . data , lowest_num_errors = self . lowest_num_errors , ) normalize_to ( comp , factor = 1 ) Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/computed.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) normalize_to_element ( element , factor = 1 ) Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element/Species Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/computed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) reverse () Returns a reversed reaction (i.e. sides flipped) Source code in rxn_network/reactions/computed.py 198 199 200 201 202 203 204 205 def reverse ( self ) -> \"ComputedReaction\" : \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors )","title":"Computed"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction","text":"Bases: BasicReaction Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction. Source code in rxn_network/reactions/computed.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 class ComputedReaction ( BasicReaction ): \"\"\" Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors ) @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ) -> \"ComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) def get_new_temperature ( self , new_temperature : float ): \"\"\" Returns a new reaction with the temperature changed. Args: new_temperature: New temperature in Kelvin \"\"\" try : new_entries = [ e . get_new_temperature ( new_temperature ) for e in self . entries ] except AttributeError as e : raise AttributeError ( \"One or more of the entries in the reaction is not associated with a\" \" temperature. Please use the GibbsComputedEntry class for all entries\" \" in the reaction.\" ) from e return ComputedReaction ( new_entries , self . coefficients , data = self . data , lowest_num_errors = self . lowest_num_errors , ) def get_energy ( self ): \"\"\" \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @cached_property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @cached_property def energy_per_atom ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. \"\"\" return self . energy / self . num_atoms @cached_property def energy_uncertainty ( self ) -> float : \"\"\" Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. \"\"\" calc_energies : Dict [ Composition , ufloat ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () energy_ufloat = ufloat ( entry . energy , entry . correction_uncertainty ) calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), energy_ufloat / factor ) energy_with_uncertainty = sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) return energy_with_uncertainty . s # type: ignore @cached_property def energy_uncertainty_per_atom ( self ) -> float : \"\"\" Returns the energy_uncertainty divided by the total number of atoms in the reaction. \"\"\" return self . energy_uncertainty / self . num_atoms @property def entries ( self ) -> List [ ComputedEntry ]: \"\"\" Returns a copy of the entries \"\"\" return self . _entries def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors ) def reverse ( self ) -> \"ComputedReaction\" : \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors ) def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors ) def get_entry_idx_vector ( self , n ): indices = [ e . data . get ( \"idx\" ) for e in self . entries ] if None in indices : raise ValueError ( f \"Could not find index for one or more entries in reaction: { self } \" ) v = np . zeros ( n ) v [ indices ] = self . coefficients return v def __hash__ ( self ): return BasicReaction . __hash__ ( self ) def __eq__ ( self , other ): is_equal = BasicReaction . __eq__ ( self , other ) if is_equal : is_equal = np . isclose ( self . energy_per_atom , other . energy_per_atom ) return is_equal","title":"ComputedReaction"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.__init__","text":"Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects. required coefficients Union [ np . ndarray , List [ float ]] List of reaction coefficients. required data Optional [ Dict ] Optional dict of data None lowest_num_errors Union [ int , float ] number of \"errors\" encountered during reaction balancing 0 Source code in rxn_network/reactions/computed.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors )","title":"__init__()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.balance","text":"Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Parameters: Name Type Description Default reactant_entries List [ ComputedEntry ] List of reactant entries required product_entries List [ ComputedEntry ] List of product entries required data Optional [ Dict ] Optional dict of data None Source code in rxn_network/reactions/computed.py 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ) -> \"ComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , )","title":"balance()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.copy","text":"Returns a copy of the Reaction object Source code in rxn_network/reactions/computed.py 190 191 192 193 194 195 196 def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors )","title":"copy()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy","text":"Returns (float): The calculated reaction energy. Source code in rxn_network/reactions/computed.py 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @cached_property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) )","title":"energy()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy_per_atom","text":"Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. Source code in rxn_network/reactions/computed.py 143 144 145 146 147 148 149 150 @cached_property def energy_per_atom ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. \"\"\" return self . energy / self . num_atoms","title":"energy_per_atom()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy_uncertainty","text":"Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. Source code in rxn_network/reactions/computed.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 @cached_property def energy_uncertainty ( self ) -> float : \"\"\" Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products. \"\"\" calc_energies : Dict [ Composition , ufloat ] = {} for entry in self . _entries : ( comp , factor ) = entry . composition . get_reduced_composition_and_factor () energy_ufloat = ufloat ( entry . energy , entry . correction_uncertainty ) calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), energy_ufloat / factor ) energy_with_uncertainty = sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) return energy_with_uncertainty . s # type: ignore","title":"energy_uncertainty()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy_uncertainty_per_atom","text":"Returns the energy_uncertainty divided by the total number of atoms in the reaction. Source code in rxn_network/reactions/computed.py 175 176 177 178 179 180 181 @cached_property def energy_uncertainty_per_atom ( self ) -> float : \"\"\" Returns the energy_uncertainty divided by the total number of atoms in the reaction. \"\"\" return self . energy_uncertainty / self . num_atoms","title":"energy_uncertainty_per_atom()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.entries","text":"Returns a copy of the entries Source code in rxn_network/reactions/computed.py 183 184 185 186 187 188 @property def entries ( self ) -> List [ ComputedEntry ]: \"\"\" Returns a copy of the entries \"\"\" return self . _entries","title":"entries()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.get_new_temperature","text":"Returns a new reaction with the temperature changed. Parameters: Name Type Description Default new_temperature float New temperature in Kelvin required Source code in rxn_network/reactions/computed.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 def get_new_temperature ( self , new_temperature : float ): \"\"\" Returns a new reaction with the temperature changed. Args: new_temperature: New temperature in Kelvin \"\"\" try : new_entries = [ e . get_new_temperature ( new_temperature ) for e in self . entries ] except AttributeError as e : raise AttributeError ( \"One or more of the entries in the reaction is not associated with a\" \" temperature. Please use the GibbsComputedEntry class for all entries\" \" in the reaction.\" ) from e return ComputedReaction ( new_entries , self . coefficients , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"get_new_temperature()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.normalize_to","text":"Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/computed.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" coeffs = self . coefficients . copy () scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors )","title":"normalize_to()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.normalize_to_element","text":"Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element/Species Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/computed.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"ComputedReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients . copy () current_el_amount = ( sum ( all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return ComputedReaction ( self . entries , coeffs , self . data , self . lowest_num_errors )","title":"normalize_to_element()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.reverse","text":"Returns a reversed reaction (i.e. sides flipped) Source code in rxn_network/reactions/computed.py 198 199 200 201 202 203 204 205 def reverse ( self ) -> \"ComputedReaction\" : \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors )","title":"reverse()"},{"location":"reference/reactions/hull/","text":"Code for analyzing sets of reactions between two phases. InterfaceReactionHull Bases: MSONable A class for storing and analyzing a set of reactions at an interface between two reactants. This class is more generalized than the InterfacialReactivity class and can encompass any set of reactions between two reactants, regardless of whether the reaction products are \"stable\" (i.e. together on the convex hull) Source code in rxn_network/reactions/hull.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class InterfaceReactionHull ( MSONable ): \"\"\" A class for storing and analyzing a set of reactions at an interface between two reactants. This class is more generalized than the InterfacialReactivity class and can encompass any set of reactions between two reactants, regardless of whether the reaction products are \"stable\" (i.e. together on the convex hull) \"\"\" def __init__ ( self , c1 : Composition , c2 : Composition , reactions : List [ ComputedReaction ], max_num_constraints = 1 , ): \"\"\" Args: c1: Composition of reactant 1 c2: Composition of reactant 2 reactions: List of reactions containing all enumerated reactions between the two reactants. Note that this list should \"\"\" self . c1 = Composition ( c1 ) . reduced_composition self . c2 = Composition ( c2 ) . reduced_composition self . e1 = None self . e2 = None for rxn in reactions : for e in rxn . reactant_entries : if e . composition . reduced_composition == self . c1 : self . e1 = e elif e . composition . reduced_composition == self . c2 : self . e2 = e if self . e1 is not None and self . e2 is not None : break else : print ( c1 , c2 ) print ( reactions ) raise ValueError ( \"Provided reactions do not correspond to reactant compositons!\" ) reactions = [ r for r in reactions if r . data . get ( \"num_constraints\" , 1 ) <= max_num_constraints ] endpoint_reactions = [ ComputedReaction . balance ([ self . e1 ], [ self . e1 ]), ComputedReaction . balance ([ self . e2 ], [ self . e2 ]), ] reactions_with_endpoints = reactions + endpoint_reactions coords = np . array ( [( self . get_coordinate ( r ), r . energy_per_atom ) for r in reactions ] ) coords = np . append ( coords , [[ 0 , 0 ], [ 1 , 0 ]], axis = 0 ) idx_sort = coords [:, 0 ] . argsort () self . coords = coords [ idx_sort ] self . reactions = [ reactions_with_endpoints [ i ] for i in idx_sort ] self . hull = ConvexHull ( self . coords ) self . endpoint_reactions = endpoint_reactions def plot ( self , y_max = 0.2 ): \"\"\" Plot the reaction hull. \"\"\" pts = self . _get_scatter () lines = self . _get_lines () fig = Figure ( data = lines + [ pts ]) fig . update_traces ( hovertemplate = ( \"<b>% {hovertext} </b><br> <br><b>Atomic fraction</b>:\" \" % {x:.3f} <br><b>Energy</b>: % {y:.3f} (eV/atom)\" ) ) fig . update_layout ( yaxis_range = [ min ( self . coords [:, 1 ]) - 0.01 , y_max ]) fig . update_layout ( xaxis_title = \"Mixing ratio\" ) fig . update_layout ( yaxis_title = \"Energy (eV/atom)\" ) return fig def get_energy_above_hull ( self , reaction ): \"\"\" Get the energy of a reaction above the reaction hull. \"\"\" idx = self . reactions . index ( reaction ) x , y = self . coords [ idx ] e_above_hull = y - self . get_hull_energy ( x ) return e_above_hull def get_coordinate ( self , reaction ): \"\"\"Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction.\"\"\" amt_c1 = reaction . reactant_atomic_fractions . get ( self . c1 , 0 ) amt_c2 = reaction . reactant_atomic_fractions . get ( self . c2 , 0 ) total = amt_c1 + amt_c2 # will add to 1.0 with two-component reactions try : coordinate = amt_c2 / total except ZeroDivisionError as e : raise ValueError ( f \"Can't compute coordinate for { reaction } with { self . c1 } , { self . c2 } \" ) from e return round ( coordinate , 12 ) # avoids numerical issues def get_hull_energy ( self , coordinate ): \"\"\" Get the energy of the reaction at a given coordinate. Args: coordinate: Coordinate of reaction in reaction hull. Returns: Energy of reaction at given coordinate. \"\"\" reactions = self . get_reactions_by_coordinate ( coordinate ) return sum ( weight * r . energy_per_atom for r , weight in reactions . items ()) def get_reactions_by_coordinate ( self , coordinate ): \"\"\"Get the reaction(s) at a given coordinate.\"\"\" sorted_vertices = np . sort ( self . hull_vertices ) for i in range ( len ( sorted_vertices ) - 1 ): v1 = sorted_vertices [ i ] v2 = sorted_vertices [ i + 1 ] x1 = self . coords [ v1 , 0 ] x2 = self . coords [ v2 , 0 ] if np . isclose ( coordinate , x1 ): return { self . reactions [ v1 ]: 1.0 } if np . isclose ( coordinate , x2 ): return { self . reactions [ v2 ]: 1.0 } if x1 < coordinate < x2 : return { self . reactions [ v1 ]: ( x2 - coordinate ) / ( x2 - x1 ), self . reactions [ v2 ]: ( coordinate - x1 ) / ( x2 - x1 ), } continue raise ValueError ( \"No reactions found!\" ) def get_coords_in_range ( self , x1 , x2 ): \"\"\" Get the coordinates in the range [x1, x2]. Args: x1: Start of range. x2: End of range. Returns: Array of coordinates in the range. \"\"\" x_min , x_max = sorted ([ x1 , x2 ]) y_min , y_max = self . get_hull_energy ( x_min ), self . get_hull_energy ( x_max ) coords = [] if np . isclose ( x_min , 0.0 ) and not np . isclose ( y_min , 0.0 ): coords . append ([ 0.0 , 0.0 ]) coords . append ([ x_min , y_min ]) coords . extend ( [ self . coords [ i ] for i in self . hull_vertices if self . coords [ i , 0 ] < x_max and self . coords [ i , 0 ] > x_min and self . coords [ i , 1 ] <= 0 ] ) if x_max != x_min : coords . append ([ x_max , y_max ]) if np . isclose ( x_max , 1.0 ) and not np . isclose ( y_max , 0.0 ): coords . append ([ 1.0 , 0.0 ]) coords = np . array ( coords ) return coords [ coords [:, 0 ] . argsort ()] def _get_scatter ( self ): marker_size = 10 pts = px . scatter ( x = self . coords [:, 0 ], y = self . coords [:, 1 ], hover_name = [ str ( r ) for r in self . reactions ], labels = { \"x\" : \"Mixing Ratio\" , \"y\" : ( r \"$\\Delta G_{\\mathrm {rxn} } ~\" r \" \\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ), }, ) pts . update_traces ( marker = { \"size\" : marker_size }) return pts . data [ 0 ] def _get_lines ( self ): coords = self . coords [ self . hull . simplices ] coords = coords [( coords [:, :, 1 ] <= 0 ) . all ( axis = 1 )] coords = coords [ ~ ( coords [:, :, 1 ] == 0 ) . all ( axis = 1 )] lines = [ px . line ( x = c [:, 0 ], y = c [:, 1 ]) for c in coords if not ( c [:, 1 ] == 0 ) . all () ] line_data = [] for line in lines : line . update_traces ( line = { \"color\" : \"black\" }) line_data . append ( line . data [ 0 ]) return line_data @cached_property def hull_vertices ( self ): hull_vertices = [ i for i in self . hull . vertices if self . coords [ i , 1 ] <= 0 and np . isclose ( self . coords [ self . coords [:, 0 ] == self . coords [ i , 0 ]][:, 1 ] . min (), self . coords [ i , 1 ], # make sure point is lower than others on same x ) ] return np . array ( hull_vertices ) @cached_property def stable_reactions ( self ): \"\"\" Returns the reactions that are stable (on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i in self . hull_vertices ] @cached_property def unstable_reactions ( self ): \"\"\" Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i not in self . hull_vertices ] __init__ ( c1 , c2 , reactions , max_num_constraints = 1 ) Parameters: Name Type Description Default c1 Composition Composition of reactant 1 required c2 Composition Composition of reactant 2 required reactions List [ ComputedReaction ] List of reactions containing all enumerated reactions between the two reactants. Note that this list should required Source code in rxn_network/reactions/hull.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , c1 : Composition , c2 : Composition , reactions : List [ ComputedReaction ], max_num_constraints = 1 , ): \"\"\" Args: c1: Composition of reactant 1 c2: Composition of reactant 2 reactions: List of reactions containing all enumerated reactions between the two reactants. Note that this list should \"\"\" self . c1 = Composition ( c1 ) . reduced_composition self . c2 = Composition ( c2 ) . reduced_composition self . e1 = None self . e2 = None for rxn in reactions : for e in rxn . reactant_entries : if e . composition . reduced_composition == self . c1 : self . e1 = e elif e . composition . reduced_composition == self . c2 : self . e2 = e if self . e1 is not None and self . e2 is not None : break else : print ( c1 , c2 ) print ( reactions ) raise ValueError ( \"Provided reactions do not correspond to reactant compositons!\" ) reactions = [ r for r in reactions if r . data . get ( \"num_constraints\" , 1 ) <= max_num_constraints ] endpoint_reactions = [ ComputedReaction . balance ([ self . e1 ], [ self . e1 ]), ComputedReaction . balance ([ self . e2 ], [ self . e2 ]), ] reactions_with_endpoints = reactions + endpoint_reactions coords = np . array ( [( self . get_coordinate ( r ), r . energy_per_atom ) for r in reactions ] ) coords = np . append ( coords , [[ 0 , 0 ], [ 1 , 0 ]], axis = 0 ) idx_sort = coords [:, 0 ] . argsort () self . coords = coords [ idx_sort ] self . reactions = [ reactions_with_endpoints [ i ] for i in idx_sort ] self . hull = ConvexHull ( self . coords ) self . endpoint_reactions = endpoint_reactions get_coordinate ( reaction ) Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction. Source code in rxn_network/reactions/hull.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_coordinate ( self , reaction ): \"\"\"Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction.\"\"\" amt_c1 = reaction . reactant_atomic_fractions . get ( self . c1 , 0 ) amt_c2 = reaction . reactant_atomic_fractions . get ( self . c2 , 0 ) total = amt_c1 + amt_c2 # will add to 1.0 with two-component reactions try : coordinate = amt_c2 / total except ZeroDivisionError as e : raise ValueError ( f \"Can't compute coordinate for { reaction } with { self . c1 } , { self . c2 } \" ) from e return round ( coordinate , 12 ) # avoids numerical issues get_coords_in_range ( x1 , x2 ) Get the coordinates in the range [x1, x2]. Parameters: Name Type Description Default x1 Start of range. required x2 End of range. required Returns: Type Description Array of coordinates in the range. Source code in rxn_network/reactions/hull.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_coords_in_range ( self , x1 , x2 ): \"\"\" Get the coordinates in the range [x1, x2]. Args: x1: Start of range. x2: End of range. Returns: Array of coordinates in the range. \"\"\" x_min , x_max = sorted ([ x1 , x2 ]) y_min , y_max = self . get_hull_energy ( x_min ), self . get_hull_energy ( x_max ) coords = [] if np . isclose ( x_min , 0.0 ) and not np . isclose ( y_min , 0.0 ): coords . append ([ 0.0 , 0.0 ]) coords . append ([ x_min , y_min ]) coords . extend ( [ self . coords [ i ] for i in self . hull_vertices if self . coords [ i , 0 ] < x_max and self . coords [ i , 0 ] > x_min and self . coords [ i , 1 ] <= 0 ] ) if x_max != x_min : coords . append ([ x_max , y_max ]) if np . isclose ( x_max , 1.0 ) and not np . isclose ( y_max , 0.0 ): coords . append ([ 1.0 , 0.0 ]) coords = np . array ( coords ) return coords [ coords [:, 0 ] . argsort ()] get_energy_above_hull ( reaction ) Get the energy of a reaction above the reaction hull. Source code in rxn_network/reactions/hull.py 104 105 106 107 108 109 110 111 112 def get_energy_above_hull ( self , reaction ): \"\"\" Get the energy of a reaction above the reaction hull. \"\"\" idx = self . reactions . index ( reaction ) x , y = self . coords [ idx ] e_above_hull = y - self . get_hull_energy ( x ) return e_above_hull get_hull_energy ( coordinate ) Get the energy of the reaction at a given coordinate. Parameters: Name Type Description Default coordinate Coordinate of reaction in reaction hull. required Returns: Type Description Energy of reaction at given coordinate. Source code in rxn_network/reactions/hull.py 129 130 131 132 133 134 135 136 137 138 139 140 def get_hull_energy ( self , coordinate ): \"\"\" Get the energy of the reaction at a given coordinate. Args: coordinate: Coordinate of reaction in reaction hull. Returns: Energy of reaction at given coordinate. \"\"\" reactions = self . get_reactions_by_coordinate ( coordinate ) return sum ( weight * r . energy_per_atom for r , weight in reactions . items ()) get_reactions_by_coordinate ( coordinate ) Get the reaction(s) at a given coordinate. Source code in rxn_network/reactions/hull.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def get_reactions_by_coordinate ( self , coordinate ): \"\"\"Get the reaction(s) at a given coordinate.\"\"\" sorted_vertices = np . sort ( self . hull_vertices ) for i in range ( len ( sorted_vertices ) - 1 ): v1 = sorted_vertices [ i ] v2 = sorted_vertices [ i + 1 ] x1 = self . coords [ v1 , 0 ] x2 = self . coords [ v2 , 0 ] if np . isclose ( coordinate , x1 ): return { self . reactions [ v1 ]: 1.0 } if np . isclose ( coordinate , x2 ): return { self . reactions [ v2 ]: 1.0 } if x1 < coordinate < x2 : return { self . reactions [ v1 ]: ( x2 - coordinate ) / ( x2 - x1 ), self . reactions [ v2 ]: ( coordinate - x1 ) / ( x2 - x1 ), } continue raise ValueError ( \"No reactions found!\" ) plot ( y_max = 0.2 ) Plot the reaction hull. Source code in rxn_network/reactions/hull.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def plot ( self , y_max = 0.2 ): \"\"\" Plot the reaction hull. \"\"\" pts = self . _get_scatter () lines = self . _get_lines () fig = Figure ( data = lines + [ pts ]) fig . update_traces ( hovertemplate = ( \"<b>% {hovertext} </b><br> <br><b>Atomic fraction</b>:\" \" % {x:.3f} <br><b>Energy</b>: % {y:.3f} (eV/atom)\" ) ) fig . update_layout ( yaxis_range = [ min ( self . coords [:, 1 ]) - 0.01 , y_max ]) fig . update_layout ( xaxis_title = \"Mixing ratio\" ) fig . update_layout ( yaxis_title = \"Energy (eV/atom)\" ) return fig stable_reactions () property cached Returns the reactions that are stable (on the convex hull) of the interface reaction hull. Source code in rxn_network/reactions/hull.py 257 258 259 260 261 262 263 @cached_property def stable_reactions ( self ): \"\"\" Returns the reactions that are stable (on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i in self . hull_vertices ] unstable_reactions () property cached Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. Source code in rxn_network/reactions/hull.py 265 266 267 268 269 270 271 @cached_property def unstable_reactions ( self ): \"\"\" Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i not in self . hull_vertices ]","title":"Hull"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull","text":"Bases: MSONable A class for storing and analyzing a set of reactions at an interface between two reactants. This class is more generalized than the InterfacialReactivity class and can encompass any set of reactions between two reactants, regardless of whether the reaction products are \"stable\" (i.e. together on the convex hull) Source code in rxn_network/reactions/hull.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 class InterfaceReactionHull ( MSONable ): \"\"\" A class for storing and analyzing a set of reactions at an interface between two reactants. This class is more generalized than the InterfacialReactivity class and can encompass any set of reactions between two reactants, regardless of whether the reaction products are \"stable\" (i.e. together on the convex hull) \"\"\" def __init__ ( self , c1 : Composition , c2 : Composition , reactions : List [ ComputedReaction ], max_num_constraints = 1 , ): \"\"\" Args: c1: Composition of reactant 1 c2: Composition of reactant 2 reactions: List of reactions containing all enumerated reactions between the two reactants. Note that this list should \"\"\" self . c1 = Composition ( c1 ) . reduced_composition self . c2 = Composition ( c2 ) . reduced_composition self . e1 = None self . e2 = None for rxn in reactions : for e in rxn . reactant_entries : if e . composition . reduced_composition == self . c1 : self . e1 = e elif e . composition . reduced_composition == self . c2 : self . e2 = e if self . e1 is not None and self . e2 is not None : break else : print ( c1 , c2 ) print ( reactions ) raise ValueError ( \"Provided reactions do not correspond to reactant compositons!\" ) reactions = [ r for r in reactions if r . data . get ( \"num_constraints\" , 1 ) <= max_num_constraints ] endpoint_reactions = [ ComputedReaction . balance ([ self . e1 ], [ self . e1 ]), ComputedReaction . balance ([ self . e2 ], [ self . e2 ]), ] reactions_with_endpoints = reactions + endpoint_reactions coords = np . array ( [( self . get_coordinate ( r ), r . energy_per_atom ) for r in reactions ] ) coords = np . append ( coords , [[ 0 , 0 ], [ 1 , 0 ]], axis = 0 ) idx_sort = coords [:, 0 ] . argsort () self . coords = coords [ idx_sort ] self . reactions = [ reactions_with_endpoints [ i ] for i in idx_sort ] self . hull = ConvexHull ( self . coords ) self . endpoint_reactions = endpoint_reactions def plot ( self , y_max = 0.2 ): \"\"\" Plot the reaction hull. \"\"\" pts = self . _get_scatter () lines = self . _get_lines () fig = Figure ( data = lines + [ pts ]) fig . update_traces ( hovertemplate = ( \"<b>% {hovertext} </b><br> <br><b>Atomic fraction</b>:\" \" % {x:.3f} <br><b>Energy</b>: % {y:.3f} (eV/atom)\" ) ) fig . update_layout ( yaxis_range = [ min ( self . coords [:, 1 ]) - 0.01 , y_max ]) fig . update_layout ( xaxis_title = \"Mixing ratio\" ) fig . update_layout ( yaxis_title = \"Energy (eV/atom)\" ) return fig def get_energy_above_hull ( self , reaction ): \"\"\" Get the energy of a reaction above the reaction hull. \"\"\" idx = self . reactions . index ( reaction ) x , y = self . coords [ idx ] e_above_hull = y - self . get_hull_energy ( x ) return e_above_hull def get_coordinate ( self , reaction ): \"\"\"Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction.\"\"\" amt_c1 = reaction . reactant_atomic_fractions . get ( self . c1 , 0 ) amt_c2 = reaction . reactant_atomic_fractions . get ( self . c2 , 0 ) total = amt_c1 + amt_c2 # will add to 1.0 with two-component reactions try : coordinate = amt_c2 / total except ZeroDivisionError as e : raise ValueError ( f \"Can't compute coordinate for { reaction } with { self . c1 } , { self . c2 } \" ) from e return round ( coordinate , 12 ) # avoids numerical issues def get_hull_energy ( self , coordinate ): \"\"\" Get the energy of the reaction at a given coordinate. Args: coordinate: Coordinate of reaction in reaction hull. Returns: Energy of reaction at given coordinate. \"\"\" reactions = self . get_reactions_by_coordinate ( coordinate ) return sum ( weight * r . energy_per_atom for r , weight in reactions . items ()) def get_reactions_by_coordinate ( self , coordinate ): \"\"\"Get the reaction(s) at a given coordinate.\"\"\" sorted_vertices = np . sort ( self . hull_vertices ) for i in range ( len ( sorted_vertices ) - 1 ): v1 = sorted_vertices [ i ] v2 = sorted_vertices [ i + 1 ] x1 = self . coords [ v1 , 0 ] x2 = self . coords [ v2 , 0 ] if np . isclose ( coordinate , x1 ): return { self . reactions [ v1 ]: 1.0 } if np . isclose ( coordinate , x2 ): return { self . reactions [ v2 ]: 1.0 } if x1 < coordinate < x2 : return { self . reactions [ v1 ]: ( x2 - coordinate ) / ( x2 - x1 ), self . reactions [ v2 ]: ( coordinate - x1 ) / ( x2 - x1 ), } continue raise ValueError ( \"No reactions found!\" ) def get_coords_in_range ( self , x1 , x2 ): \"\"\" Get the coordinates in the range [x1, x2]. Args: x1: Start of range. x2: End of range. Returns: Array of coordinates in the range. \"\"\" x_min , x_max = sorted ([ x1 , x2 ]) y_min , y_max = self . get_hull_energy ( x_min ), self . get_hull_energy ( x_max ) coords = [] if np . isclose ( x_min , 0.0 ) and not np . isclose ( y_min , 0.0 ): coords . append ([ 0.0 , 0.0 ]) coords . append ([ x_min , y_min ]) coords . extend ( [ self . coords [ i ] for i in self . hull_vertices if self . coords [ i , 0 ] < x_max and self . coords [ i , 0 ] > x_min and self . coords [ i , 1 ] <= 0 ] ) if x_max != x_min : coords . append ([ x_max , y_max ]) if np . isclose ( x_max , 1.0 ) and not np . isclose ( y_max , 0.0 ): coords . append ([ 1.0 , 0.0 ]) coords = np . array ( coords ) return coords [ coords [:, 0 ] . argsort ()] def _get_scatter ( self ): marker_size = 10 pts = px . scatter ( x = self . coords [:, 0 ], y = self . coords [:, 1 ], hover_name = [ str ( r ) for r in self . reactions ], labels = { \"x\" : \"Mixing Ratio\" , \"y\" : ( r \"$\\Delta G_{\\mathrm {rxn} } ~\" r \" \\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ), }, ) pts . update_traces ( marker = { \"size\" : marker_size }) return pts . data [ 0 ] def _get_lines ( self ): coords = self . coords [ self . hull . simplices ] coords = coords [( coords [:, :, 1 ] <= 0 ) . all ( axis = 1 )] coords = coords [ ~ ( coords [:, :, 1 ] == 0 ) . all ( axis = 1 )] lines = [ px . line ( x = c [:, 0 ], y = c [:, 1 ]) for c in coords if not ( c [:, 1 ] == 0 ) . all () ] line_data = [] for line in lines : line . update_traces ( line = { \"color\" : \"black\" }) line_data . append ( line . data [ 0 ]) return line_data @cached_property def hull_vertices ( self ): hull_vertices = [ i for i in self . hull . vertices if self . coords [ i , 1 ] <= 0 and np . isclose ( self . coords [ self . coords [:, 0 ] == self . coords [ i , 0 ]][:, 1 ] . min (), self . coords [ i , 1 ], # make sure point is lower than others on same x ) ] return np . array ( hull_vertices ) @cached_property def stable_reactions ( self ): \"\"\" Returns the reactions that are stable (on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i in self . hull_vertices ] @cached_property def unstable_reactions ( self ): \"\"\" Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i not in self . hull_vertices ]","title":"InterfaceReactionHull"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.__init__","text":"Parameters: Name Type Description Default c1 Composition Composition of reactant 1 required c2 Composition Composition of reactant 2 required reactions List [ ComputedReaction ] List of reactions containing all enumerated reactions between the two reactants. Note that this list should required Source code in rxn_network/reactions/hull.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 def __init__ ( self , c1 : Composition , c2 : Composition , reactions : List [ ComputedReaction ], max_num_constraints = 1 , ): \"\"\" Args: c1: Composition of reactant 1 c2: Composition of reactant 2 reactions: List of reactions containing all enumerated reactions between the two reactants. Note that this list should \"\"\" self . c1 = Composition ( c1 ) . reduced_composition self . c2 = Composition ( c2 ) . reduced_composition self . e1 = None self . e2 = None for rxn in reactions : for e in rxn . reactant_entries : if e . composition . reduced_composition == self . c1 : self . e1 = e elif e . composition . reduced_composition == self . c2 : self . e2 = e if self . e1 is not None and self . e2 is not None : break else : print ( c1 , c2 ) print ( reactions ) raise ValueError ( \"Provided reactions do not correspond to reactant compositons!\" ) reactions = [ r for r in reactions if r . data . get ( \"num_constraints\" , 1 ) <= max_num_constraints ] endpoint_reactions = [ ComputedReaction . balance ([ self . e1 ], [ self . e1 ]), ComputedReaction . balance ([ self . e2 ], [ self . e2 ]), ] reactions_with_endpoints = reactions + endpoint_reactions coords = np . array ( [( self . get_coordinate ( r ), r . energy_per_atom ) for r in reactions ] ) coords = np . append ( coords , [[ 0 , 0 ], [ 1 , 0 ]], axis = 0 ) idx_sort = coords [:, 0 ] . argsort () self . coords = coords [ idx_sort ] self . reactions = [ reactions_with_endpoints [ i ] for i in idx_sort ] self . hull = ConvexHull ( self . coords ) self . endpoint_reactions = endpoint_reactions","title":"__init__()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.get_coordinate","text":"Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction. Source code in rxn_network/reactions/hull.py 114 115 116 117 118 119 120 121 122 123 124 125 126 127 def get_coordinate ( self , reaction ): \"\"\"Get coordinate of reaction in reaction hull. This is expressed as the atomic mixing ratio of component 2 in the reaction.\"\"\" amt_c1 = reaction . reactant_atomic_fractions . get ( self . c1 , 0 ) amt_c2 = reaction . reactant_atomic_fractions . get ( self . c2 , 0 ) total = amt_c1 + amt_c2 # will add to 1.0 with two-component reactions try : coordinate = amt_c2 / total except ZeroDivisionError as e : raise ValueError ( f \"Can't compute coordinate for { reaction } with { self . c1 } , { self . c2 } \" ) from e return round ( coordinate , 12 ) # avoids numerical issues","title":"get_coordinate()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.get_coords_in_range","text":"Get the coordinates in the range [x1, x2]. Parameters: Name Type Description Default x1 Start of range. required x2 End of range. required Returns: Type Description Array of coordinates in the range. Source code in rxn_network/reactions/hull.py 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 def get_coords_in_range ( self , x1 , x2 ): \"\"\" Get the coordinates in the range [x1, x2]. Args: x1: Start of range. x2: End of range. Returns: Array of coordinates in the range. \"\"\" x_min , x_max = sorted ([ x1 , x2 ]) y_min , y_max = self . get_hull_energy ( x_min ), self . get_hull_energy ( x_max ) coords = [] if np . isclose ( x_min , 0.0 ) and not np . isclose ( y_min , 0.0 ): coords . append ([ 0.0 , 0.0 ]) coords . append ([ x_min , y_min ]) coords . extend ( [ self . coords [ i ] for i in self . hull_vertices if self . coords [ i , 0 ] < x_max and self . coords [ i , 0 ] > x_min and self . coords [ i , 1 ] <= 0 ] ) if x_max != x_min : coords . append ([ x_max , y_max ]) if np . isclose ( x_max , 1.0 ) and not np . isclose ( y_max , 0.0 ): coords . append ([ 1.0 , 0.0 ]) coords = np . array ( coords ) return coords [ coords [:, 0 ] . argsort ()]","title":"get_coords_in_range()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.get_energy_above_hull","text":"Get the energy of a reaction above the reaction hull. Source code in rxn_network/reactions/hull.py 104 105 106 107 108 109 110 111 112 def get_energy_above_hull ( self , reaction ): \"\"\" Get the energy of a reaction above the reaction hull. \"\"\" idx = self . reactions . index ( reaction ) x , y = self . coords [ idx ] e_above_hull = y - self . get_hull_energy ( x ) return e_above_hull","title":"get_energy_above_hull()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.get_hull_energy","text":"Get the energy of the reaction at a given coordinate. Parameters: Name Type Description Default coordinate Coordinate of reaction in reaction hull. required Returns: Type Description Energy of reaction at given coordinate. Source code in rxn_network/reactions/hull.py 129 130 131 132 133 134 135 136 137 138 139 140 def get_hull_energy ( self , coordinate ): \"\"\" Get the energy of the reaction at a given coordinate. Args: coordinate: Coordinate of reaction in reaction hull. Returns: Energy of reaction at given coordinate. \"\"\" reactions = self . get_reactions_by_coordinate ( coordinate ) return sum ( weight * r . energy_per_atom for r , weight in reactions . items ())","title":"get_hull_energy()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.get_reactions_by_coordinate","text":"Get the reaction(s) at a given coordinate. Source code in rxn_network/reactions/hull.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 def get_reactions_by_coordinate ( self , coordinate ): \"\"\"Get the reaction(s) at a given coordinate.\"\"\" sorted_vertices = np . sort ( self . hull_vertices ) for i in range ( len ( sorted_vertices ) - 1 ): v1 = sorted_vertices [ i ] v2 = sorted_vertices [ i + 1 ] x1 = self . coords [ v1 , 0 ] x2 = self . coords [ v2 , 0 ] if np . isclose ( coordinate , x1 ): return { self . reactions [ v1 ]: 1.0 } if np . isclose ( coordinate , x2 ): return { self . reactions [ v2 ]: 1.0 } if x1 < coordinate < x2 : return { self . reactions [ v1 ]: ( x2 - coordinate ) / ( x2 - x1 ), self . reactions [ v2 ]: ( coordinate - x1 ) / ( x2 - x1 ), } continue raise ValueError ( \"No reactions found!\" )","title":"get_reactions_by_coordinate()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.plot","text":"Plot the reaction hull. Source code in rxn_network/reactions/hull.py 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 def plot ( self , y_max = 0.2 ): \"\"\" Plot the reaction hull. \"\"\" pts = self . _get_scatter () lines = self . _get_lines () fig = Figure ( data = lines + [ pts ]) fig . update_traces ( hovertemplate = ( \"<b>% {hovertext} </b><br> <br><b>Atomic fraction</b>:\" \" % {x:.3f} <br><b>Energy</b>: % {y:.3f} (eV/atom)\" ) ) fig . update_layout ( yaxis_range = [ min ( self . coords [:, 1 ]) - 0.01 , y_max ]) fig . update_layout ( xaxis_title = \"Mixing ratio\" ) fig . update_layout ( yaxis_title = \"Energy (eV/atom)\" ) return fig","title":"plot()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.stable_reactions","text":"Returns the reactions that are stable (on the convex hull) of the interface reaction hull. Source code in rxn_network/reactions/hull.py 257 258 259 260 261 262 263 @cached_property def stable_reactions ( self ): \"\"\" Returns the reactions that are stable (on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i in self . hull_vertices ]","title":"stable_reactions()"},{"location":"reference/reactions/hull/#rxn_network.reactions.hull.InterfaceReactionHull.unstable_reactions","text":"Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. Source code in rxn_network/reactions/hull.py 265 266 267 268 269 270 271 @cached_property def unstable_reactions ( self ): \"\"\" Returns the reactions that are unstable (NOT on the convex hull) of the interface reaction hull. \"\"\" return [ r for i , r in enumerate ( self . reactions ) if i not in self . hull_vertices ]","title":"unstable_reactions()"},{"location":"reference/reactions/open/","text":"A reaction class that builds reactions based on ComputedEntry objects under the presence of an open entry (e.g. O2), and provides information about reaction thermodynamics computed as changes in grand potential. OpenComputedReaction Bases: ComputedReaction Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential. Source code in rxn_network/reactions/open.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class OpenComputedReaction ( ComputedReaction ): \"\"\" Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , ) -> \"OpenComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Args: reactant_entries: List of reactant entries product_entries: List of product entries chempots: Dict of chemical potentials corresponding to open element(s) data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints entries = list ( reactant_entries ) + list ( product_entries ) kwargs = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** kwargs ) # type: ignore else : rxn = cls ( chempots = chempots , ** kwargs ) # type: ignore return rxn @property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . grand_entries : attr = \"composition\" if isinstance ( entry , GrandPotPDEntry ): attr = \"original_comp\" comp , factor = getattr ( entry , attr ) . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @property def elements ( self ) -> List [ Element ]: \"\"\" List of elements in the reaction \"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ) - set ( self . open_elems ) ) @property def total_chemical_system ( self ) -> str : \"\"\" Chemical system string, including open elements \"\"\" return \"-\" . join ( sorted ([ str ( e ) for e in set ( self . elements ) | set ( self . open_elems )]) ) def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . reactant_coeffs . items () } @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . product_coeffs . items () } @classmethod def from_computed_rxn ( cls , reaction : ComputedReaction , chempots : Dict [ Element , float ] ): return cls ( entries = reaction . entries . copy (), coefficients = reaction . coefficients . copy (), chempots = chempots , data = reaction . data . copy (), lowest_num_errors = reaction . lowest_num_errors , ) def as_dict ( self ) -> dict : \"\"\" Returns a dictionary representation of the reaction. \"\"\" d = super () . as_dict () d [ \"chempots\" ] = { el . symbol : u for el , u in self . chempots . items ()} return d @classmethod def from_dict ( cls , d ): \"\"\" Returns an OpenComputedReaction object from a dictionary representation. \"\"\" d [ \"chempots\" ] = { Element ( symbol ): u for symbol , u in d [ \"chempots\" ] . items ()} return super () . from_dict ( d ) def __repr__ ( self ): cp = f \"( { ',' . join ([ f 'mu_ { e } = { m } ' for e , m in self . chempots . items ()]) } )\" return f \" { super () . __repr__ () } { cp } \" __init__ ( entries , coefficients , chempots , data = None , lowest_num_errors = None ) Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects. required coefficients Union [ np . ndarray , List [ float ]] List of reaction coefficients. required chempots Dict [ Element , float ] Dict of chemical potentials corresponding to open elements required data Optional [ Dict ] Optional dict of data None lowest_num_errors number of \"errors\" encountered during reaction balancing None Source code in rxn_network/reactions/open.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries as_dict () Returns a dictionary representation of the reaction. Source code in rxn_network/reactions/open.py 217 218 219 220 221 222 223 def as_dict ( self ) -> dict : \"\"\" Returns a dictionary representation of the reaction. \"\"\" d = super () . as_dict () d [ \"chempots\" ] = { el . symbol : u for el , u in self . chempots . items ()} return d balance ( reactant_entries , product_entries , chempots , data = None ) classmethod Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Parameters: Name Type Description Default reactant_entries List [ ComputedEntry ] List of reactant entries required product_entries List [ ComputedEntry ] List of product entries required chempots Dict [ Element , float ] Dict of chemical potentials corresponding to open element(s) required data Optional [ Dict ] Optional dict of data None Source code in rxn_network/reactions/open.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , ) -> \"OpenComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Args: reactant_entries: List of reactant entries product_entries: List of product entries chempots: Dict of chemical potentials corresponding to open element(s) data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints entries = list ( reactant_entries ) + list ( product_entries ) kwargs = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** kwargs ) # type: ignore else : rxn = cls ( chempots = chempots , ** kwargs ) # type: ignore return rxn copy () Returns a copy of the OpenComputedReaction object. Source code in rxn_network/reactions/open.py 153 154 155 156 157 158 159 160 161 162 163 def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) elements () property List of elements in the reaction Source code in rxn_network/reactions/open.py 134 135 136 137 138 139 140 141 142 @property def elements ( self ) -> List [ Element ]: \"\"\" List of elements in the reaction \"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ) - set ( self . open_elems ) ) energy () property Returns (float): The calculated reaction energy. Source code in rxn_network/reactions/open.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . grand_entries : attr = \"composition\" if isinstance ( entry , GrandPotPDEntry ): attr = \"original_comp\" comp , factor = getattr ( entry , attr ) . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) from_dict ( d ) classmethod Returns an OpenComputedReaction object from a dictionary representation. Source code in rxn_network/reactions/open.py 225 226 227 228 229 230 231 @classmethod def from_dict ( cls , d ): \"\"\" Returns an OpenComputedReaction object from a dictionary representation. \"\"\" d [ \"chempots\" ] = { Element ( symbol ): u for symbol , u in d [ \"chempots\" ] . items ()} return super () . from_dict ( d ) product_atomic_fractions () property cached Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/open.py 192 193 194 195 196 197 198 199 200 201 202 203 @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . product_coeffs . items () } reactant_atomic_fractions () property cached Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/open.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . reactant_coeffs . items () } reverse () Returns a copy of reaction with reactants/products swapped Source code in rxn_network/reactions/open.py 165 166 167 168 169 170 171 172 173 174 175 def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) total_chemical_system () property Chemical system string, including open elements Source code in rxn_network/reactions/open.py 144 145 146 147 148 149 150 151 @property def total_chemical_system ( self ) -> str : \"\"\" Chemical system string, including open elements \"\"\" return \"-\" . join ( sorted ([ str ( e ) for e in set ( self . elements ) | set ( self . open_elems )]) )","title":"Open"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction","text":"Bases: ComputedReaction Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential. Source code in rxn_network/reactions/open.py 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 class OpenComputedReaction ( ComputedReaction ): \"\"\" Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , ) -> \"OpenComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Args: reactant_entries: List of reactant entries product_entries: List of product entries chempots: Dict of chemical potentials corresponding to open element(s) data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints entries = list ( reactant_entries ) + list ( product_entries ) kwargs = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** kwargs ) # type: ignore else : rxn = cls ( chempots = chempots , ** kwargs ) # type: ignore return rxn @property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . grand_entries : attr = \"composition\" if isinstance ( entry , GrandPotPDEntry ): attr = \"original_comp\" comp , factor = getattr ( entry , attr ) . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) ) @property def elements ( self ) -> List [ Element ]: \"\"\" List of elements in the reaction \"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ) - set ( self . open_elems ) ) @property def total_chemical_system ( self ) -> str : \"\"\" Chemical system string, including open elements \"\"\" return \"-\" . join ( sorted ([ str ( e ) for e in set ( self . elements ) | set ( self . open_elems )]) ) def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . reactant_coeffs . items () } @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . product_coeffs . items () } @classmethod def from_computed_rxn ( cls , reaction : ComputedReaction , chempots : Dict [ Element , float ] ): return cls ( entries = reaction . entries . copy (), coefficients = reaction . coefficients . copy (), chempots = chempots , data = reaction . data . copy (), lowest_num_errors = reaction . lowest_num_errors , ) def as_dict ( self ) -> dict : \"\"\" Returns a dictionary representation of the reaction. \"\"\" d = super () . as_dict () d [ \"chempots\" ] = { el . symbol : u for el , u in self . chempots . items ()} return d @classmethod def from_dict ( cls , d ): \"\"\" Returns an OpenComputedReaction object from a dictionary representation. \"\"\" d [ \"chempots\" ] = { Element ( symbol ): u for symbol , u in d [ \"chempots\" ] . items ()} return super () . from_dict ( d ) def __repr__ ( self ): cp = f \"( { ',' . join ([ f 'mu_ { e } = { m } ' for e , m in self . chempots . items ()]) } )\" return f \" { super () . __repr__ () } { cp } \"","title":"OpenComputedReaction"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.__init__","text":"Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects. required coefficients Union [ np . ndarray , List [ float ]] List of reaction coefficients. required chempots Dict [ Element , float ] Dict of chemical potentials corresponding to open elements required data Optional [ Dict ] Optional dict of data None lowest_num_errors number of \"errors\" encountered during reaction balancing None Source code in rxn_network/reactions/open.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries","title":"__init__()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.as_dict","text":"Returns a dictionary representation of the reaction. Source code in rxn_network/reactions/open.py 217 218 219 220 221 222 223 def as_dict ( self ) -> dict : \"\"\" Returns a dictionary representation of the reaction. \"\"\" d = super () . as_dict () d [ \"chempots\" ] = { el . symbol : u for el , u in self . chempots . items ()} return d","title":"as_dict()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.balance","text":"Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Parameters: Name Type Description Default reactant_entries List [ ComputedEntry ] List of reactant entries required product_entries List [ ComputedEntry ] List of product entries required chempots Dict [ Element , float ] Dict of chemical potentials corresponding to open element(s) required data Optional [ Dict ] Optional dict of data None Source code in rxn_network/reactions/open.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , ) -> \"OpenComputedReaction\" : \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as a collection (list, set, etc.) of ComputedEntry objects. A dictionary of open elements and their corresponding chemical potentials must be supplied. Args: reactant_entries: List of reactant entries product_entries: List of product entries chempots: Dict of chemical potentials corresponding to open element(s) data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors , num_constraints = cls . _balance_coeffs ( reactant_comps , product_comps ) if not data : data = {} data [ \"num_constraints\" ] = num_constraints entries = list ( reactant_entries ) + list ( product_entries ) kwargs = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** kwargs ) # type: ignore else : rxn = cls ( chempots = chempots , ** kwargs ) # type: ignore return rxn","title":"balance()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.copy","text":"Returns a copy of the OpenComputedReaction object. Source code in rxn_network/reactions/open.py 153 154 155 156 157 158 159 160 161 162 163 def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , )","title":"copy()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.elements","text":"List of elements in the reaction Source code in rxn_network/reactions/open.py 134 135 136 137 138 139 140 141 142 @property def elements ( self ) -> List [ Element ]: \"\"\" List of elements in the reaction \"\"\" return list ( set ( el for comp in self . compositions for el in comp . elements ) - set ( self . open_elems ) )","title":"elements()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.energy","text":"Returns (float): The calculated reaction energy. Source code in rxn_network/reactions/open.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 @property def energy ( self ) -> float : \"\"\" Returns (float): The calculated reaction energy. \"\"\" calc_energies : Dict [ Composition , float ] = {} for entry in self . grand_entries : attr = \"composition\" if isinstance ( entry , GrandPotPDEntry ): attr = \"original_comp\" comp , factor = getattr ( entry , attr ) . get_reduced_composition_and_factor () calc_energies [ comp ] = min ( calc_energies . get ( comp , float ( \"inf\" )), entry . energy / factor ) return sum ( amt * calc_energies [ c ] for amt , c in zip ( self . coefficients , self . compositions ) )","title":"energy()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.from_dict","text":"Returns an OpenComputedReaction object from a dictionary representation. Source code in rxn_network/reactions/open.py 225 226 227 228 229 230 231 @classmethod def from_dict ( cls , d ): \"\"\" Returns an OpenComputedReaction object from a dictionary representation. \"\"\" d [ \"chempots\" ] = { Element ( symbol ): u for symbol , u in d [ \"chempots\" ] . items ()} return super () . from_dict ( d )","title":"from_dict()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.product_atomic_fractions","text":"Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/open.py 192 193 194 195 196 197 198 199 200 201 202 203 @cached_property def product_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . product_coeffs . items () }","title":"product_atomic_fractions()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.reactant_atomic_fractions","text":"Returns the atomic mixing ratio of reactants in the reaction Source code in rxn_network/reactions/open.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 @cached_property def reactant_atomic_fractions ( self ) -> dict : \"\"\" Returns the atomic mixing ratio of reactants in the reaction \"\"\" if not self . balanced : raise ValueError ( \"Reaction is not balanced\" ) return { c . reduced_composition : - coeff * sum ( c [ el ] for el in self . elements ) / self . num_atoms for c , coeff in self . reactant_coeffs . items () }","title":"reactant_atomic_fractions()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.reverse","text":"Returns a copy of reaction with reactants/products swapped Source code in rxn_network/reactions/open.py 165 166 167 168 169 170 171 172 173 174 175 def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , )","title":"reverse()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.total_chemical_system","text":"Chemical system string, including open elements Source code in rxn_network/reactions/open.py 144 145 146 147 148 149 150 151 @property def total_chemical_system ( self ) -> str : \"\"\" Chemical system string, including open elements \"\"\" return \"-\" . join ( sorted ([ str ( e ) for e in set ( self . elements ) | set ( self . open_elems )]) )","title":"total_chemical_system()"},{"location":"reference/reactions/plotting/","text":"Utility functions for plotting reaction data/analysis. filter_df_by_precursors ( df , precursors ) Filter a reaction DataFrame by available precursors Source code in rxn_network/reactions/plotting.py 225 226 227 228 229 230 231 232 def filter_df_by_precursors ( df , precursors ): \"\"\"Filter a reaction DataFrame by available precursors\"\"\" df = df . copy () df [ \"precursors\" ] = [ list ( sorted ([ r . reduced_formula for r in rxn . reactants ])) for rxn in df [ \"rxn\" ] ] selected = df [ df [ \"precursors\" ] . apply ( lambda x : all ( p in precursors for p in x ))] return selected . drop ( columns = [ \"precursors\" ]) is_pareto_efficient ( costs , return_mask = True ) Directly borrowed from @Peter's numpy-based solution on stackoverflow. Please give him an upvote here: https://stackoverflow.com/a/40239615 . Thank you @Peter! Find the pareto-efficient points :param costs: An (n_points, n_costs) array :param return_mask: True to return a mask :return: An array of indices of pareto-efficient points. If return_mask is True, this will be an (n_points, ) boolean array Otherwise it will be a (n_efficient_points, ) integer array of indices. Source code in rxn_network/reactions/plotting.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def is_pareto_efficient ( costs , return_mask = True ): \"\"\" Directly borrowed from @Peter's numpy-based solution on stackoverflow. Please give him an upvote here: https://stackoverflow.com/a/40239615. Thank you @Peter! Find the pareto-efficient points :param costs: An (n_points, n_costs) array :param return_mask: True to return a mask :return: An array of indices of pareto-efficient points. If return_mask is True, this will be an (n_points, ) boolean array Otherwise it will be a (n_efficient_points, ) integer array of indices. \"\"\" is_efficient = np . arange ( costs . shape [ 0 ]) n_points = costs . shape [ 0 ] next_point_index = 0 # Next index in the is_efficient array to search for while next_point_index < len ( costs ): nondominated_point_mask = np . any ( costs < costs [ next_point_index ], axis = 1 ) nondominated_point_mask [ next_point_index ] = True is_efficient = is_efficient [ nondominated_point_mask ] # Remove dominated points costs = costs [ nondominated_point_mask ] next_point_index = np . sum ( nondominated_point_mask [: next_point_index ]) + 1 if return_mask : is_efficient_mask = np . zeros ( n_points , dtype = bool ) is_efficient_mask [ is_efficient ] = True return is_efficient_mask return is_efficient plot_reaction_scatter ( df , x = 'energy' , y = 'secondary_selectivity' , z = None , color = 'has_added_elems' , plot_pareto = True ) Plot a Plotly scatter plot of chemical potential distance vs energy. Parameters: Name Type Description Default df DataFrame DataFrame with columns: rxn, energy, distance, added_elems required Returns: Type Description px . scatter Plotly scatter plot Source code in rxn_network/reactions/plotting.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def plot_reaction_scatter ( df : DataFrame , x = \"energy\" , y = \"secondary_selectivity\" , z = None , color = \"has_added_elems\" , plot_pareto = True , ) -> px . scatter : \"\"\" Plot a Plotly scatter plot of chemical potential distance vs energy. Args: df: DataFrame with columns: rxn, energy, distance, added_elems Returns: Plotly scatter plot \"\"\" def get_label_and_units ( name ): label = \"\" units = \"\" if name == \"energy\" : label = ( r \"$\\mathsf{Reaction~driving~force} ~\" r \"\\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ) units = \"eV/atom\" if z is not None : label = \"Reaction Driving Force\" elif name == \"chempot_distance\" : label = ( r \"$\\Sigma \\Delta \\mu_{\\mathrm {min} } ~\" r \" \\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ) if z is not None : label = \"Total chemical potential distance\" units = \"eV/atom\" elif name == \"primary_selectivity\" : label = \"Primary Selectivity\" units = \"a.u.\" elif name == \"secondary_selectivity\" : label = \"Secondary Selectivity\" units = \"eV/atom\" elif name == \"dE\" : label = \"Uncertainty\" units = \"eV/atom\" return label , units df = df . copy () df [ \"rxn\" ] = df [ \"rxn\" ] . astype ( str ) if \"added_elems\" in df : df [ \"has_added_elems\" ] = df [ \"added_elems\" ] != \"\" x_label , x_units = get_label_and_units ( x ) y_label , y_units = get_label_and_units ( y ) z_label , z_units = None , None cols : tuple = ( x , y ) if z is not None : z_label , z_units = get_label_and_units ( z ) cols = ( x , y , z ) if plot_pareto : pareto_df = get_pareto_front ( df , cols = cols ) df = df . loc [ ~ df . index . isin ( pareto_df . index )] arr = pareto_df [ list ( cols )] . to_numpy () if z is None : scatter = go . Scatter ( x = arr [:, 0 ], y = arr [:, 1 ], hovertext = pareto_df [ \"rxn\" ], marker = dict ( size = 10 , color = \"seagreen\" , symbol = \"diamond\" ), mode = \"markers\" , name = \"Pareto front\" , ) else : scatter = go . Scatter3d ( x = arr [:, 0 ], y = arr [:, 1 ], z = arr [:, 2 ], hovertext = pareto_df [ \"rxn\" ], marker = dict ( size = 10 , color = \"seagreen\" , symbol = \"diamond\" ), mode = \"markers\" , name = \"Pareto front\" , ) if z is None : layout_2d = plotly_layouts [ \"default_layout_2d\" ] fig = px . scatter ( df , x = x , y = y , hover_name = \"rxn\" , labels = { x : x_label , y : y_label }, color = color , color_discrete_map = { True : \"darkorange\" , False : \"lightgray\" }, ) fig . update_layout ( layout_2d ) else : layout_3d = plotly_layouts [ \"default_layout_3d\" ] axis_layout = plotly_layouts [ \"default_3d_axis_layout\" ] . copy () axis_layout [ \"titlefont\" ][ \"size\" ] = 14 for t in [ \"xaxis\" , \"yaxis\" , \"zaxis\" ]: layout_3d [ \"scene\" ][ t ] = axis_layout layout_3d [ \"scene_camera\" ] = dict ( eye = dict ( x =- 5 , y =- 5 , z = 5 ), # zoomed out projection = dict ( type = \"orthographic\" ), center = dict ( x =- 0.2 , y =- 0.2 , z =- 0.1 ), ) fig = px . scatter_3d ( df , x = x , y = y , z = z , hover_name = \"rxn\" , labels = { x : x_label , y : y_label , z : z_label }, template = \"simple_white\" , color = color , color_discrete_map = { True : \"darkorange\" , False : \"lightgray\" }, ) fig . update_layout ( layout_3d ) if plot_pareto : fig . add_trace ( scatter ) hovertemplate = ( \"<b>% {hovertext} </b><br>\" + \"<br><b>\" + f \" { x } \" + \"</b>: % {x:.3f} \" + f \" { x_units } \" + \"<br><b>\" + f \" { y } \" + \"</b>: % {y:.3f} \" + f \" { y_units } \" ) if z is not None : hovertemplate = ( hovertemplate + \"<br><b>\" + f \" { z } \" + \"</b>: % {z:.3f} \" + f \" { z_units } <br>\" ) fig . update_traces ( hovertemplate = hovertemplate ) return fig pretty_df_layout ( df ) Improve visibility for a pandas DataFrame with wide column names Source code in rxn_network/reactions/plotting.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def pretty_df_layout ( df ): \"\"\"Improve visibility for a pandas DataFrame with wide column names\"\"\" return df . style . set_table_styles ( [ dict ( selector = \"th\" , props = [ ( \"max-width\" , \"70px\" ), ( \"text-overflow\" , \"ellipsis\" ), ( \"overflow\" , \"hidden\" ), ], ) ] ) # improve rendering in Jupyter","title":"Plotting"},{"location":"reference/reactions/plotting/#rxn_network.reactions.plotting.filter_df_by_precursors","text":"Filter a reaction DataFrame by available precursors Source code in rxn_network/reactions/plotting.py 225 226 227 228 229 230 231 232 def filter_df_by_precursors ( df , precursors ): \"\"\"Filter a reaction DataFrame by available precursors\"\"\" df = df . copy () df [ \"precursors\" ] = [ list ( sorted ([ r . reduced_formula for r in rxn . reactants ])) for rxn in df [ \"rxn\" ] ] selected = df [ df [ \"precursors\" ] . apply ( lambda x : all ( p in precursors for p in x ))] return selected . drop ( columns = [ \"precursors\" ])","title":"filter_df_by_precursors()"},{"location":"reference/reactions/plotting/#rxn_network.reactions.plotting.is_pareto_efficient","text":"Directly borrowed from @Peter's numpy-based solution on stackoverflow. Please give him an upvote here: https://stackoverflow.com/a/40239615 . Thank you @Peter! Find the pareto-efficient points :param costs: An (n_points, n_costs) array :param return_mask: True to return a mask :return: An array of indices of pareto-efficient points. If return_mask is True, this will be an (n_points, ) boolean array Otherwise it will be a (n_efficient_points, ) integer array of indices. Source code in rxn_network/reactions/plotting.py 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 def is_pareto_efficient ( costs , return_mask = True ): \"\"\" Directly borrowed from @Peter's numpy-based solution on stackoverflow. Please give him an upvote here: https://stackoverflow.com/a/40239615. Thank you @Peter! Find the pareto-efficient points :param costs: An (n_points, n_costs) array :param return_mask: True to return a mask :return: An array of indices of pareto-efficient points. If return_mask is True, this will be an (n_points, ) boolean array Otherwise it will be a (n_efficient_points, ) integer array of indices. \"\"\" is_efficient = np . arange ( costs . shape [ 0 ]) n_points = costs . shape [ 0 ] next_point_index = 0 # Next index in the is_efficient array to search for while next_point_index < len ( costs ): nondominated_point_mask = np . any ( costs < costs [ next_point_index ], axis = 1 ) nondominated_point_mask [ next_point_index ] = True is_efficient = is_efficient [ nondominated_point_mask ] # Remove dominated points costs = costs [ nondominated_point_mask ] next_point_index = np . sum ( nondominated_point_mask [: next_point_index ]) + 1 if return_mask : is_efficient_mask = np . zeros ( n_points , dtype = bool ) is_efficient_mask [ is_efficient ] = True return is_efficient_mask return is_efficient","title":"is_pareto_efficient()"},{"location":"reference/reactions/plotting/#rxn_network.reactions.plotting.plot_reaction_scatter","text":"Plot a Plotly scatter plot of chemical potential distance vs energy. Parameters: Name Type Description Default df DataFrame DataFrame with columns: rxn, energy, distance, added_elems required Returns: Type Description px . scatter Plotly scatter plot Source code in rxn_network/reactions/plotting.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 def plot_reaction_scatter ( df : DataFrame , x = \"energy\" , y = \"secondary_selectivity\" , z = None , color = \"has_added_elems\" , plot_pareto = True , ) -> px . scatter : \"\"\" Plot a Plotly scatter plot of chemical potential distance vs energy. Args: df: DataFrame with columns: rxn, energy, distance, added_elems Returns: Plotly scatter plot \"\"\" def get_label_and_units ( name ): label = \"\" units = \"\" if name == \"energy\" : label = ( r \"$\\mathsf{Reaction~driving~force} ~\" r \"\\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ) units = \"eV/atom\" if z is not None : label = \"Reaction Driving Force\" elif name == \"chempot_distance\" : label = ( r \"$\\Sigma \\Delta \\mu_{\\mathrm {min} } ~\" r \" \\mathrm{\\left(\\dfrac{\\mathsf {eV} }{\\mathsf {atom} }\\right)}$\" ) if z is not None : label = \"Total chemical potential distance\" units = \"eV/atom\" elif name == \"primary_selectivity\" : label = \"Primary Selectivity\" units = \"a.u.\" elif name == \"secondary_selectivity\" : label = \"Secondary Selectivity\" units = \"eV/atom\" elif name == \"dE\" : label = \"Uncertainty\" units = \"eV/atom\" return label , units df = df . copy () df [ \"rxn\" ] = df [ \"rxn\" ] . astype ( str ) if \"added_elems\" in df : df [ \"has_added_elems\" ] = df [ \"added_elems\" ] != \"\" x_label , x_units = get_label_and_units ( x ) y_label , y_units = get_label_and_units ( y ) z_label , z_units = None , None cols : tuple = ( x , y ) if z is not None : z_label , z_units = get_label_and_units ( z ) cols = ( x , y , z ) if plot_pareto : pareto_df = get_pareto_front ( df , cols = cols ) df = df . loc [ ~ df . index . isin ( pareto_df . index )] arr = pareto_df [ list ( cols )] . to_numpy () if z is None : scatter = go . Scatter ( x = arr [:, 0 ], y = arr [:, 1 ], hovertext = pareto_df [ \"rxn\" ], marker = dict ( size = 10 , color = \"seagreen\" , symbol = \"diamond\" ), mode = \"markers\" , name = \"Pareto front\" , ) else : scatter = go . Scatter3d ( x = arr [:, 0 ], y = arr [:, 1 ], z = arr [:, 2 ], hovertext = pareto_df [ \"rxn\" ], marker = dict ( size = 10 , color = \"seagreen\" , symbol = \"diamond\" ), mode = \"markers\" , name = \"Pareto front\" , ) if z is None : layout_2d = plotly_layouts [ \"default_layout_2d\" ] fig = px . scatter ( df , x = x , y = y , hover_name = \"rxn\" , labels = { x : x_label , y : y_label }, color = color , color_discrete_map = { True : \"darkorange\" , False : \"lightgray\" }, ) fig . update_layout ( layout_2d ) else : layout_3d = plotly_layouts [ \"default_layout_3d\" ] axis_layout = plotly_layouts [ \"default_3d_axis_layout\" ] . copy () axis_layout [ \"titlefont\" ][ \"size\" ] = 14 for t in [ \"xaxis\" , \"yaxis\" , \"zaxis\" ]: layout_3d [ \"scene\" ][ t ] = axis_layout layout_3d [ \"scene_camera\" ] = dict ( eye = dict ( x =- 5 , y =- 5 , z = 5 ), # zoomed out projection = dict ( type = \"orthographic\" ), center = dict ( x =- 0.2 , y =- 0.2 , z =- 0.1 ), ) fig = px . scatter_3d ( df , x = x , y = y , z = z , hover_name = \"rxn\" , labels = { x : x_label , y : y_label , z : z_label }, template = \"simple_white\" , color = color , color_discrete_map = { True : \"darkorange\" , False : \"lightgray\" }, ) fig . update_layout ( layout_3d ) if plot_pareto : fig . add_trace ( scatter ) hovertemplate = ( \"<b>% {hovertext} </b><br>\" + \"<br><b>\" + f \" { x } \" + \"</b>: % {x:.3f} \" + f \" { x_units } \" + \"<br><b>\" + f \" { y } \" + \"</b>: % {y:.3f} \" + f \" { y_units } \" ) if z is not None : hovertemplate = ( hovertemplate + \"<br><b>\" + f \" { z } \" + \"</b>: % {z:.3f} \" + f \" { z_units } <br>\" ) fig . update_traces ( hovertemplate = hovertemplate ) return fig","title":"plot_reaction_scatter()"},{"location":"reference/reactions/plotting/#rxn_network.reactions.plotting.pretty_df_layout","text":"Improve visibility for a pandas DataFrame with wide column names Source code in rxn_network/reactions/plotting.py 209 210 211 212 213 214 215 216 217 218 219 220 221 222 def pretty_df_layout ( df ): \"\"\"Improve visibility for a pandas DataFrame with wide column names\"\"\" return df . style . set_table_styles ( [ dict ( selector = \"th\" , props = [ ( \"max-width\" , \"70px\" ), ( \"text-overflow\" , \"ellipsis\" ), ( \"overflow\" , \"hidden\" ), ], ) ] ) # improve rendering in Jupyter","title":"pretty_df_layout()"},{"location":"reference/reactions/reaction_set/","text":"Implements a class for conveniently and efficiently storing sets of ComputedReaction objects which share entries. ReactionSet Bases: MSONable A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries. This is useful for dumping large amounts of reaction data to a database. this is not a true \"set\"; there is the option for filtering duplicates but it is not explicitly required. Source code in rxn_network/reactions/reaction_set.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class ReactionSet ( MSONable ): \"\"\" A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries. This is useful for dumping large amounts of reaction data to a database. Note: this is not a true \"set\"; there is the option for filtering duplicates but it is not explicitly required. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients open_elem: Open element, e.g., \"O\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . open_elem = open_elem self . chempot = chempot self . all_data = all_data if all_data else [] self . mu_dict = None if open_elem : self . mu_dict = { Element ( open_elem ): chempot } # type: ignore def get_rxns ( self , ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. \"\"\" return self . _get_rxns_by_indices ( idxs = range ( len ( self . coeffs ))) @classmethod def from_rxns ( cls , rxns : Collection [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Collection [ ComputedEntry ]] = None , open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , filter_duplicates : bool = False , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_entry_indices : Dict [ str , ComputedEntry ] = {} indices , coeffs , data = [], [], [] for rxn in rxns : rxn_indices = [] for e in rxn . entries : idx = all_entry_indices . get ( e . composition . reduced_formula ) if idx is None : idx = entries . index ( e ) all_entry_indices [ e . composition . reduced_formula ] = idx rxn_indices . append ( idx ) indices . append ( rxn_indices ) coeffs . append ( list ( rxn . coefficients )) data . append ( rxn . data ) all_open_elems : Set [ Element ] = set () all_chempots : Set [ float ] = set () if ( all ( r . __class__ . __name__ == \"OpenComputedReaction\" for r in rxns ) and not open_elem ): for r in rxns : all_open_elems . update ( r . chempots . keys ()) all_chempots . update ( r . chempots . values ()) if len ( all_chempots ) == 1 and len ( all_open_elems ) == 1 : chempot = all_chempots . pop () open_elem = all_open_elems . pop () rxn_set = cls ( entries = entries , indices = indices , coeffs = coeffs , open_elem = open_elem , chempot = chempot , all_data = data , ) if filter_duplicates : rxn_set = rxn_set . filter_duplicates () return rxn_set @lru_cache ( maxsize = 1 ) def to_dataframe ( self , cost_function : CostFunction , target : Optional [ Composition ] = None , calculate_uncertainties = False , calculate_separable = False , ) -> DataFrame : \"\"\" Make a dataframe of reactions from a ReactionSet object. Args: cost_function: Cost function to use for evaluating reaction costs target: Optional target composition (used to determine added elements) calculate_uncertainties: Whether to calculate uncertainties (dE column) calculate_separable: Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) Returns: Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction \"\"\" data : Dict [ str , Any ] = OrderedDict ({ k : [] for k in [ \"rxn\" , \"energy\" ]}) attrs = [] calculate_e_above_hulls = False determine_theoretical = False for r in self . get_rxns (): attrs = list ( r . data . keys ()) # get extra attributes from first reaction entry_data = r . entries [ 0 ] . data if \"e_above_hull\" in entry_data : calculate_e_above_hulls = True data [ \"max_e_hull_reactants\" ] = [] data [ \"max_e_hull_products\" ] = [] if \"icsd_ids\" in entry_data or \"theoretical\" in entry_data : determine_theoretical = True data [ \"num_theoretical_reactants\" ] = [] data [ \"num_theoretical_products\" ] = [] break target = Composition ( target ) if target else None if \"num_constraints\" in attrs : attrs . remove ( \"num_constraints\" ) if calculate_uncertainties : data [ \"dE\" ] = [] if target : data [ \"added_elems\" ] = [] if calculate_separable : data [ \"separable\" ] = [] data [ \"max_num_precursor_elems\" ] = [] data . update ({ k : [] for k in attrs + [ \"cost\" ]}) for rxn in self . get_rxns (): data [ \"rxn\" ] . append ( rxn ) data [ \"energy\" ] . append ( rxn . energy_per_atom ) if calculate_uncertainties : data [ \"dE\" ] . append ( rxn . energy_uncertainty_per_atom ) if target : data [ \"added_elems\" ] . append ( self . _get_added_elems ( rxn , target )) if calculate_separable : data [ \"separable\" ] . append ( rxn . is_separable ( target )) if calculate_e_above_hulls : data [ \"max_e_hull_reactants\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . reactant_entries ) ) data [ \"max_e_hull_products\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . product_entries ) ) if determine_theoretical : data [ \"num_theoretical_reactants\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . reactant_entries ) ) data [ \"num_theoretical_products\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . product_entries ) ) data [ \"max_num_precursor_elems\" ] . append ( max ( len ( precursor . elements ) for precursor in rxn . reactants ) ) for attr in attrs : data [ attr ] . append ( rxn . data . get ( attr )) data [ \"cost\" ] . append ( cost_function . evaluate ( rxn )) df = DataFrame ( data ) . sort_values ( \"cost\" ) . reset_index ( drop = True ) return df def calculate_costs ( self , cf : CostFunction , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ()] def add_rxns ( self , rxns ): \"\"\" Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. \"\"\" new_indices , new_coeffs , new_data = [], [], [] for rxn in rxns : new_indices . append ([ self . entries . index ( e ) for e in rxn . entries ]) new_coeffs . append ( list ( rxn . coefficients )) new_data . append ( rxn . data ) return ReactionSet ( self . entries , self . indices + new_indices , self . coeffs + new_coeffs , self . open_elem , self . chempot , self . all_data + new_data , ) def add_rxn_set ( self , rxn_set ): \"\"\"Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. \"\"\" if self . entries != rxn_set . entries : raise ValueError ( \"Reaction sets must have identical entries property to add.\" ) open_elem = self . open_elem chempot = self . chempot indices = self . indices + rxn_set . indices coeffs = self . coeffs + rxn_set . coeffs all_data = self . all_data + rxn_set . all_data return ReactionSet ( self . entries , indices , coeffs , open_elem , chempot , all_data ) def get_rxns_by_reactants ( self , reactants : List [ str ]): \"\"\" Return a list of reactions with the given reactants. \"\"\" idxs = [] reactants = [ Composition ( r ) . reduced_formula for r in reactants ] reactant_indices = { idx for idx , e in enumerate ( self . entries ) if e . composition . reduced_formula in reactants } if not reactant_indices : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): r_indices = { i for c , i in zip ( coeffs , indices ) if c < 1e-12 } if r_indices . issubset ( reactant_indices ): idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) def get_rxns_by_product ( self , product : str ): \"\"\" Return a list of reactions which contain the given product formula. \"\"\" idxs = [] product = Composition ( product ) . reduced_formula product_index = None for idx , e in enumerate ( self . entries ): if e . composition . reduced_formula == product : product_index = idx break if not product_index : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): p_indices = { i for c , i in zip ( coeffs , indices ) if c > - 1e-12 } if product_index in p_indices : idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) def filter_duplicates ( self ): \"\"\" Return a new ReactionSet object with duplicate reactions removed \"\"\" indices_to_remove = set () if len ( self . coeffs ) == 0 : return self # groupby only works with pre-sorted arrays sorted_coeffs , sorted_idxs , sorted_indices = zip ( * list ( sorted ( zip ( self . coeffs , range ( len ( self . indices )), self . indices ), key = lambda x : sorted ( x [ 2 ]), ) ) ) for i , group in groupby ( zip ( sorted_coeffs , sorted_idxs , sorted_indices ), key = lambda i : sorted ( i [ 2 ]), ): coeffs_group , idx_group , indices_group = zip ( * group ) if len ( idx_group ) > 1 : for ( _ , coeffs1 , indices1 ), ( idx2 , coeffs2 , indices2 , ) in combinations ( zip ( idx_group , coeffs_group , indices_group ), 2 ): if idx2 in indices_to_remove : continue coeffs2_sorted = [ coeffs2 [ indices2 . index ( i )] for i in indices1 ] ratios = np . array ( coeffs1 ) / np . array ( coeffs2_sorted ) if ( ratios <= 1e-8 ) . any (): # do not remove any reaction with negative ratio continue if np . isclose ( ratios [ 0 ], ratios ) . all (): indices_to_remove . add ( idx2 ) new_indices = [] new_coeffs = [] new_all_data = [] for idx in set ( range ( len ( self ))) - indices_to_remove : new_indices . append ( self . indices [ idx ]) new_coeffs . append ( self . coeffs [ idx ]) new_all_data . append ( self . all_data [ idx ]) return ReactionSet ( self . entries , new_indices , new_coeffs , self . open_elem , self . chempot , new_all_data , ) def _get_rxns_by_indices ( self , idxs : Union [ List [ int ], range ] ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Return a list of reactions with the given indices. \"\"\" if idxs == range ( len ( self . coeffs )): indices_slice = self . indices coeffs_slice = self . coeffs data_slice = self . all_data else : indices_slice = [] coeffs_slice = [] data_slice = [] for idx in idxs : indices_slice . append ( self . indices [ idx ]) coeffs_slice . append ( self . coeffs [ idx ]) data_slice . append ( self . all_data [ idx ]) for indices , coeffs , data in zip ( indices_slice , coeffs_slice , data_slice ): entries = [ self . entries [ i ] for i in indices ] if self . mu_dict : rxn = OpenComputedReaction ( entries = entries , coefficients = coeffs , data = data , chempots = self . mu_dict , ) else : rxn = ComputedReaction ( entries = entries , coefficients = coeffs , data = data ) yield rxn @staticmethod def _get_added_elems ( rxn : Union [ ComputedReaction , OpenComputedReaction ], target : Composition ) -> str : \"\"\" Get list of added elements for a reaction. Args: rxn: Reaction object target: target composition (used to determine added elements) \"\"\" target = Composition ( target ) chemsys_prop = ( \"total_chemical_system\" if rxn . __class__ . __name__ == \"OpenComputedReaction\" else \"chemical_system\" ) added_elems = set ( getattr ( rxn , chemsys_prop ) . split ( \"-\" )) - set ( target . chemical_system . split ( \"-\" ) ) added_elems_str = \"-\" . join ( sorted ( list ( added_elems ))) return added_elems_str @staticmethod def _get_unique_entries ( rxns : Collection [ ComputedReaction ]) -> Set [ ComputedEntry ]: \"\"\" Return only unique entries from reactions \"\"\" entries = set () for r in rxns : entries . update ( r . entries ) return entries def __iter__ ( self ): \"\"\" Iterate over the reactions in the set. \"\"\" return iter ( self . get_rxns ()) def __len__ ( self ): \"\"\" Return length of reactions stored in the set. \"\"\" return len ( self . coeffs ) __init__ ( entries , indices , coeffs , open_elem = None , chempot = 0.0 , all_data = None ) Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects shared by reactions required indices Union [ np . ndarray , List [ List [ int ]]] Array indexing the entry list; gets entries used by each reaction object required coeffs Union [ np . ndarray , List [ List [ float ]]] Array of all reaction coefficients required open_elem Optional [ Union [ str , Element ]] Open element, e.g., \"O\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 all_data Optional [ List ] Optional list of data for each reaction None Source code in rxn_network/reactions/reaction_set.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients open_elem: Open element, e.g., \"O\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . open_elem = open_elem self . chempot = chempot self . all_data = all_data if all_data else [] self . mu_dict = None if open_elem : self . mu_dict = { Element ( open_elem ): chempot } # type: ignore __iter__ () Iterate over the reactions in the set. Source code in rxn_network/reactions/reaction_set.py 475 476 477 478 479 def __iter__ ( self ): \"\"\" Iterate over the reactions in the set. \"\"\" return iter ( self . get_rxns ()) __len__ () Return length of reactions stored in the set. Source code in rxn_network/reactions/reaction_set.py 481 482 483 484 485 def __len__ ( self ): \"\"\" Return length of reactions stored in the set. \"\"\" return len ( self . coeffs ) add_rxn_set ( rxn_set ) Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. Source code in rxn_network/reactions/reaction_set.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def add_rxn_set ( self , rxn_set ): \"\"\"Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. \"\"\" if self . entries != rxn_set . entries : raise ValueError ( \"Reaction sets must have identical entries property to add.\" ) open_elem = self . open_elem chempot = self . chempot indices = self . indices + rxn_set . indices coeffs = self . coeffs + rxn_set . coeffs all_data = self . all_data + rxn_set . all_data return ReactionSet ( self . entries , indices , coeffs , open_elem , chempot , all_data ) add_rxns ( rxns ) Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. Source code in rxn_network/reactions/reaction_set.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def add_rxns ( self , rxns ): \"\"\" Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. \"\"\" new_indices , new_coeffs , new_data = [], [], [] for rxn in rxns : new_indices . append ([ self . entries . index ( e ) for e in rxn . entries ]) new_coeffs . append ( list ( rxn . coefficients )) new_data . append ( rxn . data ) return ReactionSet ( self . entries , self . indices + new_indices , self . coeffs + new_coeffs , self . open_elem , self . chempot , self . all_data + new_data , ) calculate_costs ( cf ) Evaluate a cost function on an acquired set of reactions. Parameters: Name Type Description Default cf CostFunction CostFunction object, e.g. Softplus() required Source code in rxn_network/reactions/reaction_set.py 244 245 246 247 248 249 250 251 252 253 254 def calculate_costs ( self , cf : CostFunction , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ()] filter_duplicates () Return a new ReactionSet object with duplicate reactions removed Source code in rxn_network/reactions/reaction_set.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def filter_duplicates ( self ): \"\"\" Return a new ReactionSet object with duplicate reactions removed \"\"\" indices_to_remove = set () if len ( self . coeffs ) == 0 : return self # groupby only works with pre-sorted arrays sorted_coeffs , sorted_idxs , sorted_indices = zip ( * list ( sorted ( zip ( self . coeffs , range ( len ( self . indices )), self . indices ), key = lambda x : sorted ( x [ 2 ]), ) ) ) for i , group in groupby ( zip ( sorted_coeffs , sorted_idxs , sorted_indices ), key = lambda i : sorted ( i [ 2 ]), ): coeffs_group , idx_group , indices_group = zip ( * group ) if len ( idx_group ) > 1 : for ( _ , coeffs1 , indices1 ), ( idx2 , coeffs2 , indices2 , ) in combinations ( zip ( idx_group , coeffs_group , indices_group ), 2 ): if idx2 in indices_to_remove : continue coeffs2_sorted = [ coeffs2 [ indices2 . index ( i )] for i in indices1 ] ratios = np . array ( coeffs1 ) / np . array ( coeffs2_sorted ) if ( ratios <= 1e-8 ) . any (): # do not remove any reaction with negative ratio continue if np . isclose ( ratios [ 0 ], ratios ) . all (): indices_to_remove . add ( idx2 ) new_indices = [] new_coeffs = [] new_all_data = [] for idx in set ( range ( len ( self ))) - indices_to_remove : new_indices . append ( self . indices [ idx ]) new_coeffs . append ( self . coeffs [ idx ]) new_all_data . append ( self . all_data [ idx ]) return ReactionSet ( self . entries , new_indices , new_coeffs , self . open_elem , self . chempot , new_all_data , ) from_rxns ( rxns , entries = None , open_elem = None , chempot = 0.0 , filter_duplicates = False ) classmethod Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default rxns Collection [ Union [ ComputedReaction , OpenComputedReaction ]] List of ComputedReaction-like objects. required entries Optional [ Collection [ ComputedEntry ]] Optional list of ComputedEntry objects None open_elem Optional [ Union [ str , Element ]] Open element, e.g. \"O2\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 Source code in rxn_network/reactions/reaction_set.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 @classmethod def from_rxns ( cls , rxns : Collection [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Collection [ ComputedEntry ]] = None , open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , filter_duplicates : bool = False , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_entry_indices : Dict [ str , ComputedEntry ] = {} indices , coeffs , data = [], [], [] for rxn in rxns : rxn_indices = [] for e in rxn . entries : idx = all_entry_indices . get ( e . composition . reduced_formula ) if idx is None : idx = entries . index ( e ) all_entry_indices [ e . composition . reduced_formula ] = idx rxn_indices . append ( idx ) indices . append ( rxn_indices ) coeffs . append ( list ( rxn . coefficients )) data . append ( rxn . data ) all_open_elems : Set [ Element ] = set () all_chempots : Set [ float ] = set () if ( all ( r . __class__ . __name__ == \"OpenComputedReaction\" for r in rxns ) and not open_elem ): for r in rxns : all_open_elems . update ( r . chempots . keys ()) all_chempots . update ( r . chempots . values ()) if len ( all_chempots ) == 1 and len ( all_open_elems ) == 1 : chempot = all_chempots . pop () open_elem = all_open_elems . pop () rxn_set = cls ( entries = entries , indices = indices , coeffs = coeffs , open_elem = open_elem , chempot = chempot , all_data = data , ) if filter_duplicates : rxn_set = rxn_set . filter_duplicates () return rxn_set get_rxns () Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Source code in rxn_network/reactions/reaction_set.py 63 64 65 66 67 68 69 70 def get_rxns ( self , ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. \"\"\" return self . _get_rxns_by_indices ( idxs = range ( len ( self . coeffs ))) get_rxns_by_product ( product ) Return a list of reactions which contain the given product formula. Source code in rxn_network/reactions/reaction_set.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def get_rxns_by_product ( self , product : str ): \"\"\" Return a list of reactions which contain the given product formula. \"\"\" idxs = [] product = Composition ( product ) . reduced_formula product_index = None for idx , e in enumerate ( self . entries ): if e . composition . reduced_formula == product : product_index = idx break if not product_index : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): p_indices = { i for c , i in zip ( coeffs , indices ) if c > - 1e-12 } if product_index in p_indices : idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) get_rxns_by_reactants ( reactants ) Return a list of reactions with the given reactants. Source code in rxn_network/reactions/reaction_set.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def get_rxns_by_reactants ( self , reactants : List [ str ]): \"\"\" Return a list of reactions with the given reactants. \"\"\" idxs = [] reactants = [ Composition ( r ) . reduced_formula for r in reactants ] reactant_indices = { idx for idx , e in enumerate ( self . entries ) if e . composition . reduced_formula in reactants } if not reactant_indices : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): r_indices = { i for c , i in zip ( coeffs , indices ) if c < 1e-12 } if r_indices . issubset ( reactant_indices ): idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) to_dataframe ( cost_function , target = None , calculate_uncertainties = False , calculate_separable = False ) cached Make a dataframe of reactions from a ReactionSet object. Parameters: Name Type Description Default cost_function CostFunction Cost function to use for evaluating reaction costs required target Optional [ Composition ] Optional target composition (used to determine added elements) None calculate_uncertainties Whether to calculate uncertainties (dE column) False calculate_separable Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) False Returns: Type Description DataFrame Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction Source code in rxn_network/reactions/reaction_set.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @lru_cache ( maxsize = 1 ) def to_dataframe ( self , cost_function : CostFunction , target : Optional [ Composition ] = None , calculate_uncertainties = False , calculate_separable = False , ) -> DataFrame : \"\"\" Make a dataframe of reactions from a ReactionSet object. Args: cost_function: Cost function to use for evaluating reaction costs target: Optional target composition (used to determine added elements) calculate_uncertainties: Whether to calculate uncertainties (dE column) calculate_separable: Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) Returns: Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction \"\"\" data : Dict [ str , Any ] = OrderedDict ({ k : [] for k in [ \"rxn\" , \"energy\" ]}) attrs = [] calculate_e_above_hulls = False determine_theoretical = False for r in self . get_rxns (): attrs = list ( r . data . keys ()) # get extra attributes from first reaction entry_data = r . entries [ 0 ] . data if \"e_above_hull\" in entry_data : calculate_e_above_hulls = True data [ \"max_e_hull_reactants\" ] = [] data [ \"max_e_hull_products\" ] = [] if \"icsd_ids\" in entry_data or \"theoretical\" in entry_data : determine_theoretical = True data [ \"num_theoretical_reactants\" ] = [] data [ \"num_theoretical_products\" ] = [] break target = Composition ( target ) if target else None if \"num_constraints\" in attrs : attrs . remove ( \"num_constraints\" ) if calculate_uncertainties : data [ \"dE\" ] = [] if target : data [ \"added_elems\" ] = [] if calculate_separable : data [ \"separable\" ] = [] data [ \"max_num_precursor_elems\" ] = [] data . update ({ k : [] for k in attrs + [ \"cost\" ]}) for rxn in self . get_rxns (): data [ \"rxn\" ] . append ( rxn ) data [ \"energy\" ] . append ( rxn . energy_per_atom ) if calculate_uncertainties : data [ \"dE\" ] . append ( rxn . energy_uncertainty_per_atom ) if target : data [ \"added_elems\" ] . append ( self . _get_added_elems ( rxn , target )) if calculate_separable : data [ \"separable\" ] . append ( rxn . is_separable ( target )) if calculate_e_above_hulls : data [ \"max_e_hull_reactants\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . reactant_entries ) ) data [ \"max_e_hull_products\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . product_entries ) ) if determine_theoretical : data [ \"num_theoretical_reactants\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . reactant_entries ) ) data [ \"num_theoretical_products\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . product_entries ) ) data [ \"max_num_precursor_elems\" ] . append ( max ( len ( precursor . elements ) for precursor in rxn . reactants ) ) for attr in attrs : data [ attr ] . append ( rxn . data . get ( attr )) data [ \"cost\" ] . append ( cost_function . evaluate ( rxn )) df = DataFrame ( data ) . sort_values ( \"cost\" ) . reset_index ( drop = True ) return df","title":"Reaction Set"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet","text":"Bases: MSONable A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries. This is useful for dumping large amounts of reaction data to a database. this is not a true \"set\"; there is the option for filtering duplicates but it is not explicitly required. Source code in rxn_network/reactions/reaction_set.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 class ReactionSet ( MSONable ): \"\"\" A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries. This is useful for dumping large amounts of reaction data to a database. Note: this is not a true \"set\"; there is the option for filtering duplicates but it is not explicitly required. \"\"\" def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients open_elem: Open element, e.g., \"O\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . open_elem = open_elem self . chempot = chempot self . all_data = all_data if all_data else [] self . mu_dict = None if open_elem : self . mu_dict = { Element ( open_elem ): chempot } # type: ignore def get_rxns ( self , ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. \"\"\" return self . _get_rxns_by_indices ( idxs = range ( len ( self . coeffs ))) @classmethod def from_rxns ( cls , rxns : Collection [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Collection [ ComputedEntry ]] = None , open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , filter_duplicates : bool = False , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_entry_indices : Dict [ str , ComputedEntry ] = {} indices , coeffs , data = [], [], [] for rxn in rxns : rxn_indices = [] for e in rxn . entries : idx = all_entry_indices . get ( e . composition . reduced_formula ) if idx is None : idx = entries . index ( e ) all_entry_indices [ e . composition . reduced_formula ] = idx rxn_indices . append ( idx ) indices . append ( rxn_indices ) coeffs . append ( list ( rxn . coefficients )) data . append ( rxn . data ) all_open_elems : Set [ Element ] = set () all_chempots : Set [ float ] = set () if ( all ( r . __class__ . __name__ == \"OpenComputedReaction\" for r in rxns ) and not open_elem ): for r in rxns : all_open_elems . update ( r . chempots . keys ()) all_chempots . update ( r . chempots . values ()) if len ( all_chempots ) == 1 and len ( all_open_elems ) == 1 : chempot = all_chempots . pop () open_elem = all_open_elems . pop () rxn_set = cls ( entries = entries , indices = indices , coeffs = coeffs , open_elem = open_elem , chempot = chempot , all_data = data , ) if filter_duplicates : rxn_set = rxn_set . filter_duplicates () return rxn_set @lru_cache ( maxsize = 1 ) def to_dataframe ( self , cost_function : CostFunction , target : Optional [ Composition ] = None , calculate_uncertainties = False , calculate_separable = False , ) -> DataFrame : \"\"\" Make a dataframe of reactions from a ReactionSet object. Args: cost_function: Cost function to use for evaluating reaction costs target: Optional target composition (used to determine added elements) calculate_uncertainties: Whether to calculate uncertainties (dE column) calculate_separable: Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) Returns: Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction \"\"\" data : Dict [ str , Any ] = OrderedDict ({ k : [] for k in [ \"rxn\" , \"energy\" ]}) attrs = [] calculate_e_above_hulls = False determine_theoretical = False for r in self . get_rxns (): attrs = list ( r . data . keys ()) # get extra attributes from first reaction entry_data = r . entries [ 0 ] . data if \"e_above_hull\" in entry_data : calculate_e_above_hulls = True data [ \"max_e_hull_reactants\" ] = [] data [ \"max_e_hull_products\" ] = [] if \"icsd_ids\" in entry_data or \"theoretical\" in entry_data : determine_theoretical = True data [ \"num_theoretical_reactants\" ] = [] data [ \"num_theoretical_products\" ] = [] break target = Composition ( target ) if target else None if \"num_constraints\" in attrs : attrs . remove ( \"num_constraints\" ) if calculate_uncertainties : data [ \"dE\" ] = [] if target : data [ \"added_elems\" ] = [] if calculate_separable : data [ \"separable\" ] = [] data [ \"max_num_precursor_elems\" ] = [] data . update ({ k : [] for k in attrs + [ \"cost\" ]}) for rxn in self . get_rxns (): data [ \"rxn\" ] . append ( rxn ) data [ \"energy\" ] . append ( rxn . energy_per_atom ) if calculate_uncertainties : data [ \"dE\" ] . append ( rxn . energy_uncertainty_per_atom ) if target : data [ \"added_elems\" ] . append ( self . _get_added_elems ( rxn , target )) if calculate_separable : data [ \"separable\" ] . append ( rxn . is_separable ( target )) if calculate_e_above_hulls : data [ \"max_e_hull_reactants\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . reactant_entries ) ) data [ \"max_e_hull_products\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . product_entries ) ) if determine_theoretical : data [ \"num_theoretical_reactants\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . reactant_entries ) ) data [ \"num_theoretical_products\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . product_entries ) ) data [ \"max_num_precursor_elems\" ] . append ( max ( len ( precursor . elements ) for precursor in rxn . reactants ) ) for attr in attrs : data [ attr ] . append ( rxn . data . get ( attr )) data [ \"cost\" ] . append ( cost_function . evaluate ( rxn )) df = DataFrame ( data ) . sort_values ( \"cost\" ) . reset_index ( drop = True ) return df def calculate_costs ( self , cf : CostFunction , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ()] def add_rxns ( self , rxns ): \"\"\" Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. \"\"\" new_indices , new_coeffs , new_data = [], [], [] for rxn in rxns : new_indices . append ([ self . entries . index ( e ) for e in rxn . entries ]) new_coeffs . append ( list ( rxn . coefficients )) new_data . append ( rxn . data ) return ReactionSet ( self . entries , self . indices + new_indices , self . coeffs + new_coeffs , self . open_elem , self . chempot , self . all_data + new_data , ) def add_rxn_set ( self , rxn_set ): \"\"\"Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. \"\"\" if self . entries != rxn_set . entries : raise ValueError ( \"Reaction sets must have identical entries property to add.\" ) open_elem = self . open_elem chempot = self . chempot indices = self . indices + rxn_set . indices coeffs = self . coeffs + rxn_set . coeffs all_data = self . all_data + rxn_set . all_data return ReactionSet ( self . entries , indices , coeffs , open_elem , chempot , all_data ) def get_rxns_by_reactants ( self , reactants : List [ str ]): \"\"\" Return a list of reactions with the given reactants. \"\"\" idxs = [] reactants = [ Composition ( r ) . reduced_formula for r in reactants ] reactant_indices = { idx for idx , e in enumerate ( self . entries ) if e . composition . reduced_formula in reactants } if not reactant_indices : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): r_indices = { i for c , i in zip ( coeffs , indices ) if c < 1e-12 } if r_indices . issubset ( reactant_indices ): idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) def get_rxns_by_product ( self , product : str ): \"\"\" Return a list of reactions which contain the given product formula. \"\"\" idxs = [] product = Composition ( product ) . reduced_formula product_index = None for idx , e in enumerate ( self . entries ): if e . composition . reduced_formula == product : product_index = idx break if not product_index : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): p_indices = { i for c , i in zip ( coeffs , indices ) if c > - 1e-12 } if product_index in p_indices : idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs ) def filter_duplicates ( self ): \"\"\" Return a new ReactionSet object with duplicate reactions removed \"\"\" indices_to_remove = set () if len ( self . coeffs ) == 0 : return self # groupby only works with pre-sorted arrays sorted_coeffs , sorted_idxs , sorted_indices = zip ( * list ( sorted ( zip ( self . coeffs , range ( len ( self . indices )), self . indices ), key = lambda x : sorted ( x [ 2 ]), ) ) ) for i , group in groupby ( zip ( sorted_coeffs , sorted_idxs , sorted_indices ), key = lambda i : sorted ( i [ 2 ]), ): coeffs_group , idx_group , indices_group = zip ( * group ) if len ( idx_group ) > 1 : for ( _ , coeffs1 , indices1 ), ( idx2 , coeffs2 , indices2 , ) in combinations ( zip ( idx_group , coeffs_group , indices_group ), 2 ): if idx2 in indices_to_remove : continue coeffs2_sorted = [ coeffs2 [ indices2 . index ( i )] for i in indices1 ] ratios = np . array ( coeffs1 ) / np . array ( coeffs2_sorted ) if ( ratios <= 1e-8 ) . any (): # do not remove any reaction with negative ratio continue if np . isclose ( ratios [ 0 ], ratios ) . all (): indices_to_remove . add ( idx2 ) new_indices = [] new_coeffs = [] new_all_data = [] for idx in set ( range ( len ( self ))) - indices_to_remove : new_indices . append ( self . indices [ idx ]) new_coeffs . append ( self . coeffs [ idx ]) new_all_data . append ( self . all_data [ idx ]) return ReactionSet ( self . entries , new_indices , new_coeffs , self . open_elem , self . chempot , new_all_data , ) def _get_rxns_by_indices ( self , idxs : Union [ List [ int ], range ] ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Return a list of reactions with the given indices. \"\"\" if idxs == range ( len ( self . coeffs )): indices_slice = self . indices coeffs_slice = self . coeffs data_slice = self . all_data else : indices_slice = [] coeffs_slice = [] data_slice = [] for idx in idxs : indices_slice . append ( self . indices [ idx ]) coeffs_slice . append ( self . coeffs [ idx ]) data_slice . append ( self . all_data [ idx ]) for indices , coeffs , data in zip ( indices_slice , coeffs_slice , data_slice ): entries = [ self . entries [ i ] for i in indices ] if self . mu_dict : rxn = OpenComputedReaction ( entries = entries , coefficients = coeffs , data = data , chempots = self . mu_dict , ) else : rxn = ComputedReaction ( entries = entries , coefficients = coeffs , data = data ) yield rxn @staticmethod def _get_added_elems ( rxn : Union [ ComputedReaction , OpenComputedReaction ], target : Composition ) -> str : \"\"\" Get list of added elements for a reaction. Args: rxn: Reaction object target: target composition (used to determine added elements) \"\"\" target = Composition ( target ) chemsys_prop = ( \"total_chemical_system\" if rxn . __class__ . __name__ == \"OpenComputedReaction\" else \"chemical_system\" ) added_elems = set ( getattr ( rxn , chemsys_prop ) . split ( \"-\" )) - set ( target . chemical_system . split ( \"-\" ) ) added_elems_str = \"-\" . join ( sorted ( list ( added_elems ))) return added_elems_str @staticmethod def _get_unique_entries ( rxns : Collection [ ComputedReaction ]) -> Set [ ComputedEntry ]: \"\"\" Return only unique entries from reactions \"\"\" entries = set () for r in rxns : entries . update ( r . entries ) return entries def __iter__ ( self ): \"\"\" Iterate over the reactions in the set. \"\"\" return iter ( self . get_rxns ()) def __len__ ( self ): \"\"\" Return length of reactions stored in the set. \"\"\" return len ( self . coeffs )","title":"ReactionSet"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.__init__","text":"Parameters: Name Type Description Default entries List [ ComputedEntry ] List of ComputedEntry objects shared by reactions required indices Union [ np . ndarray , List [ List [ int ]]] Array indexing the entry list; gets entries used by each reaction object required coeffs Union [ np . ndarray , List [ List [ float ]]] Array of all reaction coefficients required open_elem Optional [ Union [ str , Element ]] Open element, e.g., \"O\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 all_data Optional [ List ] Optional list of data for each reaction None Source code in rxn_network/reactions/reaction_set.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients open_elem: Open element, e.g., \"O\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . open_elem = open_elem self . chempot = chempot self . all_data = all_data if all_data else [] self . mu_dict = None if open_elem : self . mu_dict = { Element ( open_elem ): chempot } # type: ignore","title":"__init__()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.__iter__","text":"Iterate over the reactions in the set. Source code in rxn_network/reactions/reaction_set.py 475 476 477 478 479 def __iter__ ( self ): \"\"\" Iterate over the reactions in the set. \"\"\" return iter ( self . get_rxns ())","title":"__iter__()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.__len__","text":"Return length of reactions stored in the set. Source code in rxn_network/reactions/reaction_set.py 481 482 483 484 485 def __len__ ( self ): \"\"\" Return length of reactions stored in the set. \"\"\" return len ( self . coeffs )","title":"__len__()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.add_rxn_set","text":"Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. Source code in rxn_network/reactions/reaction_set.py 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 def add_rxn_set ( self , rxn_set ): \"\"\"Adds a new reaction set to current reaction set. Warning: new reaction set must have the same entries as the current reaction set. \"\"\" if self . entries != rxn_set . entries : raise ValueError ( \"Reaction sets must have identical entries property to add.\" ) open_elem = self . open_elem chempot = self . chempot indices = self . indices + rxn_set . indices coeffs = self . coeffs + rxn_set . coeffs all_data = self . all_data + rxn_set . all_data return ReactionSet ( self . entries , indices , coeffs , open_elem , chempot , all_data )","title":"add_rxn_set()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.add_rxns","text":"Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. Source code in rxn_network/reactions/reaction_set.py 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 def add_rxns ( self , rxns ): \"\"\" Return a new ReactionSet with the reactions added. Warning: all new reactions must only have entires contained in the entries of the current reaction set. \"\"\" new_indices , new_coeffs , new_data = [], [], [] for rxn in rxns : new_indices . append ([ self . entries . index ( e ) for e in rxn . entries ]) new_coeffs . append ( list ( rxn . coefficients )) new_data . append ( rxn . data ) return ReactionSet ( self . entries , self . indices + new_indices , self . coeffs + new_coeffs , self . open_elem , self . chempot , self . all_data + new_data , )","title":"add_rxns()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.calculate_costs","text":"Evaluate a cost function on an acquired set of reactions. Parameters: Name Type Description Default cf CostFunction CostFunction object, e.g. Softplus() required Source code in rxn_network/reactions/reaction_set.py 244 245 246 247 248 249 250 251 252 253 254 def calculate_costs ( self , cf : CostFunction , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ()]","title":"calculate_costs()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.filter_duplicates","text":"Return a new ReactionSet object with duplicate reactions removed Source code in rxn_network/reactions/reaction_set.py 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 def filter_duplicates ( self ): \"\"\" Return a new ReactionSet object with duplicate reactions removed \"\"\" indices_to_remove = set () if len ( self . coeffs ) == 0 : return self # groupby only works with pre-sorted arrays sorted_coeffs , sorted_idxs , sorted_indices = zip ( * list ( sorted ( zip ( self . coeffs , range ( len ( self . indices )), self . indices ), key = lambda x : sorted ( x [ 2 ]), ) ) ) for i , group in groupby ( zip ( sorted_coeffs , sorted_idxs , sorted_indices ), key = lambda i : sorted ( i [ 2 ]), ): coeffs_group , idx_group , indices_group = zip ( * group ) if len ( idx_group ) > 1 : for ( _ , coeffs1 , indices1 ), ( idx2 , coeffs2 , indices2 , ) in combinations ( zip ( idx_group , coeffs_group , indices_group ), 2 ): if idx2 in indices_to_remove : continue coeffs2_sorted = [ coeffs2 [ indices2 . index ( i )] for i in indices1 ] ratios = np . array ( coeffs1 ) / np . array ( coeffs2_sorted ) if ( ratios <= 1e-8 ) . any (): # do not remove any reaction with negative ratio continue if np . isclose ( ratios [ 0 ], ratios ) . all (): indices_to_remove . add ( idx2 ) new_indices = [] new_coeffs = [] new_all_data = [] for idx in set ( range ( len ( self ))) - indices_to_remove : new_indices . append ( self . indices [ idx ]) new_coeffs . append ( self . coeffs [ idx ]) new_all_data . append ( self . all_data [ idx ]) return ReactionSet ( self . entries , new_indices , new_coeffs , self . open_elem , self . chempot , new_all_data , )","title":"filter_duplicates()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.from_rxns","text":"Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default rxns Collection [ Union [ ComputedReaction , OpenComputedReaction ]] List of ComputedReaction-like objects. required entries Optional [ Collection [ ComputedEntry ]] Optional list of ComputedEntry objects None open_elem Optional [ Union [ str , Element ]] Open element, e.g. \"O2\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 Source code in rxn_network/reactions/reaction_set.py 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 @classmethod def from_rxns ( cls , rxns : Collection [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Collection [ ComputedEntry ]] = None , open_elem : Optional [ Union [ str , Element ]] = None , chempot : float = 0.0 , filter_duplicates : bool = False , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_entry_indices : Dict [ str , ComputedEntry ] = {} indices , coeffs , data = [], [], [] for rxn in rxns : rxn_indices = [] for e in rxn . entries : idx = all_entry_indices . get ( e . composition . reduced_formula ) if idx is None : idx = entries . index ( e ) all_entry_indices [ e . composition . reduced_formula ] = idx rxn_indices . append ( idx ) indices . append ( rxn_indices ) coeffs . append ( list ( rxn . coefficients )) data . append ( rxn . data ) all_open_elems : Set [ Element ] = set () all_chempots : Set [ float ] = set () if ( all ( r . __class__ . __name__ == \"OpenComputedReaction\" for r in rxns ) and not open_elem ): for r in rxns : all_open_elems . update ( r . chempots . keys ()) all_chempots . update ( r . chempots . values ()) if len ( all_chempots ) == 1 and len ( all_open_elems ) == 1 : chempot = all_chempots . pop () open_elem = all_open_elems . pop () rxn_set = cls ( entries = entries , indices = indices , coeffs = coeffs , open_elem = open_elem , chempot = chempot , all_data = data , ) if filter_duplicates : rxn_set = rxn_set . filter_duplicates () return rxn_set","title":"from_rxns()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.get_rxns","text":"Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Source code in rxn_network/reactions/reaction_set.py 63 64 65 66 67 68 69 70 def get_rxns ( self , ) -> Iterable [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. \"\"\" return self . _get_rxns_by_indices ( idxs = range ( len ( self . coeffs )))","title":"get_rxns()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.get_rxns_by_product","text":"Return a list of reactions which contain the given product formula. Source code in rxn_network/reactions/reaction_set.py 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 def get_rxns_by_product ( self , product : str ): \"\"\" Return a list of reactions which contain the given product formula. \"\"\" idxs = [] product = Composition ( product ) . reduced_formula product_index = None for idx , e in enumerate ( self . entries ): if e . composition . reduced_formula == product : product_index = idx break if not product_index : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): p_indices = { i for c , i in zip ( coeffs , indices ) if c > - 1e-12 } if product_index in p_indices : idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs )","title":"get_rxns_by_product()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.get_rxns_by_reactants","text":"Return a list of reactions with the given reactants. Source code in rxn_network/reactions/reaction_set.py 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 def get_rxns_by_reactants ( self , reactants : List [ str ]): \"\"\" Return a list of reactions with the given reactants. \"\"\" idxs = [] reactants = [ Composition ( r ) . reduced_formula for r in reactants ] reactant_indices = { idx for idx , e in enumerate ( self . entries ) if e . composition . reduced_formula in reactants } if not reactant_indices : return [] for idx , ( coeffs , indices ) in enumerate ( zip ( self . coeffs , self . indices )): r_indices = { i for c , i in zip ( coeffs , indices ) if c < 1e-12 } if r_indices . issubset ( reactant_indices ): idxs . append ( idx ) return self . _get_rxns_by_indices ( idxs )","title":"get_rxns_by_reactants()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.to_dataframe","text":"Make a dataframe of reactions from a ReactionSet object. Parameters: Name Type Description Default cost_function CostFunction Cost function to use for evaluating reaction costs required target Optional [ Composition ] Optional target composition (used to determine added elements) None calculate_uncertainties Whether to calculate uncertainties (dE column) False calculate_separable Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) False Returns: Type Description DataFrame Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction Source code in rxn_network/reactions/reaction_set.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 @lru_cache ( maxsize = 1 ) def to_dataframe ( self , cost_function : CostFunction , target : Optional [ Composition ] = None , calculate_uncertainties = False , calculate_separable = False , ) -> DataFrame : \"\"\" Make a dataframe of reactions from a ReactionSet object. Args: cost_function: Cost function to use for evaluating reaction costs target: Optional target composition (used to determine added elements) calculate_uncertainties: Whether to calculate uncertainties (dE column) calculate_separable: Whether to calculate if the reaction products are separable (see ComputedReaction.is_separable) Returns: Pandas DataFrame with columns: rxn: Reaction object energy: reaction energy in eV/atom dE (optional): uncertainty in reaction energy in eV/atom added_elems (optional): List of added elements separable (optional): whether reaction products are separable cost: Cost of reaction other: any other data associated with reaction \"\"\" data : Dict [ str , Any ] = OrderedDict ({ k : [] for k in [ \"rxn\" , \"energy\" ]}) attrs = [] calculate_e_above_hulls = False determine_theoretical = False for r in self . get_rxns (): attrs = list ( r . data . keys ()) # get extra attributes from first reaction entry_data = r . entries [ 0 ] . data if \"e_above_hull\" in entry_data : calculate_e_above_hulls = True data [ \"max_e_hull_reactants\" ] = [] data [ \"max_e_hull_products\" ] = [] if \"icsd_ids\" in entry_data or \"theoretical\" in entry_data : determine_theoretical = True data [ \"num_theoretical_reactants\" ] = [] data [ \"num_theoretical_products\" ] = [] break target = Composition ( target ) if target else None if \"num_constraints\" in attrs : attrs . remove ( \"num_constraints\" ) if calculate_uncertainties : data [ \"dE\" ] = [] if target : data [ \"added_elems\" ] = [] if calculate_separable : data [ \"separable\" ] = [] data [ \"max_num_precursor_elems\" ] = [] data . update ({ k : [] for k in attrs + [ \"cost\" ]}) for rxn in self . get_rxns (): data [ \"rxn\" ] . append ( rxn ) data [ \"energy\" ] . append ( rxn . energy_per_atom ) if calculate_uncertainties : data [ \"dE\" ] . append ( rxn . energy_uncertainty_per_atom ) if target : data [ \"added_elems\" ] . append ( self . _get_added_elems ( rxn , target )) if calculate_separable : data [ \"separable\" ] . append ( rxn . is_separable ( target )) if calculate_e_above_hulls : data [ \"max_e_hull_reactants\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . reactant_entries ) ) data [ \"max_e_hull_products\" ] . append ( max ( e . data . get ( \"e_above_hull\" , 0.0 ) for e in rxn . product_entries ) ) if determine_theoretical : data [ \"num_theoretical_reactants\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . reactant_entries ) ) data [ \"num_theoretical_products\" ] . append ( sum ( bool ( not e . is_experimental ) for e in rxn . product_entries ) ) data [ \"max_num_precursor_elems\" ] . append ( max ( len ( precursor . elements ) for precursor in rxn . reactants ) ) for attr in attrs : data [ attr ] . append ( rxn . data . get ( attr )) data [ \"cost\" ] . append ( cost_function . evaluate ( rxn )) df = DataFrame ( data ) . sort_values ( \"cost\" ) . reset_index ( drop = True ) return df","title":"to_dataframe()"},{"location":"reference/thermo/chempot_diagram/","text":"This module implements added features to the ChemicalPotentialDiagram class from pymatgen. ChemicalPotentialDiagram Bases: ChempotDiagram This class is an extension of the ChemicalPotentialDiagram class from pymatgen. Several features have been added to the original class for the purpose of efficiently calculating the shortest distance between two chemical potential domains. For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, P. K., McDermott, M. J., Rom, C. L., Corrao, A. A., Denney, J. J., Dwaraknath, S. S., Khalifah, P. G., Persson, K. A., & Neilson, J. R. (2021). Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. Journal of the American Chemical Society, 143(37), 15185-15194. https://doi.org/10.1021/jacs.1c06229 Source code in rxn_network/thermo/chempot_diagram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class ChemicalPotentialDiagram ( ChempotDiagram ): \"\"\" This class is an extension of the ChemicalPotentialDiagram class from pymatgen. Several features have been added to the original class for the purpose of efficiently calculating the shortest distance between two chemical potential domains. For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, P. K., McDermott, M. J., Rom, C. L., Corrao, A. A., Denney, J. J., Dwaraknath, S. S., Khalifah, P. G., Persson, K. A., & Neilson, J. R. (2021). Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. Journal of the American Chemical Society, 143(37), 15185-15194. https://doi.org/10.1021/jacs.1c06229 \"\"\" def __init__ ( # pylint: disable=super-init-not-called self , entries : List [ PDEntry ], limits : Optional [ Dict [ Element , float ]] = None , default_min_limit : Optional [ float ] = - 100.0 , ): \"\"\" Initialize a ChemicalPotentialDiagram object. Args: entries: List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements limits: Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument default_min_limit (float): Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) \"\"\" self . entries = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . _entry_set = GibbsEntrySet ( self . entries ) self . limits = limits self . default_min_limit = default_min_limit self . elements = list ( sorted ({ els for e in self . entries for els in e . composition . elements }) ) self . dim = len ( self . elements ) self . _min_entries , self . _el_refs = self . _get_min_entries_and_el_refs ( self . entries ) self . _entry_dict = { e . composition . reduced_formula : e for e in self . _min_entries } self . _border_hyperplanes = self . _get_border_hyperplanes () ( self . _hyperplanes , self . _hyperplane_entries , ) = self . _get_hyperplanes_and_entries () if self . dim < 2 : raise ValueError ( \"ChemicalPotentialDiagram currently requires phase \" \"diagrams with 2 or more elements!\" ) if len ( self . el_refs ) != self . dim : missing = set ( self . elements ) . difference ( self . el_refs . keys ()) raise ValueError ( f \"There are no entries for the terminal elements: { missing } \" ) self . _hs_int = self . _get_halfspace_intersection () num_hyperplanes = len ( self . _hyperplanes ) num_border_hyperplanes = len ( self . _border_hyperplanes ) self . _border_hyperplane_indices = list ( range ( num_hyperplanes , num_hyperplanes + num_border_hyperplanes ) ) self . _metastable_domains : Dict [ str , List ] = {} # for caching def shortest_domain_distance ( self , f1 : str , f2 : str , offset = 0.0 ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" if f1 in self . domains : pts1 = self . domains [ f1 ] else : pts1 = self . _get_metastable_domain ( f1 ) if f2 in self . domains : pts2 = self . domains [ f2 ] else : pts2 = self . _get_metastable_domain ( f2 ) tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ]) + offset def _get_halfspace_intersection ( self ): hs_hyperplanes = np . vstack ([ self . _hyperplanes , self . _border_hyperplanes ]) interior_point = np . min ( self . lims , axis = 1 ) + 1e-1 return HalfspaceIntersection ( hs_hyperplanes , interior_point ) def _get_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Returns a dictionary of domains as {formula: np.ndarray}\"\"\" domains : Dict [ str , List ] = { entry . composition . reduced_formula : [] for entry in self . _hyperplane_entries } entries = self . _hyperplane_entries for intersection , facet in zip ( self . hs_int . intersections , self . hs_int . dual_facets ): for v in facet : if v not in self . _border_hyperplane_indices : this_entry = entries [ v ] formula = this_entry . composition . reduced_formula domains [ formula ] . append ( intersection ) return { k : np . array ( v ) for k , v in domains . items () if v } def _get_hyperplanes_and_entries ( self ) -> Tuple [ np . ndarray , List [ PDEntry ]]: \"\"\"Returns both the array of hyperplanes, as well as a list of the minimum entries\"\"\" data = np . array ([ self . _get_hyperplane ( e ) for e in self . _min_entries ]) vec = [ self . el_refs [ el ] . energy_per_atom for el in self . elements ] + [ 1 ] form_e = - np . dot ( data , vec ) inds = np . where ( form_e < - PhaseDiagram . formation_energy_tol )[ 0 ] . tolist () inds . extend ([ self . _min_entries . index ( el ) for el in self . el_refs . values ()]) hyperplanes = data [ inds ] hyperplane_entries = [ self . _min_entries [ i ] for i in inds ] return hyperplanes , hyperplane_entries def _get_hyperplane ( self , entry ): data = np . array ( [ entry . composition . get_atomic_fraction ( el ) for el in self . elements ] + [ - entry . energy_per_atom ] ) return data def get_offset ( self , entry ): \"\"\" \"\"\" if ( entry in self . _min_entries and entry . composition . reduced_formula in self . domains ): offset = 0.0 else : e_above_hull = self . _entry_set . get_e_above_hull ( entry ) hyperplane = self . _get_hyperplane ( entry ) offset = self . _get_distance_between_parallel_hyperplanes ( hyperplane [: - 1 ], e_above_hull ) return offset @staticmethod def _get_distance_between_parallel_hyperplanes ( a , delta_b ): \"\"\"Returns the distance between two parallel hyperplanes\"\"\" return np . abs ( delta_b ) / np . linalg . norm ( a ) def _get_metastable_domain ( self , formula ): \"\"\"Returns the metastable domain for a given formula\"\"\" if formula in self . _metastable_domains : return self . _metastable_domains [ formula ] orig_entry = self . _entry_set . get_min_entry_by_formula ( formula ) new_entry = self . _entry_set . get_stabilized_entry ( orig_entry , tol = 1e-1 ) self . _entry_set . add ( new_entry ) cpd = ChemicalPotentialDiagram ( self . _entry_set , default_min_limit =- 500 ) try : metastable_domain = cpd . domains [ formula ] except KeyError as exc : raise ValueError ( f \"Metastable domain for { formula } not found! Please investigate.\" ) from exc self . _metastable_domains [ formula ] = metastable_domain self . _entry_set . remove ( new_entry ) return metastable_domain @property def hs_int ( self ): \"\"\"Returns the scipy HalfSpaceIntersection object\"\"\" return self . _hs_int @cached_property def domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Mapping of formulas to array of domain boundary points\"\"\" return self . _get_domains () @property def metastable_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\" Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable \"\"\" return { e . composition . reduced_formula : self . _get_metastable_domain ( e . composition . reduced_formula ) for e in self . _min_entries if e . composition . reduced_formula not in self . domains } __init__ ( entries , limits = None , default_min_limit =- 100.0 ) Initialize a ChemicalPotentialDiagram object. Parameters: Name Type Description Default entries List [ PDEntry ] List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements required limits Optional [ Dict [ Element , float ]] Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument None default_min_limit float Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) -100.0 Source code in rxn_network/thermo/chempot_diagram.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( # pylint: disable=super-init-not-called self , entries : List [ PDEntry ], limits : Optional [ Dict [ Element , float ]] = None , default_min_limit : Optional [ float ] = - 100.0 , ): \"\"\" Initialize a ChemicalPotentialDiagram object. Args: entries: List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements limits: Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument default_min_limit (float): Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) \"\"\" self . entries = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . _entry_set = GibbsEntrySet ( self . entries ) self . limits = limits self . default_min_limit = default_min_limit self . elements = list ( sorted ({ els for e in self . entries for els in e . composition . elements }) ) self . dim = len ( self . elements ) self . _min_entries , self . _el_refs = self . _get_min_entries_and_el_refs ( self . entries ) self . _entry_dict = { e . composition . reduced_formula : e for e in self . _min_entries } self . _border_hyperplanes = self . _get_border_hyperplanes () ( self . _hyperplanes , self . _hyperplane_entries , ) = self . _get_hyperplanes_and_entries () if self . dim < 2 : raise ValueError ( \"ChemicalPotentialDiagram currently requires phase \" \"diagrams with 2 or more elements!\" ) if len ( self . el_refs ) != self . dim : missing = set ( self . elements ) . difference ( self . el_refs . keys ()) raise ValueError ( f \"There are no entries for the terminal elements: { missing } \" ) self . _hs_int = self . _get_halfspace_intersection () num_hyperplanes = len ( self . _hyperplanes ) num_border_hyperplanes = len ( self . _border_hyperplanes ) self . _border_hyperplane_indices = list ( range ( num_hyperplanes , num_hyperplanes + num_border_hyperplanes ) ) self . _metastable_domains : Dict [ str , List ] = {} # for caching domains () property cached Mapping of formulas to array of domain boundary points Source code in rxn_network/thermo/chempot_diagram.py 218 219 220 221 @cached_property def domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Mapping of formulas to array of domain boundary points\"\"\" return self . _get_domains () hs_int () property Returns the scipy HalfSpaceIntersection object Source code in rxn_network/thermo/chempot_diagram.py 213 214 215 216 @property def hs_int ( self ): \"\"\"Returns the scipy HalfSpaceIntersection object\"\"\" return self . _hs_int metastable_domains () property Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable Source code in rxn_network/thermo/chempot_diagram.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @property def metastable_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\" Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable \"\"\" return { e . composition . reduced_formula : self . _get_metastable_domain ( e . composition . reduced_formula ) for e in self . _min_entries if e . composition . reduced_formula not in self . domains } shortest_domain_distance ( f1 , f2 , offset = 0.0 ) Parameters: Name Type Description Default f1 str chemical formula (1) required f2 str chemical formula (2) required Returns: Type Description float Shortest distance between domain boundaries in the full float (hyper)dimensional space, calculated using KDTree. Source code in rxn_network/thermo/chempot_diagram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def shortest_domain_distance ( self , f1 : str , f2 : str , offset = 0.0 ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" if f1 in self . domains : pts1 = self . domains [ f1 ] else : pts1 = self . _get_metastable_domain ( f1 ) if f2 in self . domains : pts2 = self . domains [ f2 ] else : pts2 = self . _get_metastable_domain ( f2 ) tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ]) + offset","title":"Chempot Diagram"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram","text":"Bases: ChempotDiagram This class is an extension of the ChemicalPotentialDiagram class from pymatgen. Several features have been added to the original class for the purpose of efficiently calculating the shortest distance between two chemical potential domains. For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, P. K., McDermott, M. J., Rom, C. L., Corrao, A. A., Denney, J. J., Dwaraknath, S. S., Khalifah, P. G., Persson, K. A., & Neilson, J. R. (2021). Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. Journal of the American Chemical Society, 143(37), 15185-15194. https://doi.org/10.1021/jacs.1c06229 Source code in rxn_network/thermo/chempot_diagram.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 class ChemicalPotentialDiagram ( ChempotDiagram ): \"\"\" This class is an extension of the ChemicalPotentialDiagram class from pymatgen. Several features have been added to the original class for the purpose of efficiently calculating the shortest distance between two chemical potential domains. For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, P. K., McDermott, M. J., Rom, C. L., Corrao, A. A., Denney, J. J., Dwaraknath, S. S., Khalifah, P. G., Persson, K. A., & Neilson, J. R. (2021). Selectivity in Yttrium Manganese Oxide Synthesis via Local Chemical Potentials in Hyperdimensional Phase Space. Journal of the American Chemical Society, 143(37), 15185-15194. https://doi.org/10.1021/jacs.1c06229 \"\"\" def __init__ ( # pylint: disable=super-init-not-called self , entries : List [ PDEntry ], limits : Optional [ Dict [ Element , float ]] = None , default_min_limit : Optional [ float ] = - 100.0 , ): \"\"\" Initialize a ChemicalPotentialDiagram object. Args: entries: List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements limits: Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument default_min_limit (float): Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) \"\"\" self . entries = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . _entry_set = GibbsEntrySet ( self . entries ) self . limits = limits self . default_min_limit = default_min_limit self . elements = list ( sorted ({ els for e in self . entries for els in e . composition . elements }) ) self . dim = len ( self . elements ) self . _min_entries , self . _el_refs = self . _get_min_entries_and_el_refs ( self . entries ) self . _entry_dict = { e . composition . reduced_formula : e for e in self . _min_entries } self . _border_hyperplanes = self . _get_border_hyperplanes () ( self . _hyperplanes , self . _hyperplane_entries , ) = self . _get_hyperplanes_and_entries () if self . dim < 2 : raise ValueError ( \"ChemicalPotentialDiagram currently requires phase \" \"diagrams with 2 or more elements!\" ) if len ( self . el_refs ) != self . dim : missing = set ( self . elements ) . difference ( self . el_refs . keys ()) raise ValueError ( f \"There are no entries for the terminal elements: { missing } \" ) self . _hs_int = self . _get_halfspace_intersection () num_hyperplanes = len ( self . _hyperplanes ) num_border_hyperplanes = len ( self . _border_hyperplanes ) self . _border_hyperplane_indices = list ( range ( num_hyperplanes , num_hyperplanes + num_border_hyperplanes ) ) self . _metastable_domains : Dict [ str , List ] = {} # for caching def shortest_domain_distance ( self , f1 : str , f2 : str , offset = 0.0 ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" if f1 in self . domains : pts1 = self . domains [ f1 ] else : pts1 = self . _get_metastable_domain ( f1 ) if f2 in self . domains : pts2 = self . domains [ f2 ] else : pts2 = self . _get_metastable_domain ( f2 ) tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ]) + offset def _get_halfspace_intersection ( self ): hs_hyperplanes = np . vstack ([ self . _hyperplanes , self . _border_hyperplanes ]) interior_point = np . min ( self . lims , axis = 1 ) + 1e-1 return HalfspaceIntersection ( hs_hyperplanes , interior_point ) def _get_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Returns a dictionary of domains as {formula: np.ndarray}\"\"\" domains : Dict [ str , List ] = { entry . composition . reduced_formula : [] for entry in self . _hyperplane_entries } entries = self . _hyperplane_entries for intersection , facet in zip ( self . hs_int . intersections , self . hs_int . dual_facets ): for v in facet : if v not in self . _border_hyperplane_indices : this_entry = entries [ v ] formula = this_entry . composition . reduced_formula domains [ formula ] . append ( intersection ) return { k : np . array ( v ) for k , v in domains . items () if v } def _get_hyperplanes_and_entries ( self ) -> Tuple [ np . ndarray , List [ PDEntry ]]: \"\"\"Returns both the array of hyperplanes, as well as a list of the minimum entries\"\"\" data = np . array ([ self . _get_hyperplane ( e ) for e in self . _min_entries ]) vec = [ self . el_refs [ el ] . energy_per_atom for el in self . elements ] + [ 1 ] form_e = - np . dot ( data , vec ) inds = np . where ( form_e < - PhaseDiagram . formation_energy_tol )[ 0 ] . tolist () inds . extend ([ self . _min_entries . index ( el ) for el in self . el_refs . values ()]) hyperplanes = data [ inds ] hyperplane_entries = [ self . _min_entries [ i ] for i in inds ] return hyperplanes , hyperplane_entries def _get_hyperplane ( self , entry ): data = np . array ( [ entry . composition . get_atomic_fraction ( el ) for el in self . elements ] + [ - entry . energy_per_atom ] ) return data def get_offset ( self , entry ): \"\"\" \"\"\" if ( entry in self . _min_entries and entry . composition . reduced_formula in self . domains ): offset = 0.0 else : e_above_hull = self . _entry_set . get_e_above_hull ( entry ) hyperplane = self . _get_hyperplane ( entry ) offset = self . _get_distance_between_parallel_hyperplanes ( hyperplane [: - 1 ], e_above_hull ) return offset @staticmethod def _get_distance_between_parallel_hyperplanes ( a , delta_b ): \"\"\"Returns the distance between two parallel hyperplanes\"\"\" return np . abs ( delta_b ) / np . linalg . norm ( a ) def _get_metastable_domain ( self , formula ): \"\"\"Returns the metastable domain for a given formula\"\"\" if formula in self . _metastable_domains : return self . _metastable_domains [ formula ] orig_entry = self . _entry_set . get_min_entry_by_formula ( formula ) new_entry = self . _entry_set . get_stabilized_entry ( orig_entry , tol = 1e-1 ) self . _entry_set . add ( new_entry ) cpd = ChemicalPotentialDiagram ( self . _entry_set , default_min_limit =- 500 ) try : metastable_domain = cpd . domains [ formula ] except KeyError as exc : raise ValueError ( f \"Metastable domain for { formula } not found! Please investigate.\" ) from exc self . _metastable_domains [ formula ] = metastable_domain self . _entry_set . remove ( new_entry ) return metastable_domain @property def hs_int ( self ): \"\"\"Returns the scipy HalfSpaceIntersection object\"\"\" return self . _hs_int @cached_property def domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Mapping of formulas to array of domain boundary points\"\"\" return self . _get_domains () @property def metastable_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\" Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable \"\"\" return { e . composition . reduced_formula : self . _get_metastable_domain ( e . composition . reduced_formula ) for e in self . _min_entries if e . composition . reduced_formula not in self . domains }","title":"ChemicalPotentialDiagram"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.__init__","text":"Initialize a ChemicalPotentialDiagram object. Parameters: Name Type Description Default entries List [ PDEntry ] List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements required limits Optional [ Dict [ Element , float ]] Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument None default_min_limit float Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) -100.0 Source code in rxn_network/thermo/chempot_diagram.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 def __init__ ( # pylint: disable=super-init-not-called self , entries : List [ PDEntry ], limits : Optional [ Dict [ Element , float ]] = None , default_min_limit : Optional [ float ] = - 100.0 , ): \"\"\" Initialize a ChemicalPotentialDiagram object. Args: entries: List of PDEntry-like objects containing a composition and energy. Must contain elemental references and be suitable for typical phase diagram construction. Entries must be within a chemical system of with 2+ elements limits: Bounds of elemental chemical potentials (min, max), which are used to construct the border hyperplanes used in the HalfspaceIntersection algorithm; these constrain the space over which the domains are calculated and also determine the size of the plotted diagram. Any elemental limits not specified are covered in the default_min_limit argument default_min_limit (float): Default minimum chemical potential limit for unspecified elements within the \"limits\" argument. This results in default limits of (-100, 0) \"\"\" self . entries = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . _entry_set = GibbsEntrySet ( self . entries ) self . limits = limits self . default_min_limit = default_min_limit self . elements = list ( sorted ({ els for e in self . entries for els in e . composition . elements }) ) self . dim = len ( self . elements ) self . _min_entries , self . _el_refs = self . _get_min_entries_and_el_refs ( self . entries ) self . _entry_dict = { e . composition . reduced_formula : e for e in self . _min_entries } self . _border_hyperplanes = self . _get_border_hyperplanes () ( self . _hyperplanes , self . _hyperplane_entries , ) = self . _get_hyperplanes_and_entries () if self . dim < 2 : raise ValueError ( \"ChemicalPotentialDiagram currently requires phase \" \"diagrams with 2 or more elements!\" ) if len ( self . el_refs ) != self . dim : missing = set ( self . elements ) . difference ( self . el_refs . keys ()) raise ValueError ( f \"There are no entries for the terminal elements: { missing } \" ) self . _hs_int = self . _get_halfspace_intersection () num_hyperplanes = len ( self . _hyperplanes ) num_border_hyperplanes = len ( self . _border_hyperplanes ) self . _border_hyperplane_indices = list ( range ( num_hyperplanes , num_hyperplanes + num_border_hyperplanes ) ) self . _metastable_domains : Dict [ str , List ] = {} # for caching","title":"__init__()"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.domains","text":"Mapping of formulas to array of domain boundary points Source code in rxn_network/thermo/chempot_diagram.py 218 219 220 221 @cached_property def domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\"Mapping of formulas to array of domain boundary points\"\"\" return self . _get_domains ()","title":"domains()"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.hs_int","text":"Returns the scipy HalfSpaceIntersection object Source code in rxn_network/thermo/chempot_diagram.py 213 214 215 216 @property def hs_int ( self ): \"\"\"Returns the scipy HalfSpaceIntersection object\"\"\" return self . _hs_int","title":"hs_int()"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.metastable_domains","text":"Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable Source code in rxn_network/thermo/chempot_diagram.py 223 224 225 226 227 228 229 230 231 232 233 234 235 236 @property def metastable_domains ( self ) -> Dict [ str , np . ndarray ]: \"\"\" Gets a dictionary of the chemical potential domains for metastable chemical formulas. This corresponds to the domains of the relevant phases if they were just barely stable \"\"\" return { e . composition . reduced_formula : self . _get_metastable_domain ( e . composition . reduced_formula ) for e in self . _min_entries if e . composition . reduced_formula not in self . domains }","title":"metastable_domains()"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.shortest_domain_distance","text":"Parameters: Name Type Description Default f1 str chemical formula (1) required f2 str chemical formula (2) required Returns: Type Description float Shortest distance between domain boundaries in the full float (hyper)dimensional space, calculated using KDTree. Source code in rxn_network/thermo/chempot_diagram.py 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 def shortest_domain_distance ( self , f1 : str , f2 : str , offset = 0.0 ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" if f1 in self . domains : pts1 = self . domains [ f1 ] else : pts1 = self . _get_metastable_domain ( f1 ) if f2 in self . domains : pts2 = self . domains [ f2 ] else : pts2 = self . _get_metastable_domain ( f2 ) tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ]) + offset","title":"shortest_domain_distance()"},{"location":"reference/thermo/utils/","text":"Utility functions used in the thermodynamic analysis classes. expand_pd ( entries , pbar = False ) Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic stability in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Parameters: Name Type Description Default entries [ Entry ] list of Entry objects for building phase diagram. required pbar bool whether to show a progress bar. False Returns: Type Description Dict [ str , PhaseDiagram ] Dictionary of PhaseDiagram objects indexed by chemical subsystem string; Dict [ str , PhaseDiagram ] e.g. {\"Li-Mn-O\": , \"C-Y\": , ...} Source code in rxn_network/thermo/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def expand_pd ( entries : Iterable [ Entry ], pbar : bool = False ) -> Dict [ str , PhaseDiagram ]: \"\"\" Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic stability in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Args: entries ([Entry]): list of Entry objects for building phase diagram. pbar (bool): whether to show a progress bar. Returns: Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": <PhaseDiagram object>, \"C-Y\": <PhaseDiagram object>, ...} \"\"\" pd_dict : Dict [ str , PhaseDiagram ] = {} sorted_entries = sorted ( entries , key = lambda x : len ( x . composition . elements ), reverse = True ) for e in tqdm ( sorted_entries , disable = not pbar , desc = \"Building phase diagrams\" ): for chemsys in pd_dict : if set ( e . composition . chemical_system . split ( \"-\" )) . issubset ( chemsys . split ( \"-\" ) ): break else : pd_dict [ e . composition . chemical_system ] = PhaseDiagram ( list ( filter ( lambda x : set ( x . composition . elements ) . issubset ( e . composition . elements ), entries , ) ) ) return pd_dict","title":"Utils"},{"location":"reference/thermo/utils/#rxn_network.thermo.utils.expand_pd","text":"Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic stability in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Parameters: Name Type Description Default entries [ Entry ] list of Entry objects for building phase diagram. required pbar bool whether to show a progress bar. False Returns: Type Description Dict [ str , PhaseDiagram ] Dictionary of PhaseDiagram objects indexed by chemical subsystem string; Dict [ str , PhaseDiagram ] e.g. {\"Li-Mn-O\": , \"C-Y\": , ...} Source code in rxn_network/thermo/utils.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def expand_pd ( entries : Iterable [ Entry ], pbar : bool = False ) -> Dict [ str , PhaseDiagram ]: \"\"\" Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic stability in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Args: entries ([Entry]): list of Entry objects for building phase diagram. pbar (bool): whether to show a progress bar. Returns: Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": <PhaseDiagram object>, \"C-Y\": <PhaseDiagram object>, ...} \"\"\" pd_dict : Dict [ str , PhaseDiagram ] = {} sorted_entries = sorted ( entries , key = lambda x : len ( x . composition . elements ), reverse = True ) for e in tqdm ( sorted_entries , disable = not pbar , desc = \"Building phase diagrams\" ): for chemsys in pd_dict : if set ( e . composition . chemical_system . split ( \"-\" )) . issubset ( chemsys . split ( \"-\" ) ): break else : pd_dict [ e . composition . chemical_system ] = PhaseDiagram ( list ( filter ( lambda x : set ( x . composition . elements ) . issubset ( e . composition . elements ), entries , ) ) ) return pd_dict","title":"expand_pd()"},{"location":"reference/utils/funcs/","text":"Utility functions used throughout the reaction-network package. datetime_str () Get a string representation of the current time. Borrowed from atomate2. Source code in rxn_network/utils/funcs.py 83 84 85 86 87 def datetime_str () -> str : \"\"\" Get a string representation of the current time. Borrowed from atomate2. \"\"\" return str ( datetime . utcnow ()) get_logger ( name , level = logging . DEBUG , log_format = ' %(asctime)s %(levelname)s %(name)s %(message)s ' , stream = sys . stdout ) Code borrowed from the atomate package. Helper method for acquiring logger. Source code in rxn_network/utils/funcs.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def get_logger ( name : str , level = logging . DEBUG , log_format = \" %(asctime)s %(levelname)s %(name)s %(message)s \" , stream = sys . stdout , ): \"\"\" Code borrowed from the atomate package. Helper method for acquiring logger. \"\"\" logger = logging . getLogger ( name ) logger . setLevel ( level ) formatter = logging . Formatter ( log_format ) if logger . hasHandlers (): logger . handlers . clear () sh = logging . StreamHandler ( stream = stream ) sh . setFormatter ( formatter ) logger . addHandler ( sh ) return logger get_project_root () Gets a Path object for the reaction-network project root directory. Note This is specific to this file and project. Returns: Type Description Path Path object for the project root directory. Source code in rxn_network/utils/funcs.py 42 43 44 45 46 47 48 49 50 51 52 def get_project_root () -> Path : \"\"\" Gets a Path object for the reaction-network project root directory. Note: This is specific to this file and project. Returns: Path object for the project root directory. \"\"\" return Path ( __file__ ) . parent . parent . parent grouper ( iterable , n , fillvalue = None ) Collects data into fixed-length chunks or blocks. Parameters: Name Type Description Default iterable Iterable An iterable object to group. required n int The number of items to include in each group. required fillvalue Any The value to use for the last group, if the length of the group is less than n. None Source code in rxn_network/utils/funcs.py 28 29 30 31 32 33 34 35 36 37 38 39 def grouper ( iterable : Iterable , n : int , fillvalue : Any = None ): \"\"\" Collects data into fixed-length chunks or blocks. Args: iterable: An iterable object to group. n: The number of items to include in each group. fillvalue: The value to use for the last group, if the length of the group is less than n. \"\"\" args = [ iter ( iterable )] * n return zip_longest ( * args , fillvalue = fillvalue ) limited_powerset ( iterable , max_size ) Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Parameters: Name Type Description Default iterable list/set all objects to consider. required max_size int upper limit for size of combination subsets. required Returns: Type Description Iterable All combination sets up to maximum size Source code in rxn_network/utils/funcs.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def limited_powerset ( iterable , max_size ) -> Iterable : \"\"\" Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Args: iterable (list/set): all objects to consider. max_size (int): upper limit for size of combination subsets. Returns: All combination sets up to maximum size \"\"\" return chain . from_iterable ( [ combinations ( iterable , num_combos ) for num_combos in range ( 1 , max_size + 1 )] )","title":"Funcs"},{"location":"reference/utils/funcs/#rxn_network.utils.funcs.datetime_str","text":"Get a string representation of the current time. Borrowed from atomate2. Source code in rxn_network/utils/funcs.py 83 84 85 86 87 def datetime_str () -> str : \"\"\" Get a string representation of the current time. Borrowed from atomate2. \"\"\" return str ( datetime . utcnow ())","title":"datetime_str()"},{"location":"reference/utils/funcs/#rxn_network.utils.funcs.get_logger","text":"Code borrowed from the atomate package. Helper method for acquiring logger. Source code in rxn_network/utils/funcs.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 def get_logger ( name : str , level = logging . DEBUG , log_format = \" %(asctime)s %(levelname)s %(name)s %(message)s \" , stream = sys . stdout , ): \"\"\" Code borrowed from the atomate package. Helper method for acquiring logger. \"\"\" logger = logging . getLogger ( name ) logger . setLevel ( level ) formatter = logging . Formatter ( log_format ) if logger . hasHandlers (): logger . handlers . clear () sh = logging . StreamHandler ( stream = stream ) sh . setFormatter ( formatter ) logger . addHandler ( sh ) return logger","title":"get_logger()"},{"location":"reference/utils/funcs/#rxn_network.utils.funcs.get_project_root","text":"Gets a Path object for the reaction-network project root directory. Note This is specific to this file and project. Returns: Type Description Path Path object for the project root directory. Source code in rxn_network/utils/funcs.py 42 43 44 45 46 47 48 49 50 51 52 def get_project_root () -> Path : \"\"\" Gets a Path object for the reaction-network project root directory. Note: This is specific to this file and project. Returns: Path object for the project root directory. \"\"\" return Path ( __file__ ) . parent . parent . parent","title":"get_project_root()"},{"location":"reference/utils/funcs/#rxn_network.utils.funcs.grouper","text":"Collects data into fixed-length chunks or blocks. Parameters: Name Type Description Default iterable Iterable An iterable object to group. required n int The number of items to include in each group. required fillvalue Any The value to use for the last group, if the length of the group is less than n. None Source code in rxn_network/utils/funcs.py 28 29 30 31 32 33 34 35 36 37 38 39 def grouper ( iterable : Iterable , n : int , fillvalue : Any = None ): \"\"\" Collects data into fixed-length chunks or blocks. Args: iterable: An iterable object to group. n: The number of items to include in each group. fillvalue: The value to use for the last group, if the length of the group is less than n. \"\"\" args = [ iter ( iterable )] * n return zip_longest ( * args , fillvalue = fillvalue )","title":"grouper()"},{"location":"reference/utils/funcs/#rxn_network.utils.funcs.limited_powerset","text":"Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Parameters: Name Type Description Default iterable list/set all objects to consider. required max_size int upper limit for size of combination subsets. required Returns: Type Description Iterable All combination sets up to maximum size Source code in rxn_network/utils/funcs.py 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 def limited_powerset ( iterable , max_size ) -> Iterable : \"\"\" Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Args: iterable (list/set): all objects to consider. max_size (int): upper limit for size of combination subsets. Returns: All combination sets up to maximum size \"\"\" return chain . from_iterable ( [ combinations ( iterable , num_combos ) for num_combos in range ( 1 , max_size + 1 )] )","title":"limited_powerset()"},{"location":"reference/utils/ray/","text":"Functions for working with Ray. initialize_ray ( quiet = False ) Simple function to initialize ray. Basic support for running ray on multiple nodes. Currently supports SLURM and PBS job schedulers. SLURM Checks enviornment for existence of \"ip_head\" for situations where the user is running on multiple nodes. Automatically creats a new ray cluster if it has not been initialized. See https://github.com/NERSC/slurm-ray-cluster/ PBS Checks environment for PBS_NNODES > 1. Source code in rxn_network/utils/ray.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def initialize_ray ( quiet = False ): \"\"\" Simple function to initialize ray. Basic support for running ray on multiple nodes. Currently supports SLURM and PBS job schedulers. SLURM: Checks enviornment for existence of \"ip_head\" for situations where the user is running on multiple nodes. Automatically creats a new ray cluster if it has not been initialized. See https://github.com/NERSC/slurm-ray-cluster/ PBS: Checks environment for PBS_NNODES > 1. \"\"\" logger = logging . getLogger ( \"enumerator\" ) if not quiet : logger . setLevel ( \"INFO\" ) if not ray . is_initialized (): logger . info ( \"Ray is not initialized. Checking for existing cluster...\" ) if os . environ . get ( \"ip_head\" ) or int ( os . environ . get ( \"PBS_NNODES\" , 0 )) > 1 : ray . init ( address = \"auto\" , ) else : logger . info ( \"Could not identify existing Ray instance. Creating a new one...\" ) ray . init () logger . info ( f \"HOST: { ray . nodes ()[ 0 ][ 'NodeManagerHostname' ] } ,\" f \" { ray . nodes ()[ 0 ][ 'Resources' ] } \" ) to_iterator ( obj_ids ) Method to convert a list of ray object ids to an iterator that can be used in a for loop. Source code in rxn_network/utils/ray.py 42 43 44 45 46 47 48 49 def to_iterator ( obj_ids ): \"\"\" Method to convert a list of ray object ids to an iterator that can be used in a for loop. \"\"\" while obj_ids : done , obj_ids = ray . wait ( obj_ids ) yield ray . get ( done [ 0 ])","title":"Ray"},{"location":"reference/utils/ray/#rxn_network.utils.ray.initialize_ray","text":"Simple function to initialize ray. Basic support for running ray on multiple nodes. Currently supports SLURM and PBS job schedulers. SLURM Checks enviornment for existence of \"ip_head\" for situations where the user is running on multiple nodes. Automatically creats a new ray cluster if it has not been initialized. See https://github.com/NERSC/slurm-ray-cluster/ PBS Checks environment for PBS_NNODES > 1. Source code in rxn_network/utils/ray.py 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def initialize_ray ( quiet = False ): \"\"\" Simple function to initialize ray. Basic support for running ray on multiple nodes. Currently supports SLURM and PBS job schedulers. SLURM: Checks enviornment for existence of \"ip_head\" for situations where the user is running on multiple nodes. Automatically creats a new ray cluster if it has not been initialized. See https://github.com/NERSC/slurm-ray-cluster/ PBS: Checks environment for PBS_NNODES > 1. \"\"\" logger = logging . getLogger ( \"enumerator\" ) if not quiet : logger . setLevel ( \"INFO\" ) if not ray . is_initialized (): logger . info ( \"Ray is not initialized. Checking for existing cluster...\" ) if os . environ . get ( \"ip_head\" ) or int ( os . environ . get ( \"PBS_NNODES\" , 0 )) > 1 : ray . init ( address = \"auto\" , ) else : logger . info ( \"Could not identify existing Ray instance. Creating a new one...\" ) ray . init () logger . info ( f \"HOST: { ray . nodes ()[ 0 ][ 'NodeManagerHostname' ] } ,\" f \" { ray . nodes ()[ 0 ][ 'Resources' ] } \" )","title":"initialize_ray()"},{"location":"reference/utils/ray/#rxn_network.utils.ray.to_iterator","text":"Method to convert a list of ray object ids to an iterator that can be used in a for loop. Source code in rxn_network/utils/ray.py 42 43 44 45 46 47 48 49 def to_iterator ( obj_ids ): \"\"\" Method to convert a list of ray object ids to an iterator that can be used in a for loop. \"\"\" while obj_ids : done , obj_ids = ray . wait ( obj_ids ) yield ray . get ( done [ 0 ])","title":"to_iterator()"}]}