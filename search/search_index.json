{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u00b6 Reaction network (rxn-network) is a Python package for predicting chemical reaction pathways in solid-state materials synthesis using graph theory. Installing rxn-network \u00b6 The rxn-network package has several dependencies, most of which can be installed through PyPI. However, graph-tool must be installed through a more customized method; please see https://graph-tool.skewed.de/ for more details. We recommend the following installation procedure to create a new conda environment: conda create -n gt python=3.9 And then install graph-tool through conda-forge: conda install - c conda - forge graph - tool To install an editable version of the rxn-network code, simply download (clone) the code from this repository, navigate to its directory in terminal, and then run the following command to install the requirements: pip install -r requirements.txt And then to finally install an editable version of the package: pip install -e . Demo \u00b6 A demo Jupyter notebook (demo.ipynb) contains the code necessary to replicate the results of the paper and is a good starting template for using the rxn-network package. Note: this needs to be updated! How to cite rxn-network \u00b6 The following paper explains the methodology of the rxn-network package: McDermott, M. J., Dwaraknath, S. S., and Persson, K. A. (2021). A graph-based network for predicting chemical reaction pathways in solid-state materials synthesis. Nature Communications, 12(1). https://doi.org/10.1038/s41467-021-23339-x Acknowledgements \u00b6 This work was supported as part of GENESIS: A Next Generation Synthesis Center, an Energy Frontier Research Center funded by the U.S. Department of Energy, Office of Science, Basic Energy Sciences under Award Number DE-SC0019212. Learn more about the GENESIS EFRC here: https://www.stonybrook.edu/genesis/","title":"Home"},{"location":"#_1","text":"Reaction network (rxn-network) is a Python package for predicting chemical reaction pathways in solid-state materials synthesis using graph theory.","title":""},{"location":"#installing-rxn-network","text":"The rxn-network package has several dependencies, most of which can be installed through PyPI. However, graph-tool must be installed through a more customized method; please see https://graph-tool.skewed.de/ for more details. We recommend the following installation procedure to create a new conda environment: conda create -n gt python=3.9 And then install graph-tool through conda-forge: conda install - c conda - forge graph - tool To install an editable version of the rxn-network code, simply download (clone) the code from this repository, navigate to its directory in terminal, and then run the following command to install the requirements: pip install -r requirements.txt And then to finally install an editable version of the package: pip install -e .","title":"Installing rxn-network"},{"location":"#demo","text":"A demo Jupyter notebook (demo.ipynb) contains the code necessary to replicate the results of the paper and is a good starting template for using the rxn-network package. Note: this needs to be updated!","title":"Demo"},{"location":"#how-to-cite-rxn-network","text":"The following paper explains the methodology of the rxn-network package: McDermott, M. J., Dwaraknath, S. S., and Persson, K. A. (2021). A graph-based network for predicting chemical reaction pathways in solid-state materials synthesis. Nature Communications, 12(1). https://doi.org/10.1038/s41467-021-23339-x","title":"How to cite rxn-network"},{"location":"#acknowledgements","text":"This work was supported as part of GENESIS: A Next Generation Synthesis Center, an Energy Frontier Research Center funded by the U.S. Department of Energy, Office of Science, Basic Energy Sciences under Award Number DE-SC0019212. Learn more about the GENESIS EFRC here: https://www.stonybrook.edu/genesis/","title":"Acknowledgements"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v3.0.0 (2021-10-01) \u00b6 Full Changelog Merged pull requests: [WIP] Add much-needed tests #45 ( mattmcdermott ) v2.0.3 (2021-08-05) \u00b6 Full Changelog Merged pull requests: Update README and trigger release #34 ( shyamd ) v2.0.2 (2021-08-05) \u00b6 Full Changelog Merged pull requests: Bug fix for interdependent reactions #33 ( mattmcdermott ) v2.0.1 (2021-08-05) \u00b6 Full Changelog Merged pull requests: Fix and deploy docs #32 ( shyamd ) v2.0.0 (2021-08-05) \u00b6 Full Changelog Merged pull requests: Major refactor of entire reaction-network package #23 ( mattmcdermott ) paper (2021-04-15) \u00b6 Full Changelog Merged pull requests: Merging of major revision reaction-network code #5 ( mattmcdermott ) Repo Cleanup #4 ( shyamd ) v1.0 (2020-07-21) \u00b6 Full Changelog Merged pull requests: Added pathway balancing, NIST gas data, StructuralComplexity cost metric, and more. #3 ( mattmcdermott ) Implemented Gibbs Free Energy SISSO descriptor #2 ( mattmcdermott ) Added refactoring and documentation #1 ( mattmcdermott ) * This Changelog was automatically generated by github_changelog_generator","title":"CHANGELOG"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v300-2021-10-01","text":"Full Changelog Merged pull requests: [WIP] Add much-needed tests #45 ( mattmcdermott )","title":"v3.0.0 (2021-10-01)"},{"location":"CHANGELOG/#v203-2021-08-05","text":"Full Changelog Merged pull requests: Update README and trigger release #34 ( shyamd )","title":"v2.0.3 (2021-08-05)"},{"location":"CHANGELOG/#v202-2021-08-05","text":"Full Changelog Merged pull requests: Bug fix for interdependent reactions #33 ( mattmcdermott )","title":"v2.0.2 (2021-08-05)"},{"location":"CHANGELOG/#v201-2021-08-05","text":"Full Changelog Merged pull requests: Fix and deploy docs #32 ( shyamd )","title":"v2.0.1 (2021-08-05)"},{"location":"CHANGELOG/#v200-2021-08-05","text":"Full Changelog Merged pull requests: Major refactor of entire reaction-network package #23 ( mattmcdermott )","title":"v2.0.0 (2021-08-05)"},{"location":"CHANGELOG/#paper-2021-04-15","text":"Full Changelog Merged pull requests: Merging of major revision reaction-network code #5 ( mattmcdermott ) Repo Cleanup #4 ( shyamd )","title":"paper (2021-04-15)"},{"location":"CHANGELOG/#v10-2020-07-21","text":"Full Changelog Merged pull requests: Added pathway balancing, NIST gas data, StructuralComplexity cost metric, and more. #3 ( mattmcdermott ) Implemented Gibbs Free Energy SISSO descriptor #2 ( mattmcdermott ) Added refactoring and documentation #1 ( mattmcdermott ) * This Changelog was automatically generated by github_changelog_generator","title":"v1.0 (2020-07-21)"},{"location":"reference/utils/","text":"Utility functions used throughout the reaction-network package. limited_powerset ( iterable , max_size ) \u00b6 Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Parameters: Name Type Description Default iterable list/set all objects to consider. required max_size int upper limit for size of combination subsets. required Returns: Type Description list all combination sets up to maximum size Source code in rxn_network/utils.py def limited_powerset ( iterable , max_size ): \"\"\" Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Args: iterable (list/set): all objects to consider. max_size (int): upper limit for size of combination subsets. Returns: list: all combination sets up to maximum size \"\"\" return chain . from_iterable ( [ combinations ( iterable , num_combos ) for num_combos in range ( 1 , max_size + 1 )] )","title":"Utils"},{"location":"reference/utils/#rxn_network.utils.limited_powerset","text":"Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Parameters: Name Type Description Default iterable list/set all objects to consider. required max_size int upper limit for size of combination subsets. required Returns: Type Description list all combination sets up to maximum size Source code in rxn_network/utils.py def limited_powerset ( iterable , max_size ): \"\"\" Helper method for generating subsets ranging from singular length to maximum length specified by max_size. Args: iterable (list/set): all objects to consider. max_size (int): upper limit for size of combination subsets. Returns: list: all combination sets up to maximum size \"\"\" return chain . from_iterable ( [ combinations ( iterable , num_combos ) for num_combos in range ( 1 , max_size + 1 )] )","title":"limited_powerset()"},{"location":"reference/core/calculator/","text":"Basic interface for a reaction cost Calculator Calculator \u00b6 Base definition for a property calculator calculate ( self , rxn ) \u00b6 Evaluates the specified property of a reaction Source code in rxn_network/core/calculator.py @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\" decorate ( self , rxn ) \u00b6 Evaluates the specified prop. of a reaction and stores it in the reaction data Source code in rxn_network/core/calculator.py @abstractmethod def decorate ( self , rxn : Reaction ) -> \"Reaction\" : \"\"\" Evaluates the specified prop. of a reaction and stores it in the reaction data \"\"\"","title":"Calculator"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator","text":"Base definition for a property calculator","title":"Calculator"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.calculate","text":"Evaluates the specified property of a reaction Source code in rxn_network/core/calculator.py @abstractmethod def calculate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the specified property of a reaction \"\"\"","title":"calculate()"},{"location":"reference/core/calculator/#rxn_network.core.calculator.Calculator.decorate","text":"Evaluates the specified prop. of a reaction and stores it in the reaction data Source code in rxn_network/core/calculator.py @abstractmethod def decorate ( self , rxn : Reaction ) -> \"Reaction\" : \"\"\" Evaluates the specified prop. of a reaction and stores it in the reaction data \"\"\"","title":"decorate()"},{"location":"reference/core/cost_function/","text":"Basic interface for a cost function CostFunction \u00b6 Base definition for a cost function evaluate ( self , rxn ) \u00b6 Evaluates the total cost function on a reaction Source code in rxn_network/core/cost_function.py @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\"","title":"Cost Function"},{"location":"reference/core/cost_function/#rxn_network.core.cost_function.CostFunction","text":"Base definition for a cost function","title":"CostFunction"},{"location":"reference/core/cost_function/#rxn_network.core.cost_function.CostFunction.evaluate","text":"Evaluates the total cost function on a reaction Source code in rxn_network/core/cost_function.py @abstractmethod def evaluate ( self , rxn : Reaction ) -> float : \"\"\" Evaluates the total cost function on a reaction \"\"\"","title":"evaluate()"},{"location":"reference/core/enumerator/","text":"Basic interface for a reaction Enumerator Enumerator \u00b6 Base definition for the reaction enumeration methodology enumerate ( self , entries ) \u00b6 Enumerates the potential reactions from the list of entries Source code in rxn_network/core/enumerator.py @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\" estimate_max_num_reactions ( self , entries ) \u00b6 Estimate of the number of reactions from a list of entries Source code in rxn_network/core/enumerator.py @abstractmethod def estimate_max_num_reactions ( self , entries ) -> int : \"\"\" Estimate of the number of reactions from a list of entries \"\"\"","title":"Enumerator"},{"location":"reference/core/enumerator/#rxn_network.core.enumerator.Enumerator","text":"Base definition for the reaction enumeration methodology","title":"Enumerator"},{"location":"reference/core/enumerator/#rxn_network.core.enumerator.Enumerator.enumerate","text":"Enumerates the potential reactions from the list of entries Source code in rxn_network/core/enumerator.py @abstractmethod def enumerate ( self , entries ): \"\"\" Enumerates the potential reactions from the list of entries \"\"\"","title":"enumerate()"},{"location":"reference/core/enumerator/#rxn_network.core.enumerator.Enumerator.estimate_max_num_reactions","text":"Estimate of the number of reactions from a list of entries Source code in rxn_network/core/enumerator.py @abstractmethod def estimate_max_num_reactions ( self , entries ) -> int : \"\"\" Estimate of the number of reactions from a list of entries \"\"\"","title":"estimate_max_num_reactions()"},{"location":"reference/core/network/","text":"Basic interface for a (reaction) Network Network \u00b6 Base definition for a reaction network build ( self ) \u00b6 Construct the network from the supplied enumerators Source code in rxn_network/core/network.py @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\" find_pathways ( self , target , k ) \u00b6 Find reaction pathways Source code in rxn_network/core/network.py @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\" set_precursors ( self ) \u00b6 Set the phases used as precursors in the network Source code in rxn_network/core/network.py @abstractmethod def set_precursors ( self ): \"\"\"Set the phases used as precursors in the network\"\"\" set_target ( self ) \u00b6 Set the phase used as a target in the network Source code in rxn_network/core/network.py @abstractmethod def set_target ( self ): \"\"\"Set the phase used as a target in the network\"\"\"","title":"Network"},{"location":"reference/core/network/#rxn_network.core.network.Network","text":"Base definition for a reaction network","title":"Network"},{"location":"reference/core/network/#rxn_network.core.network.Network.build","text":"Construct the network from the supplied enumerators Source code in rxn_network/core/network.py @abstractmethod def build ( self ): \"\"\"Construct the network from the supplied enumerators\"\"\"","title":"build()"},{"location":"reference/core/network/#rxn_network.core.network.Network.find_pathways","text":"Find reaction pathways Source code in rxn_network/core/network.py @abstractmethod def find_pathways ( self , target , k ) -> List [ Pathway ]: \"\"\"Find reaction pathways\"\"\"","title":"find_pathways()"},{"location":"reference/core/network/#rxn_network.core.network.Network.set_precursors","text":"Set the phases used as precursors in the network Source code in rxn_network/core/network.py @abstractmethod def set_precursors ( self ): \"\"\"Set the phases used as precursors in the network\"\"\"","title":"set_precursors()"},{"location":"reference/core/network/#rxn_network.core.network.Network.set_target","text":"Set the phase used as a target in the network Source code in rxn_network/core/network.py @abstractmethod def set_target ( self ): \"\"\"Set the phase used as a target in the network\"\"\"","title":"set_target()"},{"location":"reference/core/pathway/","text":"Basic interface for a reaction Pathway Pathway \u00b6 Base definition for a reaction pathway all_products property readonly \u00b6 Entries serving as a product in any sub reaction all_reactants property readonly \u00b6 Entries serving as a reactant in any sub reaction compositions property readonly \u00b6 Compositions in the reaction energy property readonly \u00b6 Total energy of this reaction pathway energy_per_atom property readonly \u00b6 Total energy per atom of this reaction pathway entries property readonly \u00b6 Entry objects in this Pathway intermediates property readonly \u00b6 Intermediates as entries in this reaction pathway products property readonly \u00b6 The products of this whole reaction pathway reactants property readonly \u00b6 The reactants of this whole reaction pathway reactions : List [ rxn_network . core . reaction . Reaction ] property readonly \u00b6 List of reactions in this Pathway","title":"Pathway"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway","text":"Base definition for a reaction pathway","title":"Pathway"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.all_products","text":"Entries serving as a product in any sub reaction","title":"all_products"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.all_reactants","text":"Entries serving as a reactant in any sub reaction","title":"all_reactants"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.compositions","text":"Compositions in the reaction","title":"compositions"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.energy","text":"Total energy of this reaction pathway","title":"energy"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.energy_per_atom","text":"Total energy per atom of this reaction pathway","title":"energy_per_atom"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.entries","text":"Entry objects in this Pathway","title":"entries"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.intermediates","text":"Intermediates as entries in this reaction pathway","title":"intermediates"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.products","text":"The products of this whole reaction pathway","title":"products"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.reactants","text":"The reactants of this whole reaction pathway","title":"reactants"},{"location":"reference/core/pathway/#rxn_network.core.pathway.Pathway.reactions","text":"List of reactions in this Pathway","title":"reactions"},{"location":"reference/core/reaction/","text":"Basic interface for a (chemical) Reaction Reaction \u00b6 Base definition for a Reaction coefficients : ndarray property readonly \u00b6 Coefficients of the reaction compositions : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of all compositions in the reaction elements : List [ pymatgen . core . periodic_table . Element ] property readonly \u00b6 List of elements in the reaction energy : float property readonly \u00b6 The energy of this reaction in total eV energy_per_atom : float property readonly \u00b6 The energy per atom of this reaction in eV num_atoms : float property readonly \u00b6 Total number of atoms in this reaction products : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of products for this reaction reactants : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of reactants for this reaction","title":"Reaction"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction","text":"Base definition for a Reaction","title":"Reaction"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.coefficients","text":"Coefficients of the reaction","title":"coefficients"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.compositions","text":"List of all compositions in the reaction","title":"compositions"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.elements","text":"List of elements in the reaction","title":"elements"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.energy","text":"The energy of this reaction in total eV","title":"energy"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.energy_per_atom","text":"The energy per atom of this reaction in eV","title":"energy_per_atom"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.num_atoms","text":"Total number of atoms in this reaction","title":"num_atoms"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.products","text":"List of products for this reaction","title":"products"},{"location":"reference/core/reaction/#rxn_network.core.reaction.Reaction.reactants","text":"List of reactants for this reaction","title":"reactants"},{"location":"reference/core/solver/","text":"Basic interface for a reaction pathway Solver Solver \u00b6 Base definition for a pathway solver class costs : List [ float ] property readonly \u00b6 Costs used in solver class entries : EntrySet property readonly \u00b6 Entry set used in solver num_entries : int property readonly \u00b6 Length of entry list num_rxns : int property readonly \u00b6 Length of reaction list pathways : List [ rxn_network . core . pathway . Pathway ] property readonly \u00b6 Pathways used in solver class reactions : List [ rxn_network . core . reaction . Reaction ] property readonly \u00b6 Reactions used in solver class solve ( self , net_rxn ) \u00b6 Solve paths Source code in rxn_network/core/solver.py @abstractmethod def solve ( self , net_rxn ) -> List [ Pathway ]: \"\"\"Solve paths\"\"\"","title":"Solver"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver","text":"Base definition for a pathway solver class","title":"Solver"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.costs","text":"Costs used in solver class","title":"costs"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.entries","text":"Entry set used in solver","title":"entries"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.num_entries","text":"Length of entry list","title":"num_entries"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.num_rxns","text":"Length of reaction list","title":"num_rxns"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.pathways","text":"Pathways used in solver class","title":"pathways"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.reactions","text":"Reactions used in solver class","title":"reactions"},{"location":"reference/core/solver/#rxn_network.core.solver.Solver.solve","text":"Solve paths Source code in rxn_network/core/solver.py @abstractmethod def solve ( self , net_rxn ) -> List [ Pathway ]: \"\"\"Solve paths\"\"\"","title":"solve()"},{"location":"reference/costs/calculators/","text":"A calculator class for determining chemical potential distance of reactions ChempotDistanceCalculator \u00b6 Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, Paul K., McDermott, M.J., et al. \u201cSelectivity in yttrium manganese oxide synthesis via local chemical potentials in hyperdimensional phase space.\u201d ArXiv:2104.05986 [Cond-Mat], Apr. 2021. arXiv.org, http://arxiv.org/abs/2104.05986 mu_func property readonly \u00b6 Returns the function used to process the interfacial mu distances __init__ ( self , cpd , mu_func = 'sum' , name = 'chempot_distance' ) special \u00b6 Parameters: Name Type Description Default cpd ChemicalPotentialDiagram the chemical potential diagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key with which to store the calculated value. 'chempot_distance' Source code in rxn_network/costs/calculators.py def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key with which to store the calculated value. \"\"\" self . cpd = cpd self . name = name if mu_func == \"max\" : self . _mu_func = np . max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = np . sum # type: ignore calculate ( self , rxn ) \u00b6 Calculates the chemical potential distance in eV/atom. The mu_func parameter determines how the distance is calculated for the overall reaction. Parameters: Name Type Description Default rxn ComputedReaction the reaction object required Returns: Type Description float The chemical potential distance of the reaction. Source code in rxn_network/costs/calculators.py def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the chemical potential distance in eV/atom. The mu_func parameter determines how the distance is calculated for the overall reaction. Args: rxn: the reaction object Returns: The chemical potential distance of the reaction. \"\"\" combos = chain ( product ( rxn . reactant_entries , rxn . product_entries ), combinations ( rxn . product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , ) for combo in combos ] distance = float ( self . _mu_func ( distances )) return distance decorate ( self , rxn ) \u00b6 Decorates the reaction (in place) with the chemical potential distance by storing the value within the reaction's data dictionary. Parameters: Name Type Description Default rxn ComputedReaction The reaction object. required Returns: Type Description ComputedReaction The reaction object, modified in place Source code in rxn_network/costs/calculators.py def decorate ( self , rxn : ComputedReaction ) -> ComputedReaction : \"\"\" Decorates the reaction (in place) with the chemical potential distance by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" if not rxn . data : rxn . data = {} rxn . data [ self . name ] = self . calculate ( rxn ) return rxn from_entries ( entries , mu_func = 'sum' , name = 'chempot_distance' , ** kwargs ) classmethod \u00b6 Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Parameters: Name Type Description Default entries List[pymatgen.analysis.phase_diagram.PDEntry] entry objects used to build the ChemicalPotentialDiagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" 'chempot_distance' **kwargs optional kwargs passed to ChemicalPotentialDiagram; defaults to \"default_min_limit\"=-50 {} Returns: Type Description ChempotDistanceCalculator A ChempotDistanceCalculator object Source code in rxn_network/costs/calculators.py @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram; defaults to \"default_min_limit\"=-50 Returns: A ChempotDistanceCalculator object \"\"\" if not kwargs . get ( \"default_min_limit\" ): kwargs [ \"default_min_limit\" ] = - 50 cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name )","title":"Calculators"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator","text":"Calculator for determining the \"chemical potential distance\" for a reaction (in eV/atom). For more information on this specific implementation of the algorithm, please cite/reference the paper below: Todd, Paul K., McDermott, M.J., et al. \u201cSelectivity in yttrium manganese oxide synthesis via local chemical potentials in hyperdimensional phase space.\u201d ArXiv:2104.05986 [Cond-Mat], Apr. 2021. arXiv.org, http://arxiv.org/abs/2104.05986","title":"ChempotDistanceCalculator"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.mu_func","text":"Returns the function used to process the interfacial mu distances","title":"mu_func"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.__init__","text":"Parameters: Name Type Description Default cpd ChemicalPotentialDiagram the chemical potential diagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key with which to store the calculated value. 'chempot_distance' Source code in rxn_network/costs/calculators.py def __init__ ( self , cpd : ChemicalPotentialDiagram , mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ): \"\"\" Args: cpd: the chemical potential diagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key with which to store the calculated value. \"\"\" self . cpd = cpd self . name = name if mu_func == \"max\" : self . _mu_func = np . max # type: ignore elif mu_func == \"mean\" : self . _mu_func = np . mean # type: ignore elif mu_func == \"sum\" : self . _mu_func = np . sum # type: ignore","title":"__init__()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.calculate","text":"Calculates the chemical potential distance in eV/atom. The mu_func parameter determines how the distance is calculated for the overall reaction. Parameters: Name Type Description Default rxn ComputedReaction the reaction object required Returns: Type Description float The chemical potential distance of the reaction. Source code in rxn_network/costs/calculators.py def calculate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the chemical potential distance in eV/atom. The mu_func parameter determines how the distance is calculated for the overall reaction. Args: rxn: the reaction object Returns: The chemical potential distance of the reaction. \"\"\" combos = chain ( product ( rxn . reactant_entries , rxn . product_entries ), combinations ( rxn . product_entries , 2 ), ) distances = [ self . cpd . shortest_domain_distance ( combo [ 0 ] . composition . reduced_formula , combo [ 1 ] . composition . reduced_formula , ) for combo in combos ] distance = float ( self . _mu_func ( distances )) return distance","title":"calculate()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.decorate","text":"Decorates the reaction (in place) with the chemical potential distance by storing the value within the reaction's data dictionary. Parameters: Name Type Description Default rxn ComputedReaction The reaction object. required Returns: Type Description ComputedReaction The reaction object, modified in place Source code in rxn_network/costs/calculators.py def decorate ( self , rxn : ComputedReaction ) -> ComputedReaction : \"\"\" Decorates the reaction (in place) with the chemical potential distance by storing the value within the reaction's data dictionary. Args: rxn: The reaction object. Returns: The reaction object, modified in place \"\"\" if not rxn . data : rxn . data = {} rxn . data [ self . name ] = self . calculate ( rxn ) return rxn","title":"decorate()"},{"location":"reference/costs/calculators/#rxn_network.costs.calculators.ChempotDistanceCalculator.from_entries","text":"Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Parameters: Name Type Description Default entries List[pymatgen.analysis.phase_diagram.PDEntry] entry objects used to build the ChemicalPotentialDiagram required mu_func str the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. 'sum' name str the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" 'chempot_distance' **kwargs optional kwargs passed to ChemicalPotentialDiagram; defaults to \"default_min_limit\"=-50 {} Returns: Type Description ChempotDistanceCalculator A ChempotDistanceCalculator object Source code in rxn_network/costs/calculators.py @classmethod def from_entries ( cls , entries : List [ PDEntry ], mu_func : str = \"sum\" , name : str = \"chempot_distance\" , ** kwargs ) -> \"ChempotDistanceCalculator\" : \"\"\" Convenience constructor which first builds the ChemicalPotentialDiagram object from a list of entry objects. Args: entries: entry objects used to build the ChemicalPotentialDiagram mu_func: the name of the function used to process the interfacial chemical potential distances into a single value describing the whole reaction. name: the data dictionary key by which to store the calculated value, defaults to \"chempot_distance\" **kwargs: optional kwargs passed to ChemicalPotentialDiagram; defaults to \"default_min_limit\"=-50 Returns: A ChempotDistanceCalculator object \"\"\" if not kwargs . get ( \"default_min_limit\" ): kwargs [ \"default_min_limit\" ] = - 50 cpd = ChemicalPotentialDiagram ( entries = entries , ** kwargs ) return cls ( cpd , mu_func , name )","title":"from_entries()"},{"location":"reference/costs/softplus/","text":"Implementation of the softplus cost function Softplus \u00b6 The softplus cost function is a smooth version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for applying it to determine costs in reaction networks. __init__ ( self , temp = 300 , params = None , weights = None ) special \u00b6 Parameters: Name Type Description Default temp float Temperature [K]. 300 params Optional[List[str]] List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] None weights Optional[List[float]] List of corresponding values by which to weight the function parameters. Defaults to [1.0]. None Source code in rxn_network/costs/softplus.py def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Temperature [K]. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights ) evaluate ( self , rxn ) \u00b6 Calculates the ost of reaction based on the initialized parameters and weights. Parameters: Name Type Description Default rxn ComputedReaction A computed reaction to evaluate. required Returns: Type Description float The cost of the reaction. Source code in rxn_network/costs/softplus.py def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the ost of reaction based on the initialized parameters and weights. Args: rxn: A computed reaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp )","title":"Softplus"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus","text":"The softplus cost function is a smooth version of the Rectified Linear Unit ( ReLU) function commonly used in neural networks. It has the property that the output goes to 0 as the input goes to negative infinity, but the output approaches a linear scaling as the input goes to positive infinity. This is an especially useful mapping for applying it to determine costs in reaction networks.","title":"Softplus"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus.__init__","text":"Parameters: Name Type Description Default temp float Temperature [K]. 300 params Optional[List[str]] List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] None weights Optional[List[float]] List of corresponding values by which to weight the function parameters. Defaults to [1.0]. None Source code in rxn_network/costs/softplus.py def __init__ ( self , temp : float = 300 , params : Optional [ List [ str ]] = None , weights : Optional [ List [ float ]] = None , ): \"\"\" Args: temp: Temperature [K]. params: List of data dictionary keys for function parameters used as an argument to the softplus function. Defaults to [\"energy_per_atom\"] weights: List of corresponding values by which to weight the function parameters. Defaults to [1.0]. \"\"\" if params is None : params = [ \"energy_per_atom\" ] if weights is None : weights = [ 1.0 ] self . temp = temp self . params = params self . weights = np . array ( weights )","title":"__init__()"},{"location":"reference/costs/softplus/#rxn_network.costs.softplus.Softplus.evaluate","text":"Calculates the ost of reaction based on the initialized parameters and weights. Parameters: Name Type Description Default rxn ComputedReaction A computed reaction to evaluate. required Returns: Type Description float The cost of the reaction. Source code in rxn_network/costs/softplus.py def evaluate ( self , rxn : ComputedReaction ) -> float : \"\"\" Calculates the ost of reaction based on the initialized parameters and weights. Args: rxn: A computed reaction to evaluate. Returns: The cost of the reaction. \"\"\" values = [] for p in self . params : if rxn . data and p in rxn . data : value = rxn . data [ p ] elif hasattr ( rxn , p ): value = getattr ( rxn , p ) else : raise ValueError ( f \"Reaction is missing parameter { p } !\" ) values . append ( value ) values_arr = np . array ( values ) total = float ( np . dot ( values_arr , self . weights )) return self . _softplus ( total , self . temp )","title":"evaluate()"},{"location":"reference/data/data/","text":"Experimental Gibbs free energy data from NIST-JANAF (compounds, gases) and FactSage (elements)","title":"Data"},{"location":"reference/entries/entry_set/","text":"An entry set class for acquiring entries with Gibbs formation energies GibbsEntrySet \u00b6 An extension of pymatgen's EntrySet to include factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects. __init__ ( self , entries ) special \u00b6 The supplied collection of entries will automatically be converted to a set of unique entries. Parameters: Name Type Description Default entries List[Union[rxn_network.entries.gibbs.GibbsComputedEntry, rxn_network.entries.nist.NISTReferenceEntry]] A collection of entry objects that will make up the entry set. required Source code in rxn_network/entries/entry_set.py def __init__ ( self , entries : List [ Union [ GibbsComputedEntry , NISTReferenceEntry ]]): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. \"\"\" super () . __init__ ( entries ) self . entries_list = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . build_indices () filter_by_stability ( self , e_above_hull , include_polymorphs = False ) \u00b6 Filter the entry set by a metastability (energy above hull) cutoff. Parameters: Name Type Description Default e_above_hull float Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. required include_polymorphs Optional[bool] optional specification of whether to include metastable polymorphs. Defaults to False. False Returns: Type Description GibbsEntrySet A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. Source code in rxn_network/entries/entry_set.py def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = expand_pd ( self . entries ) filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = dict () for chemsys , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries )) from_entries ( entries , temperature ) classmethod \u00b6 Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedStructureEntry] List of ComputedStructureEntry objects, as downloaded from The Materials Project API. required temperature float Temperature for estimating Gibbs free energy of formation [K] required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py @classmethod def from_entries ( cls , entries : List [ ComputedStructureEntry ], temperature : float ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature ) pd_dict = expand_pd ( list ( e_set )) for chemsys , pd in tqdm ( pd_dict . items ()): gibbs_set = cls . from_pd ( pd , temperature ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries )) from_pd ( pd , temperature ) classmethod \u00b6 Constructor method for building a GibbsEntrySet from an existing phase diagram. Parameters: Name Type Description Default pd PhaseDiagram Phase Diagram object (pymatgen) required temperature float Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] for entry in pd . all_entries : if entry . composition . is_element and entry not in pd . el_refs . values (): continue composition = entry . composition if composition . reduced_formula in NISTReferenceEntry . REFERENCES : new_entry = NISTReferenceEntry ( composition = composition , temperature = temperature ) else : structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) new_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = None , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) gibbs_entries . append ( new_entry ) return cls ( gibbs_entries ) get_min_entry_by_formula ( self , formula ) \u00b6 Helper method for acquiring the ground state entry with the specified formula. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry Ground state computed entry object. Source code in rxn_network/entries/entry_set.py def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" comp = Composition ( formula ) . reduced_composition possible_entries = filter ( lambda x : x . composition . reduced_composition == comp , self . entries ) return sorted ( possible_entries , key = lambda x : x . energy_per_atom )[ 0 ] stabilize_entry ( self , entry , tol = 1e-06 ) \u00b6 Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. Parameters: Name Type Description Default entry ComputedEntry A computed entry object. required tol float The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. 1e-06 Returns: Type Description ComputedEntry A new ComputedEntry with energy adjustment making it appear to be stable. Source code in rxn_network/entries/entry_set.py def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" chemsys = [ str ( e ) for e in entry . composition . elements ] entries = self . get_subset_in_chemsys ( chemsys ) pd = PhaseDiagram ( entries ) e_above_hull = pd . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * pd . get_e_above_hull ( entry ) * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that \" \"entry is on the convex hull\" , ) entry_dict = entry . as_dict () entry_dict [ \"energy_adjustments\" ] . append ( adjustment ) new_entry = MontyDecoder () . process_decoded ( entry_dict ) return new_entry","title":"Entry Set"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet","text":"An extension of pymatgen's EntrySet to include factory methods for constructing GibbsComputedEntry objects from zero-temperature ComputedStructureEntry objects.","title":"GibbsEntrySet"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.__init__","text":"The supplied collection of entries will automatically be converted to a set of unique entries. Parameters: Name Type Description Default entries List[Union[rxn_network.entries.gibbs.GibbsComputedEntry, rxn_network.entries.nist.NISTReferenceEntry]] A collection of entry objects that will make up the entry set. required Source code in rxn_network/entries/entry_set.py def __init__ ( self , entries : List [ Union [ GibbsComputedEntry , NISTReferenceEntry ]]): \"\"\" The supplied collection of entries will automatically be converted to a set of unique entries. Args: entries: A collection of entry objects that will make up the entry set. \"\"\" super () . __init__ ( entries ) self . entries_list = list ( sorted ( entries , key = lambda e : e . composition . reduced_formula ) ) self . build_indices ()","title":"__init__()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.filter_by_stability","text":"Filter the entry set by a metastability (energy above hull) cutoff. Parameters: Name Type Description Default e_above_hull float Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. required include_polymorphs Optional[bool] optional specification of whether to include metastable polymorphs. Defaults to False. False Returns: Type Description GibbsEntrySet A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. Source code in rxn_network/entries/entry_set.py def filter_by_stability ( self , e_above_hull : float , include_polymorphs : Optional [ bool ] = False ) -> \"GibbsEntrySet\" : \"\"\" Filter the entry set by a metastability (energy above hull) cutoff. Args: e_above_hull: Energy above hull, the cutoff describing the allowed metastability of the entries as determined via phase diagram construction. include_polymorphs: optional specification of whether to include metastable polymorphs. Defaults to False. Returns: A new GibbsEntrySet where the entries have been filtered by an energy cutoff (e_above_hull) via phase diagram construction. \"\"\" pd_dict = expand_pd ( self . entries ) filtered_entries : Set [ Union [ GibbsComputedEntry , NISTReferenceEntry ]] = set () all_comps : Dict [ str , Union [ GibbsComputedEntry , NISTReferenceEntry ]] = dict () for chemsys , pd in pd_dict . items (): for entry in pd . all_entries : if ( entry in filtered_entries or pd . get_e_above_hull ( entry ) > e_above_hull ): continue formula = entry . composition . reduced_formula if not include_polymorphs and ( formula in all_comps ): if all_comps [ formula ] . energy_per_atom < entry . energy_per_atom : continue filtered_entries . remove ( all_comps [ formula ]) all_comps [ formula ] = entry filtered_entries . add ( entry ) return self . __class__ ( list ( filtered_entries ))","title":"filter_by_stability()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.from_entries","text":"Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedStructureEntry] List of ComputedStructureEntry objects, as downloaded from The Materials Project API. required temperature float Temperature for estimating Gibbs free energy of formation [K] required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py @classmethod def from_entries ( cls , entries : List [ ComputedStructureEntry ], temperature : float ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for initializing GibbsEntrySet from T = 0 K ComputedStructureEntry objects, as acquired from a thermochemical database e.g. The Materials Project. Automatically expands the phase diagram for large chemical systems (10 or more elements) to avoid limitations of Qhull. Args: entries: List of ComputedStructureEntry objects, as downloaded from The Materials Project API. temperature: Temperature for estimating Gibbs free energy of formation [K] Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" e_set = EntrySet ( entries ) new_entries : Set [ GibbsComputedEntry ] = set () if len ( e_set . chemsys ) <= 9 : # Qhull algorithm struggles beyond 9 dimensions pd = PhaseDiagram ( e_set ) return cls . from_pd ( pd , temperature ) pd_dict = expand_pd ( list ( e_set )) for chemsys , pd in tqdm ( pd_dict . items ()): gibbs_set = cls . from_pd ( pd , temperature ) new_entries . update ( gibbs_set ) return cls ( list ( new_entries ))","title":"from_entries()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.from_pd","text":"Constructor method for building a GibbsEntrySet from an existing phase diagram. Parameters: Name Type Description Default pd PhaseDiagram Phase Diagram object (pymatgen) required temperature float Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) required Returns: Type Description GibbsEntrySet A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. Source code in rxn_network/entries/entry_set.py @classmethod def from_pd ( cls , pd : PhaseDiagram , temperature : float ) -> \"GibbsEntrySet\" : \"\"\" Constructor method for building a GibbsEntrySet from an existing phase diagram. Args: pd: Phase Diagram object (pymatgen) temperature: Temperature [K] for determining Gibbs Free Energy of formation, dGf(T) Returns: A GibbsEntrySet containing a collection of GibbsComputedEntry and experimental reference entry objects at the specified temperature. \"\"\" gibbs_entries = [] for entry in pd . all_entries : if entry . composition . is_element and entry not in pd . el_refs . values (): continue composition = entry . composition if composition . reduced_formula in NISTReferenceEntry . REFERENCES : new_entry = NISTReferenceEntry ( composition = composition , temperature = temperature ) else : structure = entry . structure formation_energy_per_atom = pd . get_form_energy_per_atom ( entry ) new_entry = GibbsComputedEntry . from_structure ( structure = structure , formation_energy_per_atom = formation_energy_per_atom , temperature = temperature , energy_adjustments = None , parameters = entry . parameters , data = entry . data , entry_id = entry . entry_id , ) gibbs_entries . append ( new_entry ) return cls ( gibbs_entries )","title":"from_pd()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.get_min_entry_by_formula","text":"Helper method for acquiring the ground state entry with the specified formula. Parameters: Name Type Description Default formula str The chemical formula of the desired entry. required Returns: Type Description ComputedEntry Ground state computed entry object. Source code in rxn_network/entries/entry_set.py def get_min_entry_by_formula ( self , formula : str ) -> ComputedEntry : \"\"\" Helper method for acquiring the ground state entry with the specified formula. Args: formula: The chemical formula of the desired entry. Returns: Ground state computed entry object. \"\"\" comp = Composition ( formula ) . reduced_composition possible_entries = filter ( lambda x : x . composition . reduced_composition == comp , self . entries ) return sorted ( possible_entries , key = lambda x : x . energy_per_atom )[ 0 ]","title":"get_min_entry_by_formula()"},{"location":"reference/entries/entry_set/#rxn_network.entries.entry_set.GibbsEntrySet.stabilize_entry","text":"Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. Parameters: Name Type Description Default entry ComputedEntry A computed entry object. required tol float The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. 1e-06 Returns: Type Description ComputedEntry A new ComputedEntry with energy adjustment making it appear to be stable. Source code in rxn_network/entries/entry_set.py def stabilize_entry ( self , entry : ComputedEntry , tol : float = 1e-6 ) -> ComputedEntry : \"\"\" Helper method for lowering the energy of a single entry such that it is just barely stable on the phase diagram. Args: entry: A computed entry object. tol: The numerical padding added to the energy correction to guarantee that it is determined to be stable during phase diagram construction. Returns: A new ComputedEntry with energy adjustment making it appear to be stable. \"\"\" chemsys = [ str ( e ) for e in entry . composition . elements ] entries = self . get_subset_in_chemsys ( chemsys ) pd = PhaseDiagram ( entries ) e_above_hull = pd . get_e_above_hull ( entry ) if e_above_hull == 0.0 : new_entry = entry else : e_adj = - 1 * pd . get_e_above_hull ( entry ) * entry . composition . num_atoms - tol adjustment = ConstantEnergyAdjustment ( value = e_adj , name = \"Stabilization Adjustment\" , description = \"Shifts energy so that \" \"entry is on the convex hull\" , ) entry_dict = entry . as_dict () entry_dict [ \"energy_adjustments\" ] . append ( adjustment ) new_entry = MontyDecoder () . process_decoded ( entry_dict ) return new_entry","title":"stabilize_entry()"},{"location":"reference/entries/gibbs/","text":"Specialized computed entry to estimate Gibbs free energy of formation GibbsComputedEntry \u00b6 An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2). __init__ ( self , composition , formation_energy_per_atom , volume_per_atom , temperature , energy_adjustments = None , parameters = None , data = None , entry_id = None ) special \u00b6 A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Parameters: Name Type Description Default composition Composition The composition object (pymatgen) required formation_energy_per_atom float Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. required volume_per_atom float The total volume of the associated structure divided by the total number of atoms. required temperature float Temperature [K] by which to acquire dGf(T), must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. required energy_adjustments Optional[List] Optional list of energy adjustments None parameters Optional[dict] Optional list of calculation parameters None data Optional[dict] Optional dictionary containing entry data None entry_id Optional[object] Optional entry-id, such as the entry's mp-id None Source code in rxn_network/entries/gibbs.py def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List ] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. volume_per_atom: The total volume of the associated structure divided by the total number of atoms. temperature: Temperature [K] by which to acquire dGf(T), must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" self . _composition = Composition ( composition ) self . formation_energy_per_atom = formation_energy_per_atom self . volume_per_atom = volume_per_atom self . temperature = temperature num_atoms = self . _composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { self . temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , ) as_dict ( self ) \u00b6 Returns an MSONable dict. Source code in rxn_network/entries/gibbs.py def as_dict ( self ) -> dict : \"Returns an MSONable dict.\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data from_dict ( d ) classmethod \u00b6 Returns a GibbsComputedEntry object from MSONable dictionary Source code in rxn_network/entries/gibbs.py @classmethod def from_dict ( cls , d ) -> \"GibbsComputedEntry\" : \"Returns a GibbsComputedEntry object from MSONable dictionary\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry from_structure ( structure , formation_energy_per_atom , temperature , ** kwargs ) classmethod \u00b6 Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Parameters: Name Type Description Default structure Structure Structure object (pymatgen) required formation_energy_per_atom float Formation enthalpy at T = 298 K associated with structure required temperature float Desired temperature [K] for acquiring dGf(T) required **kwargs Optional kwargs to be passed to init method of GibbsComputedEntry {} Returns: Type Description GibbsComputedEntry A new GibbsComputedEntry object Source code in rxn_network/entries/gibbs.py @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to init method of GibbsComputedEntry Returns: A new GibbsComputedEntry object \"\"\" composition = structure . composition volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry get_new_temperature ( self , new_temperature ) \u00b6 Return a copy of the GibbsComputedEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description GibbsComputedEntry A copy of the GibbsComputedEntry at the new specified temperature. Source code in rxn_network/entries/gibbs.py def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry gibbs_adjustment ( self , temperature ) \u00b6 Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Parameters: Name Type Description Default temperature float The absolute temperature [K]. required Returns: Type Description float The correction to Gibbs free energy of formation (eV) from DFT energy. Source code in rxn_network/entries/gibbs.py def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature )","title":"Gibbs"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry","text":"An extension to ComputedEntry which estimates the Gibbs free energy of formation of solids using energy adjustments from the machine-learned SISSO descriptor from Bartel et al. (2018). WARNING: This descriptor only applies to solids. See entries.nist.NISTReferenceEntry for common gases (e.g. CO2).","title":"GibbsComputedEntry"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.__init__","text":"A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Parameters: Name Type Description Default composition Composition The composition object (pymatgen) required formation_energy_per_atom float Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. required volume_per_atom float The total volume of the associated structure divided by the total number of atoms. required temperature float Temperature [K] by which to acquire dGf(T), must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. required energy_adjustments Optional[List] Optional list of energy adjustments None parameters Optional[dict] Optional list of calculation parameters None data Optional[dict] Optional dictionary containing entry data None entry_id Optional[object] Optional entry-id, such as the entry's mp-id None Source code in rxn_network/entries/gibbs.py def __init__ ( self , composition : Composition , formation_energy_per_atom : float , volume_per_atom : float , temperature : float , energy_adjustments : Optional [ List ] = None , parameters : Optional [ dict ] = None , data : Optional [ dict ] = None , entry_id : Optional [ object ] = None , ): \"\"\" A new computed entry object is returned with a supplied energy correction representing the difference between the formation enthalpy at T=0K and the Gibbs formation energy at the specified temperature. Args: composition: The composition object (pymatgen) formation_energy_per_atom: Calculated formation enthalpy, dH, at T = 298 K, normalized to the total number of atoms in the composition. volume_per_atom: The total volume of the associated structure divided by the total number of atoms. temperature: Temperature [K] by which to acquire dGf(T), must be selected from a range of [300, 2000] K. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. energy_adjustments: Optional list of energy adjustments parameters: Optional list of calculation parameters data: Optional dictionary containing entry data entry_id: Optional entry-id, such as the entry's mp-id \"\"\" self . _composition = Composition ( composition ) self . formation_energy_per_atom = formation_energy_per_atom self . volume_per_atom = volume_per_atom self . temperature = temperature num_atoms = self . _composition . num_atoms if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K.\" ) if energy_adjustments is not None : energy_adjustments = [ adjustment for adjustment in energy_adjustments if adjustment . name != \"Gibbs SISSO Correction\" ] else : energy_adjustments = [] energy_adjustments . append ( ConstantEnergyAdjustment ( self . gibbs_adjustment ( temperature ), uncertainty = 0.05 * num_atoms , # descriptor has ~50 meV/atom MAD name = \"Gibbs SISSO Correction\" , description = f \"Gibbs correction: dGf( { self . temperature } K) - dHf (298 K)\" , ) ) formation_energy = num_atoms * formation_energy_per_atom super () . __init__ ( composition = composition , energy = formation_energy , energy_adjustments = energy_adjustments , parameters = parameters , data = data , entry_id = entry_id , )","title":"__init__()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.as_dict","text":"Returns an MSONable dict. Source code in rxn_network/entries/gibbs.py def as_dict ( self ) -> dict : \"Returns an MSONable dict.\" data = super () . as_dict () data [ \"volume_per_atom\" ] = self . volume_per_atom data [ \"formation_energy_per_atom\" ] = self . formation_energy_per_atom data [ \"temperature\" ] = self . temperature return data","title":"as_dict()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.from_dict","text":"Returns a GibbsComputedEntry object from MSONable dictionary Source code in rxn_network/entries/gibbs.py @classmethod def from_dict ( cls , d ) -> \"GibbsComputedEntry\" : \"Returns a GibbsComputedEntry object from MSONable dictionary\" dec = MontyDecoder () entry = cls ( composition = d [ \"composition\" ], formation_energy_per_atom = d [ \"formation_energy_per_atom\" ], volume_per_atom = d [ \"volume_per_atom\" ], temperature = d [ \"temperature\" ], energy_adjustments = dec . process_decoded ( d [ \"energy_adjustments\" ]), parameters = d [ \"parameters\" ], data = d [ \"data\" ], entry_id = d [ \"entry_id\" ], ) return entry","title":"from_dict()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.from_structure","text":"Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Parameters: Name Type Description Default structure Structure Structure object (pymatgen) required formation_energy_per_atom float Formation enthalpy at T = 298 K associated with structure required temperature float Desired temperature [K] for acquiring dGf(T) required **kwargs Optional kwargs to be passed to init method of GibbsComputedEntry {} Returns: Type Description GibbsComputedEntry A new GibbsComputedEntry object Source code in rxn_network/entries/gibbs.py @classmethod def from_structure ( cls , structure : Structure , formation_energy_per_atom : float , temperature : float , ** kwargs , ) -> \"GibbsComputedEntry\" : \"\"\" Constructor method for building a GibbsComputedEntry from a structure, formation enthalpy, and temperature. Args: structure: Structure object (pymatgen) formation_energy_per_atom: Formation enthalpy at T = 298 K associated with structure temperature: Desired temperature [K] for acquiring dGf(T) **kwargs: Optional kwargs to be passed to init method of GibbsComputedEntry Returns: A new GibbsComputedEntry object \"\"\" composition = structure . composition volume_per_atom = structure . volume / structure . num_sites entry = cls ( composition = composition , formation_energy_per_atom = formation_energy_per_atom , volume_per_atom = volume_per_atom , temperature = temperature , ** kwargs , ) return entry","title":"from_structure()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.get_new_temperature","text":"Return a copy of the GibbsComputedEntry at the new specified temperature. Parameters: Name Type Description Default new_temperature float The new temperature to use [K] required Returns: Type Description GibbsComputedEntry A copy of the GibbsComputedEntry at the new specified temperature. Source code in rxn_network/entries/gibbs.py def get_new_temperature ( self , new_temperature : float ) -> \"GibbsComputedEntry\" : \"\"\" Return a copy of the GibbsComputedEntry at the new specified temperature. Args: new_temperature: The new temperature to use [K] Returns: A copy of the GibbsComputedEntry at the new specified temperature. \"\"\" new_entry_dict = self . as_dict () new_entry_dict [ \"temperature\" ] = new_temperature new_entry = self . from_dict ( new_entry_dict ) return new_entry","title":"get_new_temperature()"},{"location":"reference/entries/gibbs/#rxn_network.entries.gibbs.GibbsComputedEntry.gibbs_adjustment","text":"Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Parameters: Name Type Description Default temperature float The absolute temperature [K]. required Returns: Type Description float The correction to Gibbs free energy of formation (eV) from DFT energy. Source code in rxn_network/entries/gibbs.py def gibbs_adjustment ( self , temperature : float ) -> float : \"\"\" Returns the difference between the predicted Gibbs formation energy and the formation enthalpy at 298 K, i.e., dGf(T) - dHf(298 K). Calculated using SISSO descriptor from Bartel et al. (2018) and elemental chemical potentials (FactSage). Units: eV (not normalized) Reference: Bartel, C. J., Millican, S. L., Deml, A. M., Rumptz, J. R., Tumas, W., Weimer, A. W., \u2026 Holder, A. M. (2018). Physical descriptor for the Gibbs energy of inorganic crystalline solids and temperature-dependent materials chemistry. Nature Communications, 9(1), 4168. https://doi.org/10.1038/s41467-018-06682-4 Args: temperature: The absolute temperature [K]. Returns: The correction to Gibbs free energy of formation (eV) from DFT energy. \"\"\" if self . _composition . is_element : return 0 num_atoms = self . _composition . num_atoms reduced_mass = self . _reduced_mass ( self . _composition ) return num_atoms * self . _g_delta_sisso ( self . volume_per_atom , reduced_mass , temperature ) - self . _sum_g_i ( self . _composition , temperature )","title":"gibbs_adjustment()"},{"location":"reference/entries/nist/","text":"Implements an Entry that looks up NIST pre-tabulated Gibbs free energies NISTReferenceEntry \u00b6 An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values (G_GASES, G_COMPOUNDS). Reference Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998. correction_uncertainty : float property readonly \u00b6 Uncertainty of NIST-JANAF data is not supplied. correction_uncertainty_per_atom : float property readonly \u00b6 Uncertainty of NIST-JANAF data is not supplied. energy : float property readonly \u00b6 The energy of the entry, as supplied by the NIST-JANAF tables. is_experimental : bool property readonly \u00b6 Returns True by default. __init__ ( self , composition , temperature ) special \u00b6 Parameters: Name Type Description Default composition Composition Composition object (pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required Source code in rxn_network/entries/nist.py def __init__ ( self , composition : Composition , temperature : float ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" composition = Composition ( composition ) formula = composition . reduced_formula if formula not in NISTReferenceEntry . REFERENCES : raise ValueError ( \"Formula must be in NIST-JANAF thermochemical tables\" ) if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K\" ) energy = self . _get_nist_energy ( formula , temperature ) self . temperature = temperature self . _formula = formula self . name = formula self . entry_id = \"NISTReferenceEntry\" self . data = {} # type: Dict[Any, Any] super () . __init__ ( composition . reduced_composition , energy ) as_dict ( self ) \u00b6 Returns an MSONable dict. Source code in rxn_network/entries/nist.py def as_dict ( self ) -> dict : \"\"\" Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"temperature\" ] = self . temperature return data from_dict ( d ) classmethod \u00b6 Returns NISTReferenceEntry constructed from MSONable dict. Source code in rxn_network/entries/nist.py @classmethod def from_dict ( cls , d ) -> \"NISTReferenceEntry\" : \"\"\" Returns NISTReferenceEntry constructed from MSONable dict.\"\"\" return cls ( composition = d [ \"composition\" ], temperature = d [ \"temperature\" ])","title":"Nist"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry","text":"An Entry class for NIST-JANAF experimental reference data. Given a composition, automatically finds the Gibbs free energy of formation, dGf(T) from tabulated reference values (G_GASES, G_COMPOUNDS). Reference Malcolm W. Chase Jr. NIST-JANAF thermochemical tables. Fourth edition. Washington, DC : American Chemical Society; New York : American Institute of Physics for the National Institute of Standards and Technology, 1998.","title":"NISTReferenceEntry"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.correction_uncertainty","text":"Uncertainty of NIST-JANAF data is not supplied.","title":"correction_uncertainty"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.correction_uncertainty_per_atom","text":"Uncertainty of NIST-JANAF data is not supplied.","title":"correction_uncertainty_per_atom"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.energy","text":"The energy of the entry, as supplied by the NIST-JANAF tables.","title":"energy"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.is_experimental","text":"Returns True by default.","title":"is_experimental"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.__init__","text":"Parameters: Name Type Description Default composition Composition Composition object (pymatgen). required temperature float Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. required Source code in rxn_network/entries/nist.py def __init__ ( self , composition : Composition , temperature : float ): \"\"\" Args: composition: Composition object (pymatgen). temperature: Temperature in Kelvin. If temperature is not selected from one of [300, 400, 500, ... 2000 K], then free energies will be interpolated. Defaults to 300 K. \"\"\" composition = Composition ( composition ) formula = composition . reduced_formula if formula not in NISTReferenceEntry . REFERENCES : raise ValueError ( \"Formula must be in NIST-JANAF thermochemical tables\" ) if temperature < 300 or temperature > 2000 : raise ValueError ( \"Temperature must be selected from range: [300, 2000] K\" ) energy = self . _get_nist_energy ( formula , temperature ) self . temperature = temperature self . _formula = formula self . name = formula self . entry_id = \"NISTReferenceEntry\" self . data = {} # type: Dict[Any, Any] super () . __init__ ( composition . reduced_composition , energy )","title":"__init__()"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.as_dict","text":"Returns an MSONable dict. Source code in rxn_network/entries/nist.py def as_dict ( self ) -> dict : \"\"\" Returns an MSONable dict.\"\"\" data = super () . as_dict () data [ \"temperature\" ] = self . temperature return data","title":"as_dict()"},{"location":"reference/entries/nist/#rxn_network.entries.nist.NISTReferenceEntry.from_dict","text":"Returns NISTReferenceEntry constructed from MSONable dict. Source code in rxn_network/entries/nist.py @classmethod def from_dict ( cls , d ) -> \"NISTReferenceEntry\" : \"\"\" Returns NISTReferenceEntry constructed from MSONable dict.\"\"\" return cls ( composition = d [ \"composition\" ], temperature = d [ \"temperature\" ])","title":"from_dict()"},{"location":"reference/enumerators/basic/","text":"This module implements two types of basic reaction enumerators, with or without the option of an open entry BasicEnumerator \u00b6 Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant and product cardinality (n). build_grand_pd property readonly \u00b6 Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses) build_pd property readonly \u00b6 Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses) stabilize property readonly \u00b6 Whether or not to use only stable entries in analysis __init__ ( self , precursors = None , target = None , calculators = None , n = 2 , remove_unbalanced = True , remove_changed = True ) special \u00b6 Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default precursors Optional[List[str]] Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. None target Optional[str] Optional formula of target; only reactions which include formation of this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. 2 remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True. True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True Source code in rxn_network/enumerators/basic.py def __init__ ( self , precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , n : int = 2 , remove_unbalanced : bool = True , remove_changed : bool = True , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. target: Optional formula of target; only reactions which include formation of this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. \"\"\" super () . __init__ ( precursors , target , calculators ) self . n = n self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . _stabilize = False if \"ChempotDistanceCalculator\" in self . calculators : self . _stabilize = True self . _build_pd = False self . _build_grand_pd = False enumerate ( self , entries ) \u00b6 Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: Initialize entries, i.e. ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. Get a dictionary representing every possible node, i.e. phase combination, grouped by chemical system. Filter the combos dictionary for chemical systems which are not relevant ( i.e. don't contain elements in precursors and/or target. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Parameters: Name Type Description Default entries GibbsEntrySet the set of all entries to enumerate from required Source code in rxn_network/enumerators/basic.py def enumerate ( self , entries : GibbsEntrySet ) -> List [ ComputedReaction ]: \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e. ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible node, i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant ( i.e. don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" entries , precursors , target = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , target ) open_combos = self . _get_open_combos ( entries ) pbar = tqdm ( combos_dict . items (), desc = self . __class__ . __name__ ) rxns = [] for chemsys , combos in pbar : pbar . set_description ( f \" { chemsys } \" ) filtered_entries = filter_entries_by_chemsys ( entries , chemsys ) calculators = initialize_calculators ( self . calculators , filtered_entries ) rxn_iter = self . _get_rxn_iterable ( combos , open_combos ) r = self . _get_rxns ( rxn_iter , precursors , target , calculators , filtered_entries ) rxns . extend ( r ) return list ( set ( rxns )) estimate_max_num_reactions ( self , entries ) \u00b6 Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/basic.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" return sum ([ comb ( len ( entries ), i ) for i in range ( 1 , self . n + 1 )]) ** 2 BasicOpenEnumerator \u00b6 Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class). __init__ ( self , open_phases , precursors = None , target = None , calculators = None , n = 2 , remove_unbalanced = True , remove_changed = True ) special \u00b6 Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default open_phases List[str] List of formulas of open entries (e.g. [\"O2\"]) required precursors Optional[List[str]] Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. None target Optional[str] Optional formula of target; only reactions which make this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. 2 remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True Source code in rxn_network/enumerators/basic.py def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , n : int = 2 , remove_unbalanced : bool = True , remove_changed : bool = True , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. target: Optional formula of target; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. \"\"\" super () . __init__ ( precursors , target , calculators , n , remove_unbalanced , remove_changed ) self . open_phases = open_phases estimate_max_num_reactions ( self , entries ) \u00b6 Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/basic.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" num_open_phases = len ( self . open_phases ) num_combos_with_open = sum ( [ comb ( num_open_phases , i ) for i in range ( 1 , num_open_phases + 1 )] ) num_total_combos = 0 for i in range ( 1 , self . n + 1 ): num_combos = comb ( len ( entries ), i ) num_total_combos += num_combos_with_open * num_combos return num_total_combos ** 2","title":"Basic"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator","text":"Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant and product cardinality (n).","title":"BasicEnumerator"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.build_grand_pd","text":"Whether or not to build a GrandPotentialPhaseDiagram object during reaction enumeration (useful for some analyses)","title":"build_grand_pd"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.build_pd","text":"Whether or not to build a PhaseDiagram object during reaction enumeration ( useful for some analyses)","title":"build_pd"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.stabilize","text":"Whether or not to use only stable entries in analysis","title":"stabilize"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.__init__","text":"Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default precursors Optional[List[str]] Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. None target Optional[str] Optional formula of target; only reactions which include formation of this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. 2 remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True. True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True Source code in rxn_network/enumerators/basic.py def __init__ ( self , precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , n : int = 2 , remove_unbalanced : bool = True , remove_changed : bool = True , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: precursors: Optional list of precursor formulas; only reactions which contain at least these phases as reactants will be enumerated. target: Optional formula of target; only reactions which include formation of this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. Defaults to 2. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True. remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. \"\"\" super () . __init__ ( precursors , target , calculators ) self . n = n self . remove_unbalanced = remove_unbalanced self . remove_changed = remove_changed self . _stabilize = False if \"ChempotDistanceCalculator\" in self . calculators : self . _stabilize = True self . _build_pd = False self . _build_grand_pd = False","title":"__init__()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.enumerate","text":"Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: Initialize entries, i.e. ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. Get a dictionary representing every possible node, i.e. phase combination, grouped by chemical system. Filter the combos dictionary for chemical systems which are not relevant ( i.e. don't contain elements in precursors and/or target. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Parameters: Name Type Description Default entries GibbsEntrySet the set of all entries to enumerate from required Source code in rxn_network/enumerators/basic.py def enumerate ( self , entries : GibbsEntrySet ) -> List [ ComputedReaction ]: \"\"\" Calculate all possible reactions given a set of entries. If the enumerator was initialized with specified precursors or target, the reactions will be filtered by these constraints. Every enumerator follows a standard procedure: 1. Initialize entries, i.e. ensure that precursors and target are considered stable entries within the entry set. If using ChempotDistanceCalculator, ensure that entries are filtered by stability. 2. Get a dictionary representing every possible node, i.e. phase combination, grouped by chemical system. 3. Filter the combos dictionary for chemical systems which are not relevant ( i.e. don't contain elements in precursors and/or target. 4. Iterate through each chemical system, initializing calculators, and computing all possible reactions for reactant/product pair and/or thermodynamically predicted reactions for given reactants. 5. Add reactions to growing list, repeat Step 4 until combos dict exhausted. Args: entries: the set of all entries to enumerate from \"\"\" entries , precursors , target = self . _get_initialized_entries ( entries ) combos_dict = self . _get_combos_dict ( entries , precursors , target ) open_combos = self . _get_open_combos ( entries ) pbar = tqdm ( combos_dict . items (), desc = self . __class__ . __name__ ) rxns = [] for chemsys , combos in pbar : pbar . set_description ( f \" { chemsys } \" ) filtered_entries = filter_entries_by_chemsys ( entries , chemsys ) calculators = initialize_calculators ( self . calculators , filtered_entries ) rxn_iter = self . _get_rxn_iterable ( combos , open_combos ) r = self . _get_rxns ( rxn_iter , precursors , target , calculators , filtered_entries ) rxns . extend ( r ) return list ( set ( rxns ))","title":"enumerate()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicEnumerator.estimate_max_num_reactions","text":"Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/basic.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" return sum ([ comb ( len ( entries ), i ) for i in range ( 1 , self . n + 1 )]) ** 2","title":"estimate_max_num_reactions()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicOpenEnumerator","text":"Enumerator for finding all simple reactions within a set of entries, up to a maximum reactant/product cardinality (n), with any number of open phases. Note: this does not return OpenComputedReaction objects (this can be calculated using the ReactionSet class).","title":"BasicOpenEnumerator"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicOpenEnumerator.__init__","text":"Supplied target and calculator parameters are automatically initialized as objects during enumeration. Parameters: Name Type Description Default open_phases List[str] List of formulas of open entries (e.g. [\"O2\"]) required precursors Optional[List[str]] Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. None target Optional[str] Optional formula of target; only reactions which make this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). None n int Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. 2 remove_unbalanced bool Whether to remove reactions which are unbalanced. Defaults to True True remove_changed bool Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. True Source code in rxn_network/enumerators/basic.py def __init__ ( self , open_phases : List [ str ], precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , n : int = 2 , remove_unbalanced : bool = True , remove_changed : bool = True , ): \"\"\" Supplied target and calculator parameters are automatically initialized as objects during enumeration. Args: open_phases: List of formulas of open entries (e.g. [\"O2\"]) precursors: Optional list of formulas of precursor phases; only reactions which have these phases as reactants will be enumerated. target: Optional formula of target; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]). n: Maximum reactant/product cardinality; i.e., largest possible number of entries on either side of the reaction. remove_unbalanced: Whether to remove reactions which are unbalanced. Defaults to True remove_changed: Whether to remove reactions which can only be balanced by removing a reactant/product or having it change sides. Defaults to True. \"\"\" super () . __init__ ( precursors , target , calculators , n , remove_unbalanced , remove_changed ) self . open_phases = open_phases","title":"__init__()"},{"location":"reference/enumerators/basic/#rxn_network.enumerators.basic.BasicOpenEnumerator.estimate_max_num_reactions","text":"Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/basic.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" num_open_phases = len ( self . open_phases ) num_combos_with_open = sum ( [ comb ( num_open_phases , i ) for i in range ( 1 , num_open_phases + 1 )] ) num_total_combos = 0 for i in range ( 1 , self . n + 1 ): num_combos = comb ( len ( entries ), i ) num_total_combos += num_combos_with_open * num_combos return num_total_combos ** 2","title":"estimate_max_num_reactions()"},{"location":"reference/enumerators/minimize/","text":"MinimizeGibbsEnumerator \u00b6 Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded. __init__ ( self , precursors = None , target = None , calculators = None ) special \u00b6 Parameters: Name Type Description Default precursors Optional[List[str]] Optional formulas of precursors. None target Optional[str] Optional formula of target; only reactions which make this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) None Source code in rxn_network/enumerators/minimize.py def __init__ ( self , precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , ): \"\"\" Args: precursors: Optional formulas of precursors. target: Optional formula of target; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) \"\"\" super () . __init__ ( precursors , target , calculators ) self . _build_pd = True estimate_max_num_reactions ( self , entries ) \u00b6 Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/minimize.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" return comb ( len ( entries ), 2 ) * 2 MinimizeGrandPotentialEnumerator \u00b6 Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded.","title":"Minimize"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGibbsEnumerator","text":"Enumerator for finding all reactions between two reactants that are predicted by thermodynamics; i.e., they appear when taking the convex hull along a straight line connecting any two phases in G-x phase space. Identity reactions are automatically excluded.","title":"MinimizeGibbsEnumerator"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGibbsEnumerator.__init__","text":"Parameters: Name Type Description Default precursors Optional[List[str]] Optional formulas of precursors. None target Optional[str] Optional formula of target; only reactions which make this target will be enumerated. None calculators Optional[List[str]] Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) None Source code in rxn_network/enumerators/minimize.py def __init__ ( self , precursors : Optional [ List [ str ]] = None , target : Optional [ str ] = None , calculators : Optional [ List [ str ]] = None , ): \"\"\" Args: precursors: Optional formulas of precursors. target: Optional formula of target; only reactions which make this target will be enumerated. calculators: Optional list of Calculator object names; see calculators module for options (e.g., [\"ChempotDistanceCalculator]) \"\"\" super () . __init__ ( precursors , target , calculators ) self . _build_pd = True","title":"__init__()"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGibbsEnumerator.estimate_max_num_reactions","text":"Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] A list of all entries to consider required Returns: The upper bound on the number of possible reactions Source code in rxn_network/enumerators/minimize.py def estimate_max_num_reactions ( self , entries : List [ ComputedEntry ]) -> int : \"\"\" Estimate the upper bound of the number of possible reactions. This will correlate with the amount of time it takes to enumerate reactions. Args: entries: A list of all entries to consider Returns: The upper bound on the number of possible reactions \"\"\" return comb ( len ( entries ), 2 ) * 2","title":"estimate_max_num_reactions()"},{"location":"reference/enumerators/minimize/#rxn_network.enumerators.minimize.MinimizeGrandPotentialEnumerator","text":"Enumerator for finding all reactions between two reactants and an open element that are predicted by thermo; i.e., they appear when taking the convex hull along a straight line connecting any two phases in Phi-x phase space. Identity reactions are excluded.","title":"MinimizeGrandPotentialEnumerator"},{"location":"reference/enumerators/utils/","text":"Helpful utility functions used by the enumerator classes. apply_calculators ( rxn , calculators ) \u00b6 Decorates a reaction by applying decorate() from a list of calculators. Parameters: Name Type Description Default rxn ComputedReaction ComputedReaction object required calculators List[rxn_network.core.calculator.Calculator] List of (initialized) calculators required Source code in rxn_network/enumerators/utils.py def apply_calculators ( rxn : ComputedReaction , calculators : List [ calcs . Calculator ]): \"\"\" Decorates a reaction by applying decorate() from a list of calculators. Args: rxn: ComputedReaction object calculators: List of (initialized) calculators \"\"\" for calc in calculators : rxn = calc . decorate ( rxn ) return rxn filter_entries_by_chemsys ( entries , chemsys ) \u00b6 Parameters: Name Type Description Default entries required chemsys required Source code in rxn_network/enumerators/utils.py def filter_entries_by_chemsys ( entries , chemsys ): \"\"\" Args: entries: chemsys: Returns: \"\"\" chemsys = set ( chemsys . split ( \"-\" )) filtered_entries = list ( filter ( lambda e : chemsys . issuperset ( e . composition . chemical_system . split ( \"-\" )), entries , ) ) return filtered_entries get_computed_rxn ( rxn , entries ) \u00b6 Parameters: Name Type Description Default rxn required entries required Source code in rxn_network/enumerators/utils.py def get_computed_rxn ( rxn , entries ): \"\"\" Args: rxn: entries: Returns: \"\"\" reactant_entries = [ get_entry_by_comp ( r , entries ) for r in rxn . reactants ] product_entries = [ get_entry_by_comp ( p , entries ) for p in rxn . products ] rxn = ComputedReaction . balance ( reactant_entries , product_entries ) return rxn get_elems_set ( entries ) \u00b6 Parameters: Name Type Description Default entries required Source code in rxn_network/enumerators/utils.py def get_elems_set ( entries ): \"\"\" Args: entries: Returns: \"\"\" return { str ( elem ) for e in entries for elem in e . composition . elements } get_entry_by_comp ( comp , entries ) \u00b6 Parameters: Name Type Description Default comp required entries required Source code in rxn_network/enumerators/utils.py def get_entry_by_comp ( comp , entries ): \"\"\" Args: comp: entries: Returns: \"\"\" possible_entries = filter ( lambda e : e . composition . reduced_composition == comp . reduced_composition , entries ) return sorted ( possible_entries , key = lambda e : e . energy_per_atom )[ 0 ] get_open_computed_rxn ( rxn , entries , chempots ) \u00b6 Parameters: Name Type Description Default rxn required entries required chempots required Source code in rxn_network/enumerators/utils.py def get_open_computed_rxn ( rxn , entries , chempots ): \"\"\" Args: rxn: entries: chempots: Returns: \"\"\" reactant_entries = [ get_entry_by_comp ( r , entries ) for r in rxn . reactants ] product_entries = [ get_entry_by_comp ( p , entries ) for p in rxn . products ] rxn = OpenComputedReaction . balance ( reactant_entries , product_entries , chempots ) return rxn get_total_chemsys ( entries , open_elem = None ) \u00b6 Returns chemical system for set of entries, with optional open element. Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] required open_elem None Source code in rxn_network/enumerators/utils.py def get_total_chemsys ( entries : List [ Entry ], open_elem = None ): \"\"\" Returns chemical system for set of entries, with optional open element. Args: entries: open_elem: \"\"\" elements = { elem for entry in entries for elem in entry . composition . elements } if open_elem : elements . add ( open_elem ) return \"-\" . join ( sorted ([ str ( e ) for e in elements ])) group_by_chemsys ( combos , open_elem = None ) \u00b6 Parameters: Name Type Description Default combos required open_elem None Source code in rxn_network/enumerators/utils.py def group_by_chemsys ( combos , open_elem = None ): \"\"\" Args: combos: open_elem: Returns: \"\"\" combo_dict = {} for combo in combos : key = get_total_chemsys ( combo , open_elem ) if key in combo_dict : combo_dict [ key ] . append ( combo ) else : combo_dict [ key ] = [ combo ] return combo_dict initialize_calculators ( calculators , entries ) \u00b6 Initialize a list of Calculators given a list of their names (strings) or uninitialized objects, and a provided list of entries. Parameters: Name Type Description Default calculators Union[List[rxn_network.core.calculator.Calculator], List[str]] List of names of calculators required entries GibbsEntrySet List of entries or EntrySet-type object required Source code in rxn_network/enumerators/utils.py def initialize_calculators ( calculators : Union [ List [ calcs . Calculator ], List [ str ]], entries : GibbsEntrySet ): \"\"\" Initialize a list of Calculators given a list of their names (strings) or uninitialized objects, and a provided list of entries. Args: calculators: List of names of calculators entries: List of entries or EntrySet-type object \"\"\" calculators = [ getattr ( calcs , c ) if isinstance ( c , str ) else c for c in calculators ] return [ c . from_entries ( entries ) for c in calculators ] # type: ignore initialize_entry ( formula , entry_set , stabilize = True ) \u00b6 Acquire a (stabilized) entry by user-specified formula. Parameters: Name Type Description Default formula str Chemical formula required entry_set GibbsEntrySet GibbsEntrySet containing 1 or more entries corresponding to given formula required stabilize bool Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' True Source code in rxn_network/enumerators/utils.py def initialize_entry ( formula : str , entry_set : GibbsEntrySet , stabilize : bool = True ): \"\"\" Acquire a (stabilized) entry by user-specified formula. Args: formula: Chemical formula entry_set: GibbsEntrySet containing 1 or more entries corresponding to given formula stabilize: Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' \"\"\" entry = entry_set . get_min_entry_by_formula ( formula ) if stabilize : entry = entry_set . stabilize_entry ( entry ) return entry stabilize_entries ( pd , entries_to_adjust , tol = 1e-06 ) \u00b6 Parameters: Name Type Description Default pd required entries_to_adjust required tol 1e-06 Source code in rxn_network/enumerators/utils.py def stabilize_entries ( pd , entries_to_adjust , tol = 1e-6 ): \"\"\" Args: pd: entries_to_adjust: tol: Returns: \"\"\" indices = [ pd . all_entries . index ( entry ) for entry in entries_to_adjust ] new_entries = [] for idx , entry in zip ( indices , entries_to_adjust ): e_above_hull = pd . get_e_above_hull ( entry ) entry_dict = entry . to_dict () entry_dict [ \"energy\" ] = entry . uncorrected_energy + ( e_above_hull * entry . composition . num_atoms - tol ) new_entry = ComputedEntry . from_dict ( entry_dict ) new_entries . append ( new_entry ) return new_entries","title":"Utils"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.apply_calculators","text":"Decorates a reaction by applying decorate() from a list of calculators. Parameters: Name Type Description Default rxn ComputedReaction ComputedReaction object required calculators List[rxn_network.core.calculator.Calculator] List of (initialized) calculators required Source code in rxn_network/enumerators/utils.py def apply_calculators ( rxn : ComputedReaction , calculators : List [ calcs . Calculator ]): \"\"\" Decorates a reaction by applying decorate() from a list of calculators. Args: rxn: ComputedReaction object calculators: List of (initialized) calculators \"\"\" for calc in calculators : rxn = calc . decorate ( rxn ) return rxn","title":"apply_calculators()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.filter_entries_by_chemsys","text":"Parameters: Name Type Description Default entries required chemsys required Source code in rxn_network/enumerators/utils.py def filter_entries_by_chemsys ( entries , chemsys ): \"\"\" Args: entries: chemsys: Returns: \"\"\" chemsys = set ( chemsys . split ( \"-\" )) filtered_entries = list ( filter ( lambda e : chemsys . issuperset ( e . composition . chemical_system . split ( \"-\" )), entries , ) ) return filtered_entries","title":"filter_entries_by_chemsys()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_computed_rxn","text":"Parameters: Name Type Description Default rxn required entries required Source code in rxn_network/enumerators/utils.py def get_computed_rxn ( rxn , entries ): \"\"\" Args: rxn: entries: Returns: \"\"\" reactant_entries = [ get_entry_by_comp ( r , entries ) for r in rxn . reactants ] product_entries = [ get_entry_by_comp ( p , entries ) for p in rxn . products ] rxn = ComputedReaction . balance ( reactant_entries , product_entries ) return rxn","title":"get_computed_rxn()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_elems_set","text":"Parameters: Name Type Description Default entries required Source code in rxn_network/enumerators/utils.py def get_elems_set ( entries ): \"\"\" Args: entries: Returns: \"\"\" return { str ( elem ) for e in entries for elem in e . composition . elements }","title":"get_elems_set()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_entry_by_comp","text":"Parameters: Name Type Description Default comp required entries required Source code in rxn_network/enumerators/utils.py def get_entry_by_comp ( comp , entries ): \"\"\" Args: comp: entries: Returns: \"\"\" possible_entries = filter ( lambda e : e . composition . reduced_composition == comp . reduced_composition , entries ) return sorted ( possible_entries , key = lambda e : e . energy_per_atom )[ 0 ]","title":"get_entry_by_comp()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_open_computed_rxn","text":"Parameters: Name Type Description Default rxn required entries required chempots required Source code in rxn_network/enumerators/utils.py def get_open_computed_rxn ( rxn , entries , chempots ): \"\"\" Args: rxn: entries: chempots: Returns: \"\"\" reactant_entries = [ get_entry_by_comp ( r , entries ) for r in rxn . reactants ] product_entries = [ get_entry_by_comp ( p , entries ) for p in rxn . products ] rxn = OpenComputedReaction . balance ( reactant_entries , product_entries , chempots ) return rxn","title":"get_open_computed_rxn()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.get_total_chemsys","text":"Returns chemical system for set of entries, with optional open element. Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] required open_elem None Source code in rxn_network/enumerators/utils.py def get_total_chemsys ( entries : List [ Entry ], open_elem = None ): \"\"\" Returns chemical system for set of entries, with optional open element. Args: entries: open_elem: \"\"\" elements = { elem for entry in entries for elem in entry . composition . elements } if open_elem : elements . add ( open_elem ) return \"-\" . join ( sorted ([ str ( e ) for e in elements ]))","title":"get_total_chemsys()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.group_by_chemsys","text":"Parameters: Name Type Description Default combos required open_elem None Source code in rxn_network/enumerators/utils.py def group_by_chemsys ( combos , open_elem = None ): \"\"\" Args: combos: open_elem: Returns: \"\"\" combo_dict = {} for combo in combos : key = get_total_chemsys ( combo , open_elem ) if key in combo_dict : combo_dict [ key ] . append ( combo ) else : combo_dict [ key ] = [ combo ] return combo_dict","title":"group_by_chemsys()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.initialize_calculators","text":"Initialize a list of Calculators given a list of their names (strings) or uninitialized objects, and a provided list of entries. Parameters: Name Type Description Default calculators Union[List[rxn_network.core.calculator.Calculator], List[str]] List of names of calculators required entries GibbsEntrySet List of entries or EntrySet-type object required Source code in rxn_network/enumerators/utils.py def initialize_calculators ( calculators : Union [ List [ calcs . Calculator ], List [ str ]], entries : GibbsEntrySet ): \"\"\" Initialize a list of Calculators given a list of their names (strings) or uninitialized objects, and a provided list of entries. Args: calculators: List of names of calculators entries: List of entries or EntrySet-type object \"\"\" calculators = [ getattr ( calcs , c ) if isinstance ( c , str ) else c for c in calculators ] return [ c . from_entries ( entries ) for c in calculators ] # type: ignore","title":"initialize_calculators()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.initialize_entry","text":"Acquire a (stabilized) entry by user-specified formula. Parameters: Name Type Description Default formula str Chemical formula required entry_set GibbsEntrySet GibbsEntrySet containing 1 or more entries corresponding to given formula required stabilize bool Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' True Source code in rxn_network/enumerators/utils.py def initialize_entry ( formula : str , entry_set : GibbsEntrySet , stabilize : bool = True ): \"\"\" Acquire a (stabilized) entry by user-specified formula. Args: formula: Chemical formula entry_set: GibbsEntrySet containing 1 or more entries corresponding to given formula stabilize: Whether or not to stabilize the entry by decreasing its energy such that it is 'on the hull' \"\"\" entry = entry_set . get_min_entry_by_formula ( formula ) if stabilize : entry = entry_set . stabilize_entry ( entry ) return entry","title":"initialize_entry()"},{"location":"reference/enumerators/utils/#rxn_network.enumerators.utils.stabilize_entries","text":"Parameters: Name Type Description Default pd required entries_to_adjust required tol 1e-06 Source code in rxn_network/enumerators/utils.py def stabilize_entries ( pd , entries_to_adjust , tol = 1e-6 ): \"\"\" Args: pd: entries_to_adjust: tol: Returns: \"\"\" indices = [ pd . all_entries . index ( entry ) for entry in entries_to_adjust ] new_entries = [] for idx , entry in zip ( indices , entries_to_adjust ): e_above_hull = pd . get_e_above_hull ( entry ) entry_dict = entry . to_dict () entry_dict [ \"energy\" ] = entry . uncorrected_energy + ( e_above_hull * entry . composition . num_atoms - tol ) new_entry = ComputedEntry . from_dict ( entry_dict ) new_entries . append ( new_entry ) return new_entries","title":"stabilize_entries()"},{"location":"reference/firetasks/build_inputs/","text":"Firetasks for acquiring ComputedEntry data from MPRester or another materials MongoDB EntriesFromDb \u00b6 Acquire ComputedStructureEntry objects from a custom materials MongoDB. Automatically builds GibbsComputedEntry objects at specified temperature and filters by e_above_hull stability. Required params: entry_db_file (str): chemsys (str): temperature (float): e_above_hull (float): Optional params: include_polymorphs (bool): run_task ( self , fw_spec ) \u00b6 This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/build_inputs.py def run_task ( self , fw_spec ): db_file = env_chk ( self [ \"entry_db_file\" ], fw_spec ) chemsys = self [ \"chemsys\" ] temperature = self [ \"temperature\" ] e_above_hull = self [ \"e_above_hull\" ] include_polymorphs = self . get ( \"include_polymorphs\" , False ) inc_structure = self . get ( \"inc_structure\" , \"final\" ) compatible_only = self . get ( \"compatible_only\" , True ) property_data = self . get ( \"property_data\" , None ) with MongoStore . from_db_file ( db_file ) as db : entries = get_all_entries_in_chemsys ( db , chemsys , inc_structure = inc_structure , compatible_only = compatible_only , property_data = property_data , use_premade_entries = False , ) entries = process_entries ( entries , temperature , e_above_hull , include_polymorphs ) return FWAction ( update_spec = { \"entries\" : entries }) EntriesFromMPRester \u00b6 Acquire ComputedStructureEntry objects from the Materials Project database. Automatically builds GibbsComputedEntry objects at specified temperature and filters by e_above_hull stability. Note: the PMG_MAPI_KEY enviornment variable must be properly configured on the computing resource. Required params: chemsys (str): temperature (float): e_above_hull (float): Optional params: include_polymorphs (bool): run_task ( self , fw_spec ) \u00b6 This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/build_inputs.py def run_task ( self , fw_spec ): chemsys = self [ \"chemsys\" ] temperature = self [ \"temperature\" ] e_above_hull = self [ \"e_above_hull\" ] include_polymorphs = self . get ( \"include_polymorphs\" , False ) with MPRester () as mpr : entries = mpr . get_entries_in_chemsys ( elements = chemsys , inc_structure = \"fiinal\" ) entries = process_entries ( entries , temperature , e_above_hull , include_polymorphs ) return FWAction ( update_spec = { \"entries\" : entries }) get_all_entries_in_chemsys ( db , elements , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , n = 1000 ) \u00b6 Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. Parameters: Name Type Description Default elements str or [str] Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure str If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. None property_data list Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None conventional_unit_cell bool Whether to get the standard conventional unit cell False n int Chunk size, i.e., number of sub-chemical systems to consider 1000 Returns: Type Description List of ComputedEntries. Source code in rxn_network/firetasks/build_inputs.py def get_all_entries_in_chemsys ( db , elements , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , n = 1000 , ): \"\"\" Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. Args: elements (str or [str]): Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. compatible_only (bool): Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure (str): If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. property_data (list): Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. conventional_unit_cell (bool): Whether to get the standard conventional unit cell n (int): Chunk size, i.e., number of sub-chemical systems to consider Returns: List of ComputedEntries. \"\"\" def divide_chunks ( l , n ): for i in range ( 0 , len ( l ), n ): yield l [ i : i + n ] if isinstance ( elements , str ): elements = elements . split ( \"-\" ) if len ( elements ) < 13 : all_chemsyses = [] for i in range ( len ( elements )): for els in itertools . combinations ( elements , i + 1 ): all_chemsyses . append ( \"-\" . join ( sorted ( els ))) all_chemsyses = list ( divide_chunks ( all_chemsyses , n )) entries = [] for chemsys_group in all_chemsyses : entries . extend ( get_entries ( db , { \"chemsys\" : { \"$in\" : chemsys_group }}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) ) else : entries = get_entries ( db , { \"elements\" : { \"$not\" : { \"$elemMatch\" : { \"$nin\" : elements }}}}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) return entries get_entries ( db , chemsys_formula_id_criteria , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , sort_by_e_above_hull = False ) \u00b6 Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. Code adapted from pymatgen.ext.matproj. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required chemsys_formula_id_criteria Union[str, dict] A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure bool If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. None property_data Optional[List[str]] Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False sort_by_e_above_hull bool Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). False Returns: Type Description List of ComputedEntry or ComputedStructureEntry objects. Source code in rxn_network/firetasks/build_inputs.py def get_entries ( # noqa: C901 db : MongoStore , chemsys_formula_id_criteria : Union [ str , dict ], compatible_only : bool = True , inc_structure : bool = None , property_data : Optional [ List [ str ]] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , sort_by_e_above_hull : bool = False , ): \"\"\" Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. Code adapted from pymatgen.ext.matproj. Args: db: MongoStore object with database connection chemsys_formula_id_criteria: A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. compatible_only: Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure: If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. property_data: Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell: Whether to get the standard conventional unit cell sort_by_e_above_hull: Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). Returns: List of ComputedEntry or ComputedStructureEntry objects. \"\"\" params = [ \"deprecated\" , \"run_type\" , \"is_hubbard\" , \"pseudo_potential\" , \"hubbards\" , \"potcar_symbols\" , \"oxide_type\" , ] props = [ \"final_energy\" , \"unit_cell_formula\" , \"task_id\" ] + params if sort_by_e_above_hull : if property_data and \"e_above_hull\" not in property_data : property_data . append ( \"e_above_hull\" ) elif not property_data : property_data = [ \"e_above_hull\" ] if property_data : props += property_data if inc_structure : if inc_structure == \"initial\" : props . append ( \"initial_structure\" ) else : props . append ( \"structure\" ) if not isinstance ( chemsys_formula_id_criteria , dict ): criteria = MPRester . parse_criteria ( chemsys_formula_id_criteria ) else : criteria = chemsys_formula_id_criteria if use_premade_entries : props = [ \"entries\" , \"deprecated\" ] entries = [] for d in db . query ( criteria , props ): if d . get ( \"deprecated\" ): continue if use_premade_entries : ent = d [ \"entries\" ] if ent . get ( \"GGA\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA\" ]) elif ent . get ( \"GGA+U\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA+U\" ]) else : print ( f \"Missing entry for { d [ '_id' ] } \" ) continue else : d [ \"potcar_symbols\" ] = [ \" %s %s \" % ( d [ \"pseudo_potential\" ][ \"functional\" ], l ) for l in d [ \"pseudo_potential\" ] . get ( \"labels\" , []) ] data = { \"oxide_type\" : d [ \"oxide_type\" ]} if property_data : data . update ({ k : d [ k ] for k in property_data }) if not inc_structure : e = ComputedEntry ( d [ \"unit_cell_formula\" ], d [ \"final_energy\" ], parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) else : prim = Structure . from_dict ( d [ \"initial_structure\" ] if inc_structure == \"initial\" else d [ \"structure\" ] ) if conventional_unit_cell : s = SpacegroupAnalyzer ( prim ) . get_conventional_standard_structure () energy = d [ \"final_energy\" ] * ( len ( s ) / len ( prim )) else : s = prim . copy () energy = d [ \"final_energy\" ] e = ComputedStructureEntry ( s , energy , parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) entries . append ( e ) if compatible_only : from pymatgen.entries.compatibility import MaterialsProject2020Compatibility with warnings . catch_warnings (): warnings . filterwarnings ( \"ignore\" , message = \"Failed to guess oxidation states.*\" ) entries = MaterialsProject2020Compatibility () . process_entries ( entries , clean = True ) if sort_by_e_above_hull : entries = sorted ( entries , key = lambda entry : entry . data [ \"e_above_hull\" ]) return entries process_entries ( entries , temperature , e_above_hull , include_polymorphs ) \u00b6 Parameters: Name Type Description Default entries required temperature required e_above_hull required include_polymorphs required Source code in rxn_network/firetasks/build_inputs.py def process_entries ( entries , temperature , e_above_hull , include_polymorphs ): \"\"\" Args: entries: temperature: e_above_hull: include_polymorphs: Returns: \"\"\" entry_set = GibbsEntrySet . from_entries ( entries = entries , temperature = temperature ) entry_set = entry_set . filter_by_stability ( e_above_hull = e_above_hull , include_polymorphs = include_polymorphs ) return entry_set","title":"Build Inputs"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.EntriesFromDb","text":"Acquire ComputedStructureEntry objects from a custom materials MongoDB. Automatically builds GibbsComputedEntry objects at specified temperature and filters by e_above_hull stability. Required params: entry_db_file (str): chemsys (str): temperature (float): e_above_hull (float): Optional params: include_polymorphs (bool):","title":"EntriesFromDb"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.EntriesFromDb.run_task","text":"This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/build_inputs.py def run_task ( self , fw_spec ): db_file = env_chk ( self [ \"entry_db_file\" ], fw_spec ) chemsys = self [ \"chemsys\" ] temperature = self [ \"temperature\" ] e_above_hull = self [ \"e_above_hull\" ] include_polymorphs = self . get ( \"include_polymorphs\" , False ) inc_structure = self . get ( \"inc_structure\" , \"final\" ) compatible_only = self . get ( \"compatible_only\" , True ) property_data = self . get ( \"property_data\" , None ) with MongoStore . from_db_file ( db_file ) as db : entries = get_all_entries_in_chemsys ( db , chemsys , inc_structure = inc_structure , compatible_only = compatible_only , property_data = property_data , use_premade_entries = False , ) entries = process_entries ( entries , temperature , e_above_hull , include_polymorphs ) return FWAction ( update_spec = { \"entries\" : entries })","title":"run_task()"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.EntriesFromMPRester","text":"Acquire ComputedStructureEntry objects from the Materials Project database. Automatically builds GibbsComputedEntry objects at specified temperature and filters by e_above_hull stability. Note: the PMG_MAPI_KEY enviornment variable must be properly configured on the computing resource. Required params: chemsys (str): temperature (float): e_above_hull (float): Optional params: include_polymorphs (bool):","title":"EntriesFromMPRester"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.EntriesFromMPRester.run_task","text":"This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/build_inputs.py def run_task ( self , fw_spec ): chemsys = self [ \"chemsys\" ] temperature = self [ \"temperature\" ] e_above_hull = self [ \"e_above_hull\" ] include_polymorphs = self . get ( \"include_polymorphs\" , False ) with MPRester () as mpr : entries = mpr . get_entries_in_chemsys ( elements = chemsys , inc_structure = \"fiinal\" ) entries = process_entries ( entries , temperature , e_above_hull , include_polymorphs ) return FWAction ( update_spec = { \"entries\" : entries })","title":"run_task()"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.get_all_entries_in_chemsys","text":"Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. Parameters: Name Type Description Default elements str or [str] Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure str If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. None property_data list Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None conventional_unit_cell bool Whether to get the standard conventional unit cell False n int Chunk size, i.e., number of sub-chemical systems to consider 1000 Returns: Type Description List of ComputedEntries. Source code in rxn_network/firetasks/build_inputs.py def get_all_entries_in_chemsys ( db , elements , compatible_only = True , inc_structure = None , property_data = None , use_premade_entries = False , conventional_unit_cell = False , n = 1000 , ): \"\"\" Helper method for getting all entries in a total chemical system by querying database for all sub-chemical systems. Code adadpted from pymatgen.ext.matproj and modified to support very large chemical systems. Args: elements (str or [str]): Chemical system string comprising element symbols separated by dashes, e.g., \"Li-Fe-O\" or List of element symbols, e.g., [\"Li\", \"Fe\", \"O\"]. compatible_only (bool): Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure (str): If None, entries returned are ComputedEntries. If inc_structure=\"final\", ComputedStructureEntries with final structures are returned. Otherwise, ComputedStructureEntries with initial structures are returned. property_data (list): Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. conventional_unit_cell (bool): Whether to get the standard conventional unit cell n (int): Chunk size, i.e., number of sub-chemical systems to consider Returns: List of ComputedEntries. \"\"\" def divide_chunks ( l , n ): for i in range ( 0 , len ( l ), n ): yield l [ i : i + n ] if isinstance ( elements , str ): elements = elements . split ( \"-\" ) if len ( elements ) < 13 : all_chemsyses = [] for i in range ( len ( elements )): for els in itertools . combinations ( elements , i + 1 ): all_chemsyses . append ( \"-\" . join ( sorted ( els ))) all_chemsyses = list ( divide_chunks ( all_chemsyses , n )) entries = [] for chemsys_group in all_chemsyses : entries . extend ( get_entries ( db , { \"chemsys\" : { \"$in\" : chemsys_group }}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) ) else : entries = get_entries ( db , { \"elements\" : { \"$not\" : { \"$elemMatch\" : { \"$nin\" : elements }}}}, compatible_only = compatible_only , inc_structure = inc_structure , property_data = property_data , use_premade_entries = use_premade_entries , conventional_unit_cell = conventional_unit_cell , ) return entries","title":"get_all_entries_in_chemsys()"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.get_entries","text":"Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. Code adapted from pymatgen.ext.matproj. Parameters: Name Type Description Default db MongoStore MongoStore object with database connection required chemsys_formula_id_criteria Union[str, dict] A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. required compatible_only bool Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. True inc_structure bool If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. None property_data Optional[List[str]] Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. None use_premade_entries bool Whether to use entry objects that have already been constructed. Defaults to False. False conventional_unit_cell bool Whether to get the standard conventional unit cell False sort_by_e_above_hull bool Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). False Returns: Type Description List of ComputedEntry or ComputedStructureEntry objects. Source code in rxn_network/firetasks/build_inputs.py def get_entries ( # noqa: C901 db : MongoStore , chemsys_formula_id_criteria : Union [ str , dict ], compatible_only : bool = True , inc_structure : bool = None , property_data : Optional [ List [ str ]] = None , use_premade_entries : bool = False , conventional_unit_cell : bool = False , sort_by_e_above_hull : bool = False , ): \"\"\" Get a list of ComputedEntries or ComputedStructureEntries corresponding to a chemical system, formula, or materials_id or full criteria. Code adapted from pymatgen.ext.matproj. Args: db: MongoStore object with database connection chemsys_formula_id_criteria: A chemical system (e.g., Li-Fe-O), or formula (e.g., Fe2O3) or materials_id (e.g., mp-1234) or full Mongo-style dict criteria. compatible_only: Whether to return only \"compatible\" entries. Compatible entries are entries that have been processed using the MaterialsProjectCompatibility class, which performs adjustments to allow mixing of GGA and GGA+U calculations for more accurate phase diagrams and reaction energies. inc_structure: If None, entries returned are ComputedEntries. If inc_structure=\"initial\", ComputedStructureEntries with initial structures are returned. Otherwise, ComputedStructureEntries with final structures are returned. property_data: Specify additional properties to include in entry.data. If None, no data. Should be a subset of supported_properties. use_premade_entries: Whether to use entry objects that have already been constructed. Defaults to False. conventional_unit_cell: Whether to get the standard conventional unit cell sort_by_e_above_hull: Whether to sort the list of entries by e_above_hull (will query e_above_hull as a property_data if True). Returns: List of ComputedEntry or ComputedStructureEntry objects. \"\"\" params = [ \"deprecated\" , \"run_type\" , \"is_hubbard\" , \"pseudo_potential\" , \"hubbards\" , \"potcar_symbols\" , \"oxide_type\" , ] props = [ \"final_energy\" , \"unit_cell_formula\" , \"task_id\" ] + params if sort_by_e_above_hull : if property_data and \"e_above_hull\" not in property_data : property_data . append ( \"e_above_hull\" ) elif not property_data : property_data = [ \"e_above_hull\" ] if property_data : props += property_data if inc_structure : if inc_structure == \"initial\" : props . append ( \"initial_structure\" ) else : props . append ( \"structure\" ) if not isinstance ( chemsys_formula_id_criteria , dict ): criteria = MPRester . parse_criteria ( chemsys_formula_id_criteria ) else : criteria = chemsys_formula_id_criteria if use_premade_entries : props = [ \"entries\" , \"deprecated\" ] entries = [] for d in db . query ( criteria , props ): if d . get ( \"deprecated\" ): continue if use_premade_entries : ent = d [ \"entries\" ] if ent . get ( \"GGA\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA\" ]) elif ent . get ( \"GGA+U\" ): e = ComputedStructureEntry . from_dict ( ent [ \"GGA+U\" ]) else : print ( f \"Missing entry for { d [ '_id' ] } \" ) continue else : d [ \"potcar_symbols\" ] = [ \" %s %s \" % ( d [ \"pseudo_potential\" ][ \"functional\" ], l ) for l in d [ \"pseudo_potential\" ] . get ( \"labels\" , []) ] data = { \"oxide_type\" : d [ \"oxide_type\" ]} if property_data : data . update ({ k : d [ k ] for k in property_data }) if not inc_structure : e = ComputedEntry ( d [ \"unit_cell_formula\" ], d [ \"final_energy\" ], parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) else : prim = Structure . from_dict ( d [ \"initial_structure\" ] if inc_structure == \"initial\" else d [ \"structure\" ] ) if conventional_unit_cell : s = SpacegroupAnalyzer ( prim ) . get_conventional_standard_structure () energy = d [ \"final_energy\" ] * ( len ( s ) / len ( prim )) else : s = prim . copy () energy = d [ \"final_energy\" ] e = ComputedStructureEntry ( s , energy , parameters = { k : d [ k ] for k in params }, data = data , entry_id = d [ \"task_id\" ], ) entries . append ( e ) if compatible_only : from pymatgen.entries.compatibility import MaterialsProject2020Compatibility with warnings . catch_warnings (): warnings . filterwarnings ( \"ignore\" , message = \"Failed to guess oxidation states.*\" ) entries = MaterialsProject2020Compatibility () . process_entries ( entries , clean = True ) if sort_by_e_above_hull : entries = sorted ( entries , key = lambda entry : entry . data [ \"e_above_hull\" ]) return entries","title":"get_entries()"},{"location":"reference/firetasks/build_inputs/#rxn_network.firetasks.build_inputs.process_entries","text":"Parameters: Name Type Description Default entries required temperature required e_above_hull required include_polymorphs required Source code in rxn_network/firetasks/build_inputs.py def process_entries ( entries , temperature , e_above_hull , include_polymorphs ): \"\"\" Args: entries: temperature: e_above_hull: include_polymorphs: Returns: \"\"\" entry_set = GibbsEntrySet . from_entries ( entries = entries , temperature = temperature ) entry_set = entry_set . filter_by_stability ( e_above_hull = e_above_hull , include_polymorphs = include_polymorphs ) return entry_set","title":"process_entries()"},{"location":"reference/firetasks/parse_outputs/","text":"Firetasks for storing enumerated reaction or network data into a MongoDB. NetworkToDb \u00b6 Stores calculated reaction network in a MongoDB. run_task ( self , fw_spec ) \u00b6 This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/parse_outputs.py def run_task ( self , fw_spec ): pass ReactionsToDb \u00b6 Stores calculated reactions (rxns.json) and their metadata (metadata.json) in a MongoDB. run_task ( self , fw_spec ) \u00b6 This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/parse_outputs.py def run_task ( self , fw_spec ): db_file = env_chk ( self . get ( \"db_file\" ), fw_spec ) d = {} rxns = loadfn ( \"rxns.json\" ) metadata = loadfn ( \"metadata.json\" ) d [ \"name\" ] = ( f \"Reaction Enumeration (Target: \" f \" { metadata [ 'target' ] } ): { metadata [ 'chemsys' ] } \" ) d [ \"rxns\" ] = jsanitize ( rxns , strict = True ) d [ \"metadata\" ] = jsanitize ( metadata , strict = True ) with MongoStore . from_db_file ( db_file ) as db : task_ids = sorted ( db . distinct ( \"task_id\" )) if task_ids : d [ \"task_id\" ] = task_ids [ - 1 ] + 1 else : d [ \"task_id\" ] = 1 d [ \"last_updated\" ] = datetime . datetime . utcnow () db . update ( d )","title":"Parse Outputs"},{"location":"reference/firetasks/parse_outputs/#rxn_network.firetasks.parse_outputs.NetworkToDb","text":"Stores calculated reaction network in a MongoDB.","title":"NetworkToDb"},{"location":"reference/firetasks/parse_outputs/#rxn_network.firetasks.parse_outputs.NetworkToDb.run_task","text":"This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/parse_outputs.py def run_task ( self , fw_spec ): pass","title":"run_task()"},{"location":"reference/firetasks/parse_outputs/#rxn_network.firetasks.parse_outputs.ReactionsToDb","text":"Stores calculated reactions (rxns.json) and their metadata (metadata.json) in a MongoDB.","title":"ReactionsToDb"},{"location":"reference/firetasks/parse_outputs/#rxn_network.firetasks.parse_outputs.ReactionsToDb.run_task","text":"This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/parse_outputs.py def run_task ( self , fw_spec ): db_file = env_chk ( self . get ( \"db_file\" ), fw_spec ) d = {} rxns = loadfn ( \"rxns.json\" ) metadata = loadfn ( \"metadata.json\" ) d [ \"name\" ] = ( f \"Reaction Enumeration (Target: \" f \" { metadata [ 'target' ] } ): { metadata [ 'chemsys' ] } \" ) d [ \"rxns\" ] = jsanitize ( rxns , strict = True ) d [ \"metadata\" ] = jsanitize ( metadata , strict = True ) with MongoStore . from_db_file ( db_file ) as db : task_ids = sorted ( db . distinct ( \"task_id\" )) if task_ids : d [ \"task_id\" ] = task_ids [ - 1 ] + 1 else : d [ \"task_id\" ] = 1 d [ \"last_updated\" ] = datetime . datetime . utcnow () db . update ( d )","title":"run_task()"},{"location":"reference/firetasks/run_calc/","text":"Firetasks for running enumeration and network calculations RunEnumerators \u00b6 Run a list of enumerators on a provided set of computed entries and dump the calculated ComputedReaction objects to a file (rxns.json). Metadata is stored as metadata.json. Required params: enumerators (List[Enumerator]): Enumerators to run entries (List[ComputedEntry]): Computed entries to be fed into enumerate() methods run_task ( self , fw_spec ) \u00b6 This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/run_calc.py def run_task ( self , fw_spec ): enumerators = self [ \"enumerators\" ] entries = self . get ( \"entries\" , None ) if not entries : entries = fw_spec [ \"entries\" ] else : entries = entries [ \"entries\" ] entries = GibbsEntrySet ( entries ) chemsys = \"-\" . join ( sorted ( list ( entries . chemsys ))) target = enumerators [ 0 ] . target added_elems = None if target : added_elems = entries . chemsys - { str ( e ) for e in Composition ( target ) . elements } added_elems = \"-\" . join ( sorted ( list ( added_elems ))) metadata = { \"chemsys\" : chemsys , \"enumerators\" : enumerators , \"target\" : target , \"added_elems\" : added_elems , } results = [] for enumerator in enumerators : rxns = enumerator . enumerate ( entries ) results . extend ( rxns ) results = ReactionSet . from_rxns ( results ) dumpfn ( results , \"rxns.json\" ) dumpfn ( metadata , \"metadata.json\" )","title":"Run Calc"},{"location":"reference/firetasks/run_calc/#rxn_network.firetasks.run_calc.RunEnumerators","text":"Run a list of enumerators on a provided set of computed entries and dump the calculated ComputedReaction objects to a file (rxns.json). Metadata is stored as metadata.json. Required params: enumerators (List[Enumerator]): Enumerators to run entries (List[ComputedEntry]): Computed entries to be fed into enumerate() methods","title":"RunEnumerators"},{"location":"reference/firetasks/run_calc/#rxn_network.firetasks.run_calc.RunEnumerators.run_task","text":"This method gets called when the Firetask is run. It can take in a Firework spec, perform some task using that data, and then return an output in the form of a FWAction. Parameters: Name Type Description Default fw_spec dict A Firework spec. This comes from the master spec. In addition, this spec contains a special \"_fw_env\" key that contains the env settings of the FWorker calling this method. This provides for abstracting out certain commands or settings. For example, \"foo\" may be named \"foo1\" in resource 1 and \"foo2\" in resource 2. The FWorker env can specify { \"foo\": \"foo1\"}, which maps an abstract variable \"foo\" to the relevant \"foo1\" or \"foo2\". You can then write a task that uses fw_spec \"_fw_env\" that will work across all these multiple resources. required Returns: Type Description (FWAction) Source code in rxn_network/firetasks/run_calc.py def run_task ( self , fw_spec ): enumerators = self [ \"enumerators\" ] entries = self . get ( \"entries\" , None ) if not entries : entries = fw_spec [ \"entries\" ] else : entries = entries [ \"entries\" ] entries = GibbsEntrySet ( entries ) chemsys = \"-\" . join ( sorted ( list ( entries . chemsys ))) target = enumerators [ 0 ] . target added_elems = None if target : added_elems = entries . chemsys - { str ( e ) for e in Composition ( target ) . elements } added_elems = \"-\" . join ( sorted ( list ( added_elems ))) metadata = { \"chemsys\" : chemsys , \"enumerators\" : enumerators , \"target\" : target , \"added_elems\" : added_elems , } results = [] for enumerator in enumerators : rxns = enumerator . enumerate ( entries ) results . extend ( rxns ) results = ReactionSet . from_rxns ( results ) dumpfn ( results , \"rxns.json\" ) dumpfn ( metadata , \"metadata.json\" )","title":"run_task()"},{"location":"reference/firetasks/utils/","text":"Utility Fireworks functions borrowed from the atomate package env_chk ( val , fw_spec , strict = True , default = None ) \u00b6 Code borrowed from the atomate package. env_chk() is a way to set different values for a property depending on the worker machine. For example, you might have slightly different executable names or scratch directories on different machines. Parameters: Name Type Description Default val str any value, with \">><<\" notation reserved for special env lookup values required fw_spec dict fw_spec where one can find the _fw_env keys required strict Optional[bool] if True, errors if env format (>><<) specified but cannot be found in fw_spec True default Optional[str] if val is None or env cannot be found in non-strict mode, return default None Source code in rxn_network/firetasks/utils.py def env_chk ( val : str , fw_spec : dict , strict : Optional [ bool ] = True , default : Optional [ str ] = None , ): \"\"\" Code borrowed from the atomate package. env_chk() is a way to set different values for a property depending on the worker machine. For example, you might have slightly different executable names or scratch directories on different machines. Args: val: any value, with \">><<\" notation reserved for special env lookup values fw_spec: fw_spec where one can find the _fw_env keys strict: if True, errors if env format (>><<) specified but cannot be found in fw_spec default: if val is None or env cannot be found in non-strict mode, return default \"\"\" if val is None : return default if isinstance ( val , str ) and val . startswith ( \">>\" ) and val . endswith ( \"<<\" ): if strict : return fw_spec [ \"_fw_env\" ][ val [ 2 : - 2 ]] return fw_spec . get ( \"_fw_env\" , {}) . get ( val [ 2 : - 2 ], default ) return val get_logger ( name , level = 10 , log_format = ' %(asctime)s %(levelname)s %(name)s %(message)s ' , stream =< _io . StringIO object at 0x7fa28c2a3040 > ) \u00b6 Code borrowed from the atomate package. Helper method for acquiring logger. Source code in rxn_network/firetasks/utils.py def get_logger ( name : str , level = logging . DEBUG , log_format = \" %(asctime)s %(levelname)s %(name)s %(message)s \" , stream = sys . stdout , ): \"\"\" Code borrowed from the atomate package. Helper method for acquiring logger. \"\"\" logger = logging . getLogger ( name ) logger . setLevel ( level ) formatter = logging . Formatter ( log_format ) sh = logging . StreamHandler ( stream = stream ) sh . setFormatter ( formatter ) logger . addHandler ( sh ) return logger","title":"Utils"},{"location":"reference/firetasks/utils/#rxn_network.firetasks.utils.env_chk","text":"Code borrowed from the atomate package. env_chk() is a way to set different values for a property depending on the worker machine. For example, you might have slightly different executable names or scratch directories on different machines. Parameters: Name Type Description Default val str any value, with \">><<\" notation reserved for special env lookup values required fw_spec dict fw_spec where one can find the _fw_env keys required strict Optional[bool] if True, errors if env format (>><<) specified but cannot be found in fw_spec True default Optional[str] if val is None or env cannot be found in non-strict mode, return default None Source code in rxn_network/firetasks/utils.py def env_chk ( val : str , fw_spec : dict , strict : Optional [ bool ] = True , default : Optional [ str ] = None , ): \"\"\" Code borrowed from the atomate package. env_chk() is a way to set different values for a property depending on the worker machine. For example, you might have slightly different executable names or scratch directories on different machines. Args: val: any value, with \">><<\" notation reserved for special env lookup values fw_spec: fw_spec where one can find the _fw_env keys strict: if True, errors if env format (>><<) specified but cannot be found in fw_spec default: if val is None or env cannot be found in non-strict mode, return default \"\"\" if val is None : return default if isinstance ( val , str ) and val . startswith ( \">>\" ) and val . endswith ( \"<<\" ): if strict : return fw_spec [ \"_fw_env\" ][ val [ 2 : - 2 ]] return fw_spec . get ( \"_fw_env\" , {}) . get ( val [ 2 : - 2 ], default ) return val","title":"env_chk()"},{"location":"reference/firetasks/utils/#rxn_network.firetasks.utils.get_logger","text":"Code borrowed from the atomate package. Helper method for acquiring logger. Source code in rxn_network/firetasks/utils.py def get_logger ( name : str , level = logging . DEBUG , log_format = \" %(asctime)s %(levelname)s %(name)s %(message)s \" , stream = sys . stdout , ): \"\"\" Code borrowed from the atomate package. Helper method for acquiring logger. \"\"\" logger = logging . getLogger ( name ) logger . setLevel ( level ) formatter = logging . Formatter ( log_format ) sh = logging . StreamHandler ( stream = stream ) sh . setFormatter ( formatter ) logger . addHandler ( sh ) return logger","title":"get_logger()"},{"location":"reference/fireworks/core/","text":"Implementation of Fireworks for performing reaction enumreation and network construction EnumeratorFW \u00b6 Firework for running a list of enumerators (which outputs a list of reactions). __init__ ( self , enumerators , entries = None , chemsys = None , temperature = None , e_above_hull = None , db_file = None , entry_db_file = None , include_polymorphs = False , parents = None ) special \u00b6 Parameters: Name Type Description Default enumerators required entries None chemsys None temperature None e_above_hull None db_file None entry_db_file None include_polymorphs False parents None Source code in rxn_network/fireworks/core.py def __init__ ( self , enumerators , entries = None , chemsys = None , temperature = None , e_above_hull = None , db_file = None , entry_db_file = None , include_polymorphs = False , parents = None , ): \"\"\" Args: enumerators: entries: chemsys: temperature: e_above_hull: db_file: entry_db_file: include_polymorphs: parents: \"\"\" tasks = [] entry_set = None if entries : entry_set = GibbsEntrySet ( entries ) chemsys = \"-\" . join ( sorted ( list ( entry_set . chemsys ))) else : if entry_db_file : entry_task = EntriesFromDb ( entry_db_file = entry_db_file , chemsys = chemsys , temperature = temperature , e_above_hull = e_above_hull , include_polymorphs = include_polymorphs , ) else : entry_task = EntriesFromMPRester ( chemsys = chemsys , temperature = temperature , e_above_hull = e_above_hull , include_polymorphs = include_polymorphs , ) tasks . append ( entry_task ) targets = { enumerator . target for enumerator in enumerators } if len ( targets ) != 1 : raise ValueError ( \"Enumerators contain different targets!\" ) target = targets . pop () fw_name = f \"Reaction Enumeration (Target: { target } ): { chemsys } \" tasks . append ( RunEnumerators ( enumerators = enumerators , entries = entry_set , chemsys = chemsys ) ) tasks . append ( ReactionsToDb ( db_file = db_file , calc_dir = \".\" )) super () . __init__ ( tasks , parents = parents , name = fw_name )","title":"Core"},{"location":"reference/fireworks/core/#rxn_network.fireworks.core.EnumeratorFW","text":"Firework for running a list of enumerators (which outputs a list of reactions).","title":"EnumeratorFW"},{"location":"reference/fireworks/core/#rxn_network.fireworks.core.EnumeratorFW.__init__","text":"Parameters: Name Type Description Default enumerators required entries None chemsys None temperature None e_above_hull None db_file None entry_db_file None include_polymorphs False parents None Source code in rxn_network/fireworks/core.py def __init__ ( self , enumerators , entries = None , chemsys = None , temperature = None , e_above_hull = None , db_file = None , entry_db_file = None , include_polymorphs = False , parents = None , ): \"\"\" Args: enumerators: entries: chemsys: temperature: e_above_hull: db_file: entry_db_file: include_polymorphs: parents: \"\"\" tasks = [] entry_set = None if entries : entry_set = GibbsEntrySet ( entries ) chemsys = \"-\" . join ( sorted ( list ( entry_set . chemsys ))) else : if entry_db_file : entry_task = EntriesFromDb ( entry_db_file = entry_db_file , chemsys = chemsys , temperature = temperature , e_above_hull = e_above_hull , include_polymorphs = include_polymorphs , ) else : entry_task = EntriesFromMPRester ( chemsys = chemsys , temperature = temperature , e_above_hull = e_above_hull , include_polymorphs = include_polymorphs , ) tasks . append ( entry_task ) targets = { enumerator . target for enumerator in enumerators } if len ( targets ) != 1 : raise ValueError ( \"Enumerators contain different targets!\" ) target = targets . pop () fw_name = f \"Reaction Enumeration (Target: { target } ): { chemsys } \" tasks . append ( RunEnumerators ( enumerators = enumerators , entries = entry_set , chemsys = chemsys ) ) tasks . append ( ReactionsToDb ( db_file = db_file , calc_dir = \".\" )) super () . __init__ ( tasks , parents = parents , name = fw_name )","title":"__init__()"},{"location":"reference/network/entry/","text":"Entry objects used in a Network. This holds multiple entries and can be used as data for a graph node. DummyEntry \u00b6 A Dummy Entry that doesn't hold any info chemsys property readonly \u00b6 No Chemsys to DummyEntry description property readonly \u00b6 DummyEntry is always of type Dummy entries property readonly \u00b6 No entries in DummyEntry __init__ ( self ) special \u00b6 Dummy node doesn't need any parameters Source code in rxn_network/network/entry.py def __init__ ( self ): # pylint: disable=W0231 \"\"\"Dummy node doesn't need any parameters\"\"\" NetworkEntry \u00b6 Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network. __init__ ( self , entries , description ) special \u00b6 Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] list of ComputedEntry-like objects required description NetworkEntryType Node type required Source code in rxn_network/network/entry.py def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of ComputedEntry-like objects description: Node type \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description NetworkEntryType \u00b6 Describes the Network Entry Type","title":"Entry"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry","text":"A Dummy Entry that doesn't hold any info","title":"DummyEntry"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.chemsys","text":"No Chemsys to DummyEntry","title":"chemsys"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.description","text":"DummyEntry is always of type Dummy","title":"description"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.entries","text":"No entries in DummyEntry","title":"entries"},{"location":"reference/network/entry/#rxn_network.network.entry.DummyEntry.__init__","text":"Dummy node doesn't need any parameters Source code in rxn_network/network/entry.py def __init__ ( self ): # pylint: disable=W0231 \"\"\"Dummy node doesn't need any parameters\"\"\"","title":"__init__()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry","text":"Helper class for describing combinations of ComputedEntry-like objects in context of a reaction network.","title":"NetworkEntry"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntry.__init__","text":"Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] list of ComputedEntry-like objects required description NetworkEntryType Node type required Source code in rxn_network/network/entry.py def __init__ ( self , entries : List [ Entry ], description : NetworkEntryType ): \"\"\" Args: entries: list of ComputedEntry-like objects description: Node type \"\"\" self . entries = set ( entries ) self . elements = sorted ( list ({ elem for entry in entries for elem in entry . composition . elements }) ) self . chemsys = \"-\" . join ([ str ( e ) for e in self . elements ]) self . dim = len ( self . chemsys ) self . description = description","title":"__init__()"},{"location":"reference/network/entry/#rxn_network.network.entry.NetworkEntryType","text":"Describes the Network Entry Type","title":"NetworkEntryType"},{"location":"reference/network/gt/","text":"Graph-related functions specific to the graph-tool library. Used in the network module. initialize_graph ( vertex_props = None , edge_props = None ) \u00b6 Parameters: Name Type Description Default vertex_props Dict[str, str] None edge_props Dict[str, str] None Returns: Type Description Graph Source code in rxn_network/network/gt.py def initialize_graph ( vertex_props : Dict [ str , str ] = None , edge_props : Dict [ str , str ] = None ) -> Graph : \"\"\" Args: vertex_props: edge_props: Returns: \"\"\" g = Graph () if not vertex_props : vertex_props = dict () if not edge_props : edge_props = dict () vertex_props . update ( DEFAULT_VERTEX_PROPS ) edge_props . update ( DEFAULT_EDGE_PROPS ) for name , obj_type in vertex_props . items (): g . vp [ name ] = g . new_vertex_property ( obj_type ) for name , obj_type in edge_props . items (): g . ep [ name ] = g . new_edge_property ( obj_type ) return g update_vertex_properties ( g , v , prop_dict ) \u00b6 Helper method for updating several vertex properties at once in a graph-tool graph. Parameters: Name Type Description Default g gt.Graph a graph-tool Graph object. required v gt.Vertex or int a graph-tool Vertex object (or its index) for a vertex in the provided graph. required prop_dict dict a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. required Returns: Type Description None Source code in rxn_network/network/gt.py def update_vertex_properties ( g , v , prop_dict ): \"\"\" Helper method for updating several vertex properties at once in a graph-tool graph. Args: g (gt.Graph): a graph-tool Graph object. v (gt.Vertex or int): a graph-tool Vertex object (or its index) for a vertex in the provided graph. prop_dict (dict): a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. Returns: None \"\"\" for prop , val in prop_dict . items (): g . vp [ prop ][ v ] = val return None update_vertex_props ( g , v , prop_dict ) \u00b6 Helper method for updating several vertex properties at once in a graph-tool graph. Parameters: Name Type Description Default g gt.Graph a graph-tool Graph object. required v gt.Vertex or int a graph-tool Vertex object (or its index) for a vertex in the provided graph. required prop_dict dict a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. required Returns: Type Description None Source code in rxn_network/network/gt.py def update_vertex_props ( g , v , prop_dict ): \"\"\" Helper method for updating several vertex properties at once in a graph-tool graph. Args: g (gt.Graph): a graph-tool Graph object. v (gt.Vertex or int): a graph-tool Vertex object (or its index) for a vertex in the provided graph. prop_dict (dict): a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. Returns: None \"\"\" for prop , val in prop_dict . items (): g . vp [ prop ][ v ] = val yens_ksp ( g , num_k , precursors_v , target_v , edge_prop = 'bool' , cost_prop = 'cost' ) \u00b6 Yen's Algorithm for k-shortest paths, adopted for graph-tool. Utilizes GraphView objects to speed up filtering. Inspired by igraph implementation by Antonin Lenfant. Ref: Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Parameters: Name Type Description Default g Graph the graph-tool graph object. required num_k int number of k shortest paths that should be found. required precursors_v Vertex graph-tool vertex object containing precursors. required target_v Vertex graph-tool vertex object containing target. required edge_prop str name of edge property map which allows for filtering edges. Defaults to the word \"bool\". 'bool' cost_prop str name of edge property map that stores edge weights/costs. Defaults to the word \"weight\". 'cost' Returns: Type Description List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). Source code in rxn_network/network/gt.py def yens_ksp ( g : Graph , num_k : int , precursors_v : Vertex , target_v : Vertex , edge_prop : str = \"bool\" , cost_prop : str = \"cost\" , ): \"\"\" Yen's Algorithm for k-shortest paths, adopted for graph-tool. Utilizes GraphView objects to speed up filtering. Inspired by igraph implementation by Antonin Lenfant. Ref: Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Args: g: the graph-tool graph object. num_k: number of k shortest paths that should be found. precursors_v: graph-tool vertex object containing precursors. target_v: graph-tool vertex object containing target. edge_prop: name of edge property map which allows for filtering edges. Defaults to the word \"bool\". cost_prop: name of edge property map that stores edge weights/costs. Defaults to the word \"weight\". Returns: List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). \"\"\" def path_cost ( vertices ): \"\"\"Calculates path cost given a list of vertices.\"\"\" cost = 0 for j in range ( len ( vertices ) - 1 ): cost += g . ep [ cost_prop ][ g . edge ( vertices [ j ], vertices [ j + 1 ])] return cost path = shortest_path ( g , precursors_v , target_v , weights = g . ep [ cost_prop ])[ 0 ] if not path : return [] a = [ path ] a_costs = [ path_cost ( path )] b = PriorityQueue () # type: ignore g . ep [ \"bool\" ] = g . new_edge_property ( \"bool\" , val = True ) for k in range ( 1 , num_k ): try : prev_path = a [ k - 1 ] except IndexError : print ( f \"Identified only k= { k - 1 } paths before exiting. \\n \" ) break for i in range ( len ( prev_path ) - 1 ): spur_v = prev_path [ i ] root_path = prev_path [: i ] filtered_edges = [] for path in a : if len ( path ) - 1 > i and root_path == path [: i ]: e = g . edge ( path [ i ], path [ i + 1 ]) if not e : continue g . ep [ edge_prop ][ e ] = False filtered_edges . append ( e ) gv = GraphView ( g , efilt = g . ep [ edge_prop ]) spur_path = shortest_path ( gv , spur_v , target_v , weights = g . ep [ cost_prop ])[ 0 ] for e in filtered_edges : g . ep [ edge_prop ][ e ] = True if spur_path : total_path = root_path + spur_path total_path_cost = path_cost ( total_path ) b . put (( total_path_cost , total_path )) while True : try : cost_ , path_ = b . get ( block = False ) except Empty : break if path_ not in a : a . append ( path_ ) a_costs . append ( cost_ ) break return a","title":"Graph-tool"},{"location":"reference/network/gt/#rxn_network.network.gt.initialize_graph","text":"Parameters: Name Type Description Default vertex_props Dict[str, str] None edge_props Dict[str, str] None Returns: Type Description Graph Source code in rxn_network/network/gt.py def initialize_graph ( vertex_props : Dict [ str , str ] = None , edge_props : Dict [ str , str ] = None ) -> Graph : \"\"\" Args: vertex_props: edge_props: Returns: \"\"\" g = Graph () if not vertex_props : vertex_props = dict () if not edge_props : edge_props = dict () vertex_props . update ( DEFAULT_VERTEX_PROPS ) edge_props . update ( DEFAULT_EDGE_PROPS ) for name , obj_type in vertex_props . items (): g . vp [ name ] = g . new_vertex_property ( obj_type ) for name , obj_type in edge_props . items (): g . ep [ name ] = g . new_edge_property ( obj_type ) return g","title":"initialize_graph()"},{"location":"reference/network/gt/#rxn_network.network.gt.update_vertex_properties","text":"Helper method for updating several vertex properties at once in a graph-tool graph. Parameters: Name Type Description Default g gt.Graph a graph-tool Graph object. required v gt.Vertex or int a graph-tool Vertex object (or its index) for a vertex in the provided graph. required prop_dict dict a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. required Returns: Type Description None Source code in rxn_network/network/gt.py def update_vertex_properties ( g , v , prop_dict ): \"\"\" Helper method for updating several vertex properties at once in a graph-tool graph. Args: g (gt.Graph): a graph-tool Graph object. v (gt.Vertex or int): a graph-tool Vertex object (or its index) for a vertex in the provided graph. prop_dict (dict): a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. Returns: None \"\"\" for prop , val in prop_dict . items (): g . vp [ prop ][ v ] = val return None","title":"update_vertex_properties()"},{"location":"reference/network/gt/#rxn_network.network.gt.update_vertex_props","text":"Helper method for updating several vertex properties at once in a graph-tool graph. Parameters: Name Type Description Default g gt.Graph a graph-tool Graph object. required v gt.Vertex or int a graph-tool Vertex object (or its index) for a vertex in the provided graph. required prop_dict dict a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. required Returns: Type Description None Source code in rxn_network/network/gt.py def update_vertex_props ( g , v , prop_dict ): \"\"\" Helper method for updating several vertex properties at once in a graph-tool graph. Args: g (gt.Graph): a graph-tool Graph object. v (gt.Vertex or int): a graph-tool Vertex object (or its index) for a vertex in the provided graph. prop_dict (dict): a dictionary of the form {\"prop\": val}, where prop is the name of a VertexPropertyMap of the graph and val is the new updated value for that vertex's property. Returns: None \"\"\" for prop , val in prop_dict . items (): g . vp [ prop ][ v ] = val","title":"update_vertex_props()"},{"location":"reference/network/gt/#rxn_network.network.gt.yens_ksp","text":"Yen's Algorithm for k-shortest paths, adopted for graph-tool. Utilizes GraphView objects to speed up filtering. Inspired by igraph implementation by Antonin Lenfant. Ref: Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Parameters: Name Type Description Default g Graph the graph-tool graph object. required num_k int number of k shortest paths that should be found. required precursors_v Vertex graph-tool vertex object containing precursors. required target_v Vertex graph-tool vertex object containing target. required edge_prop str name of edge property map which allows for filtering edges. Defaults to the word \"bool\". 'bool' cost_prop str name of edge property map that stores edge weights/costs. Defaults to the word \"weight\". 'cost' Returns: Type Description List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). Source code in rxn_network/network/gt.py def yens_ksp ( g : Graph , num_k : int , precursors_v : Vertex , target_v : Vertex , edge_prop : str = \"bool\" , cost_prop : str = \"cost\" , ): \"\"\" Yen's Algorithm for k-shortest paths, adopted for graph-tool. Utilizes GraphView objects to speed up filtering. Inspired by igraph implementation by Antonin Lenfant. Ref: Jin Y. Yen, \"Finding the K Shortest Loopless Paths in a Network\", Management Science, Vol. 17, No. 11, Theory Series (Jul., 1971), pp. 712-716. Args: g: the graph-tool graph object. num_k: number of k shortest paths that should be found. precursors_v: graph-tool vertex object containing precursors. target_v: graph-tool vertex object containing target. edge_prop: name of edge property map which allows for filtering edges. Defaults to the word \"bool\". cost_prop: name of edge property map that stores edge weights/costs. Defaults to the word \"weight\". Returns: List of lists of graph vertices corresponding to each shortest path (sorted in increasing order by cost). \"\"\" def path_cost ( vertices ): \"\"\"Calculates path cost given a list of vertices.\"\"\" cost = 0 for j in range ( len ( vertices ) - 1 ): cost += g . ep [ cost_prop ][ g . edge ( vertices [ j ], vertices [ j + 1 ])] return cost path = shortest_path ( g , precursors_v , target_v , weights = g . ep [ cost_prop ])[ 0 ] if not path : return [] a = [ path ] a_costs = [ path_cost ( path )] b = PriorityQueue () # type: ignore g . ep [ \"bool\" ] = g . new_edge_property ( \"bool\" , val = True ) for k in range ( 1 , num_k ): try : prev_path = a [ k - 1 ] except IndexError : print ( f \"Identified only k= { k - 1 } paths before exiting. \\n \" ) break for i in range ( len ( prev_path ) - 1 ): spur_v = prev_path [ i ] root_path = prev_path [: i ] filtered_edges = [] for path in a : if len ( path ) - 1 > i and root_path == path [: i ]: e = g . edge ( path [ i ], path [ i + 1 ]) if not e : continue g . ep [ edge_prop ][ e ] = False filtered_edges . append ( e ) gv = GraphView ( g , efilt = g . ep [ edge_prop ]) spur_path = shortest_path ( gv , spur_v , target_v , weights = g . ep [ cost_prop ])[ 0 ] for e in filtered_edges : g . ep [ edge_prop ][ e ] = True if spur_path : total_path = root_path + spur_path total_path_cost = path_cost ( total_path ) b . put (( total_path_cost , total_path )) while True : try : cost_ , path_ = b . get ( block = False ) except Empty : break if path_ not in a : a . append ( path_ ) a_costs . append ( cost_ ) break return a","title":"yens_ksp()"},{"location":"reference/network/network/","text":"Implementation of an actual reaction network interface. ReactionNetwork \u00b6 Main reaction network class for building graphs of reactions and performing pathfinding. __init__ ( self , entries , enumerators , cost_function , open_elem = None , chempot = None ) special \u00b6 Initialize a ReactionNetwork object for a set of entires, enumerator, and cost function. The network can be constructed by calling build(). Parameters: Name Type Description Default entries GibbsEntrySet iterable of entry-like objects required enumerators List[rxn_network.core.enumerator.Enumerator] iterable of enumerators which will be called during the build of the network required cost_function CostFunction the function used to calculate the cost of each reaction edge required open_elem Optional[str] Optional name of an element that is kept open during reaction None chempot Optional[float] Optional associated chemical potential of open element None Source code in rxn_network/network/network.py def __init__ ( self , entries : GibbsEntrySet , enumerators : List [ Enumerator ], cost_function : CostFunction , open_elem : Optional [ str ] = None , chempot : Optional [ float ] = None , ): \"\"\" Initialize a ReactionNetwork object for a set of entires, enumerator, and cost function. The network can be constructed by calling build(). Args: entries: iterable of entry-like objects enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( entries = entries , enumerators = enumerators , cost_function = cost_function ) self . open_elem = open_elem self . chempot = chempot build ( self ) \u00b6 Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None Source code in rxn_network/network/network.py def build ( self ): \"\"\" Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" rxn_set = self . _get_rxns () costs = rxn_set . calculate_costs ( self . cost_function ) rxns = rxn_set . get_rxns ( self . open_elem , self . chempot ) self . logger . info ( \"Building graph from reactions...\" ) nodes , rxn_edges = get_rxn_nodes_and_edges ( rxns ) g = initialize_graph () g . add_vertex ( len ( nodes )) for i , network_entry in enumerate ( nodes ): props = { \"entry\" : network_entry , \"type\" : network_entry . description . value } update_vertex_props ( g , g . vertex ( i ), props ) edge_list = [] for edge , cost , rxn in zip ( rxn_edges , costs , rxns ): v1 = g . vertex ( edge [ 0 ]) v2 = g . vertex ( edge [ 1 ]) edge_list . append (( v1 , v2 , cost , rxn , \"reaction\" )) edge_list . extend ( get_loopback_edges ( g , nodes )) g . add_edge_list ( edge_list , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . _g = g find_pathways ( self , targets , k = 15 ) \u00b6 Find the k-shortest paths to a provided list of 1 or more targets. Parameters: Name Type Description Default targets List[str] List of the formulas of each target required k float Number of shortest paths to find for each target 15 Returns: Type Description List[rxn_network.pathways.basic.BasicPathway] List of BasicPathway objects to all provided targets. Source code in rxn_network/network/network.py def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : if type ( target ) == str : target = self . entries . get_min_entry_by_formula ( target ) self . set_target ( target ) print ( f \"PATHS to { target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _shortest_paths ( k = k ) paths . extend ( pathways ) return paths set_precursors ( self , precursors ) \u00b6 Parameters: Name Type Description Default precursors required Source code in rxn_network/network/network.py def set_precursors ( self , precursors ): \"\"\" Args: precursors: Returns: \"\"\" g = self . _g precursors = set ( precursors ) if precursors == self . precursors : return elif self . precursors : precursors_v = find_vertex ( g , g . vp [ \"type\" ], NetworkEntryType . Precursors . value )[ 0 ] g . remove_vertex ( precursors_v ) loopback_edges = find_edge ( g , g . ep [ \"type\" ], \"loopback_precursors\" ) for e in loopback_edges : g . remove_edge ( e ) elif not all ([ p in self . entries for p in precursors ]): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_v = g . add_vertex () precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) props = { \"entry\" : precursors_entry , \"type\" : precursors_entry . description . value } update_vertex_props ( g , precursors_v , props ) add_edges = [] for v in g . vertices (): entry = g . vp [ \"entry\" ][ v ] if not entry : continue if entry . description . value == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): add_edges . append (( precursors_v , v , 0.0 , None , \"precursors\" )) elif entry . description . value == NetworkEntryType . Products . value : for v2 in g . vertices (): entry2 = g . vp [ \"entry\" ][ v2 ] if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): add_edges . append (( v , v2 , 0.0 , None , \"loopback_precursors\" )) g . add_edge_list ( add_edges , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . precursors = precursors set_target ( self , target ) \u00b6 Parameters: Name Type Description Default target required Source code in rxn_network/network/network.py def set_target ( self , target ): \"\"\" Args: target: Returns: \"\"\" g = self . _g if target == self . target : return elif self . target or target is None : target_v = find_vertex ( g , g . vp [ \"type\" ], NetworkEntryType . Target . value )[ 0 ] g . remove_vertex ( target_v ) target_v = g . add_vertex () target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) props = { \"entry\" : target_entry , \"type\" : target_entry . description . value } update_vertex_props ( g , target_v , props ) add_edges = [] for v in g . vertices (): entry = g . vp [ \"entry\" ][ v ] if not entry : continue if entry . description . value != NetworkEntryType . Products . value : continue if target in entry . entries : add_edges . append ([ v , target_v , 0.0 , None , \"target\" ]) g . add_edge_list ( add_edges , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . target = target","title":"Network"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork","text":"Main reaction network class for building graphs of reactions and performing pathfinding.","title":"ReactionNetwork"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.__init__","text":"Initialize a ReactionNetwork object for a set of entires, enumerator, and cost function. The network can be constructed by calling build(). Parameters: Name Type Description Default entries GibbsEntrySet iterable of entry-like objects required enumerators List[rxn_network.core.enumerator.Enumerator] iterable of enumerators which will be called during the build of the network required cost_function CostFunction the function used to calculate the cost of each reaction edge required open_elem Optional[str] Optional name of an element that is kept open during reaction None chempot Optional[float] Optional associated chemical potential of open element None Source code in rxn_network/network/network.py def __init__ ( self , entries : GibbsEntrySet , enumerators : List [ Enumerator ], cost_function : CostFunction , open_elem : Optional [ str ] = None , chempot : Optional [ float ] = None , ): \"\"\" Initialize a ReactionNetwork object for a set of entires, enumerator, and cost function. The network can be constructed by calling build(). Args: entries: iterable of entry-like objects enumerators: iterable of enumerators which will be called during the build of the network cost_function: the function used to calculate the cost of each reaction edge open_elem: Optional name of an element that is kept open during reaction chempot: Optional associated chemical potential of open element \"\"\" super () . __init__ ( entries = entries , enumerators = enumerators , cost_function = cost_function ) self . open_elem = open_elem self . chempot = chempot","title":"__init__()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.build","text":"Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None Source code in rxn_network/network/network.py def build ( self ): \"\"\" Construct the reaction network graph object and store under the \"graph\" attribute. Does NOT initialize precursors or target; you must call set_precursors() or set_target() to do so. Returns: None \"\"\" rxn_set = self . _get_rxns () costs = rxn_set . calculate_costs ( self . cost_function ) rxns = rxn_set . get_rxns ( self . open_elem , self . chempot ) self . logger . info ( \"Building graph from reactions...\" ) nodes , rxn_edges = get_rxn_nodes_and_edges ( rxns ) g = initialize_graph () g . add_vertex ( len ( nodes )) for i , network_entry in enumerate ( nodes ): props = { \"entry\" : network_entry , \"type\" : network_entry . description . value } update_vertex_props ( g , g . vertex ( i ), props ) edge_list = [] for edge , cost , rxn in zip ( rxn_edges , costs , rxns ): v1 = g . vertex ( edge [ 0 ]) v2 = g . vertex ( edge [ 1 ]) edge_list . append (( v1 , v2 , cost , rxn , \"reaction\" )) edge_list . extend ( get_loopback_edges ( g , nodes )) g . add_edge_list ( edge_list , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . _g = g","title":"build()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.find_pathways","text":"Find the k-shortest paths to a provided list of 1 or more targets. Parameters: Name Type Description Default targets List[str] List of the formulas of each target required k float Number of shortest paths to find for each target 15 Returns: Type Description List[rxn_network.pathways.basic.BasicPathway] List of BasicPathway objects to all provided targets. Source code in rxn_network/network/network.py def find_pathways ( self , targets : List [ str ], k : float = 15 ) -> List [ BasicPathway ]: \"\"\" Find the k-shortest paths to a provided list of 1 or more targets. Args: targets: List of the formulas of each target k: Number of shortest paths to find for each target Returns: List of BasicPathway objects to all provided targets. \"\"\" if not self . precursors : raise AttributeError ( \"Must call set_precursors() before pathfinding!\" ) paths = [] for target in targets : if type ( target ) == str : target = self . entries . get_min_entry_by_formula ( target ) self . set_target ( target ) print ( f \"PATHS to { target . composition . reduced_formula } \\n \" ) print ( \"--------------------------------------- \\n \" ) pathways = self . _shortest_paths ( k = k ) paths . extend ( pathways ) return paths","title":"find_pathways()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.set_precursors","text":"Parameters: Name Type Description Default precursors required Source code in rxn_network/network/network.py def set_precursors ( self , precursors ): \"\"\" Args: precursors: Returns: \"\"\" g = self . _g precursors = set ( precursors ) if precursors == self . precursors : return elif self . precursors : precursors_v = find_vertex ( g , g . vp [ \"type\" ], NetworkEntryType . Precursors . value )[ 0 ] g . remove_vertex ( precursors_v ) loopback_edges = find_edge ( g , g . ep [ \"type\" ], \"loopback_precursors\" ) for e in loopback_edges : g . remove_edge ( e ) elif not all ([ p in self . entries for p in precursors ]): raise ValueError ( \"One or more precursors are not included in network!\" ) precursors_v = g . add_vertex () precursors_entry = NetworkEntry ( precursors , NetworkEntryType . Precursors ) props = { \"entry\" : precursors_entry , \"type\" : precursors_entry . description . value } update_vertex_props ( g , precursors_v , props ) add_edges = [] for v in g . vertices (): entry = g . vp [ \"entry\" ][ v ] if not entry : continue if entry . description . value == NetworkEntryType . Reactants . value : if entry . entries . issubset ( precursors ): add_edges . append (( precursors_v , v , 0.0 , None , \"precursors\" )) elif entry . description . value == NetworkEntryType . Products . value : for v2 in g . vertices (): entry2 = g . vp [ \"entry\" ][ v2 ] if entry2 . description . value == NetworkEntryType . Reactants . value : if precursors . issuperset ( entry2 . entries ): continue if precursors . union ( entry . entries ) . issuperset ( entry2 . entries ): add_edges . append (( v , v2 , 0.0 , None , \"loopback_precursors\" )) g . add_edge_list ( add_edges , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . precursors = precursors","title":"set_precursors()"},{"location":"reference/network/network/#rxn_network.network.network.ReactionNetwork.set_target","text":"Parameters: Name Type Description Default target required Source code in rxn_network/network/network.py def set_target ( self , target ): \"\"\" Args: target: Returns: \"\"\" g = self . _g if target == self . target : return elif self . target or target is None : target_v = find_vertex ( g , g . vp [ \"type\" ], NetworkEntryType . Target . value )[ 0 ] g . remove_vertex ( target_v ) target_v = g . add_vertex () target_entry = NetworkEntry ([ target ], NetworkEntryType . Target ) props = { \"entry\" : target_entry , \"type\" : target_entry . description . value } update_vertex_props ( g , target_v , props ) add_edges = [] for v in g . vertices (): entry = g . vp [ \"entry\" ][ v ] if not entry : continue if entry . description . value != NetworkEntryType . Products . value : continue if target in entry . entries : add_edges . append ([ v , target_v , 0.0 , None , \"target\" ]) g . add_edge_list ( add_edges , eprops = [ g . ep [ \"cost\" ], g . ep [ \"rxn\" ], g . ep [ \"type\" ]]) self . target = target","title":"set_target()"},{"location":"reference/network/utils/","text":"Utility functions used in the ReactionNetwork class. get_loopback_edges ( g , nodes ) \u00b6 Parameters: Name Type Description Default g required nodes required Source code in rxn_network/network/utils.py def get_loopback_edges ( g , nodes ): \"\"\" Args: g: nodes: Returns: \"\"\" edges = [] for idx1 , p in enumerate ( nodes ): if p . description . value != NetworkEntryType . Products . value : continue for idx2 , r in enumerate ( nodes ): if r . description . value != NetworkEntryType . Reactants . value : continue if p . entries == r . entries : edges . append (( g . vertex ( idx1 ), g . vertex ( idx2 ), 0.0 , None , \"loopback\" )) return edges get_rxn_nodes_and_edges ( rxns ) \u00b6 Parameters: Name Type Description Default rxns required Source code in rxn_network/network/utils.py def get_rxn_nodes_and_edges ( rxns ): \"\"\" Args: rxns: Returns: \"\"\" nodes , edges = [], [] for rxn in rxns : reactant_node = NetworkEntry ( rxn . reactant_entries , NetworkEntryType . Reactants ) product_node = NetworkEntry ( rxn . product_entries , NetworkEntryType . Products ) if reactant_node not in nodes : nodes . append ( reactant_node ) reactant_idx = len ( nodes ) - 1 else : reactant_idx = nodes . index ( reactant_node ) if product_node not in nodes : nodes . append ( product_node ) product_idx = len ( nodes ) - 1 else : product_idx = nodes . index ( product_node ) edges . append (( reactant_idx , product_idx )) return nodes , edges","title":"Utils"},{"location":"reference/network/utils/#rxn_network.network.utils.get_loopback_edges","text":"Parameters: Name Type Description Default g required nodes required Source code in rxn_network/network/utils.py def get_loopback_edges ( g , nodes ): \"\"\" Args: g: nodes: Returns: \"\"\" edges = [] for idx1 , p in enumerate ( nodes ): if p . description . value != NetworkEntryType . Products . value : continue for idx2 , r in enumerate ( nodes ): if r . description . value != NetworkEntryType . Reactants . value : continue if p . entries == r . entries : edges . append (( g . vertex ( idx1 ), g . vertex ( idx2 ), 0.0 , None , \"loopback\" )) return edges","title":"get_loopback_edges()"},{"location":"reference/network/utils/#rxn_network.network.utils.get_rxn_nodes_and_edges","text":"Parameters: Name Type Description Default rxns required Source code in rxn_network/network/utils.py def get_rxn_nodes_and_edges ( rxns ): \"\"\" Args: rxns: Returns: \"\"\" nodes , edges = [], [] for rxn in rxns : reactant_node = NetworkEntry ( rxn . reactant_entries , NetworkEntryType . Reactants ) product_node = NetworkEntry ( rxn . product_entries , NetworkEntryType . Products ) if reactant_node not in nodes : nodes . append ( reactant_node ) reactant_idx = len ( nodes ) - 1 else : reactant_idx = nodes . index ( reactant_node ) if product_node not in nodes : nodes . append ( product_node ) product_idx = len ( nodes ) - 1 else : product_idx = nodes . index ( product_node ) edges . append (( reactant_idx , product_idx )) return nodes , edges","title":"get_rxn_nodes_and_edges()"},{"location":"reference/network/visualize/","text":"Functions for visualizing/plotting reaction networks.","title":"Visualize"},{"location":"reference/pathways/balanced/","text":"Implements a class for storing balanced reaction pathways. BalancedPathway \u00b6 Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes cost of each reaction. __init__ ( self , reactions , coefficients , costs = None , balanced = None ) special \u00b6 Parameters: Name Type Description Default rxns [ComputedReaction] list of ComputedReaction objects in pymatgen which occur along path. required costs Optional[List[float]] list of corresponding costs for each reaction. None Source code in rxn_network/pathways/balanced.py def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : Optional [ List [ float ]] = None , balanced : Optional [ bool ] = None , ): \"\"\" Args: rxns ([ComputedReaction]): list of ComputedReaction objects in pymatgen which occur along path. costs ([float]): list of corresponding costs for each reaction. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) if balanced is not None : self . balanced = balanced else : self . balanced = False balance ( pathway_sets , net_reaction , tol = 1e-06 ) classmethod \u00b6 TODO: Implement this method Balances multiple reaction pathways to a net reaction Source code in rxn_network/pathways/balanced.py @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction \"\"\" pass comp_matrix ( self ) \u00b6 Internal method for getting the composition matrix used in the balancing procedure. Source code in rxn_network/pathways/balanced.py def comp_matrix ( self ): \"\"\" Internal method for getting the composition matrix used in the balancing procedure. \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] ) get_coeff_vector_for_rxn ( self , rxn ) \u00b6 Internal method for getting the net reaction coefficients vector. Source code in rxn_network/pathways/balanced.py def get_coeff_vector_for_rxn ( self , rxn ): \"\"\" Internal method for getting the net reaction coefficients vector. \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] )","title":"Balanced"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway","text":"Helper class for storing multiple ComputedReaction objects which form a single reaction pathway as identified via pathfinding methods. Includes cost of each reaction.","title":"BalancedPathway"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.__init__","text":"Parameters: Name Type Description Default rxns [ComputedReaction] list of ComputedReaction objects in pymatgen which occur along path. required costs Optional[List[float]] list of corresponding costs for each reaction. None Source code in rxn_network/pathways/balanced.py def __init__ ( self , reactions : List [ Reaction ], coefficients : List [ float ], costs : Optional [ List [ float ]] = None , balanced : Optional [ bool ] = None , ): \"\"\" Args: rxns ([ComputedReaction]): list of ComputedReaction objects in pymatgen which occur along path. costs ([float]): list of corresponding costs for each reaction. \"\"\" self . coefficients = coefficients super () . __init__ ( reactions = reactions , costs = costs ) if balanced is not None : self . balanced = balanced else : self . balanced = False","title":"__init__()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.balance","text":"TODO: Implement this method Balances multiple reaction pathways to a net reaction Source code in rxn_network/pathways/balanced.py @classmethod def balance ( cls , pathway_sets : Union [ List [ Pathway ], List [ List [ Reaction ]]], net_reaction : Reaction , tol = 1e-6 , ): \"\"\" TODO: Implement this method Balances multiple reaction pathways to a net reaction \"\"\" pass","title":"balance()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.comp_matrix","text":"Internal method for getting the composition matrix used in the balancing procedure. Source code in rxn_network/pathways/balanced.py def comp_matrix ( self ): \"\"\" Internal method for getting the composition matrix used in the balancing procedure. \"\"\" return np . array ( [ [ rxn . get_coeff ( comp ) if comp in rxn . all_comp else 0 for comp in self . compositions ] for rxn in self . reactions ] )","title":"comp_matrix()"},{"location":"reference/pathways/balanced/#rxn_network.pathways.balanced.BalancedPathway.get_coeff_vector_for_rxn","text":"Internal method for getting the net reaction coefficients vector. Source code in rxn_network/pathways/balanced.py def get_coeff_vector_for_rxn ( self , rxn ): \"\"\" Internal method for getting the net reaction coefficients vector. \"\"\" return np . array ( [ rxn . get_coeff ( comp ) if comp in rxn . compositions else 0 for comp in self . compositions ] )","title":"get_coeff_vector_for_rxn()"},{"location":"reference/pathways/basic/","text":"Implements a class for storing (unbalanced/unconstrained) collection of reactions forming a reaction pathway. BasicPathway \u00b6 Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry __init__ ( self , reactions , costs = None ) special \u00b6 Parameters: Name Type Description Default reactions List[rxn_network.core.reaction.Reaction] list of ComputedReaction objects in pymatgen which occur along path. required costs Optional[List[float]] list of corresponding costs for each reaction. None Source code in rxn_network/pathways/basic.py def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions ([ComputedReaction]): list of ComputedReaction objects in pymatgen which occur along path. costs ([float]): list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs","title":"Basic"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway","text":"Simple pathway class for storing multiple ComputedReaction objects which form a single reaction pathway with no constraints on stoichiometry","title":"BasicPathway"},{"location":"reference/pathways/basic/#rxn_network.pathways.basic.BasicPathway.__init__","text":"Parameters: Name Type Description Default reactions List[rxn_network.core.reaction.Reaction] list of ComputedReaction objects in pymatgen which occur along path. required costs Optional[List[float]] list of corresponding costs for each reaction. None Source code in rxn_network/pathways/basic.py def __init__ ( self , reactions : List [ Reaction ], costs : Optional [ List [ float ]] = None ): \"\"\" Args: reactions ([ComputedReaction]): list of ComputedReaction objects in pymatgen which occur along path. costs ([float]): list of corresponding costs for each reaction. \"\"\" self . _reactions = reactions if not costs : costs = [] self . costs = costs","title":"__init__()"},{"location":"reference/pathways/solver/","text":"Implements a reaction pathway solver class which efficiently solves mass balance equations using matrix operations. PathwaySolver \u00b6 __init__ ( self , entries , pathways , cost_function , open_elem = None , chempot = None ) special \u00b6 Parameters: Name Type Description Default entries GibbsEntrySet required pathways List[rxn_network.core.pathway.Pathway] required cost_function CostFunction required open_elem str None chempot float None Source code in rxn_network/pathways/solver.py def __init__ ( self , entries : GibbsEntrySet , pathways : List [ Pathway ], cost_function : CostFunction , open_elem : str = None , chempot : float = None , ): \"\"\" Args: entries: pathways: cost_function: open_elem: chempot: \"\"\" super () . __init__ ( entries = entries , pathways = pathways ) self . cost_function = cost_function self . open_elem = open_elem self . chempot = chempot solve ( self , net_rxn , max_num_combos = 4 , find_intermediate_rxns = True , intermediate_rxn_energy_cutoff = 0.0 , filter_interdependent = True ) \u00b6 Parameters: Name Type Description Default net_rxn ComputedReaction required max_num_combos int 4 find_intermediate_rxns bool True intermediate_rxn_energy_cutoff float 0.0 filter_interdependent bool True Source code in rxn_network/pathways/solver.py def solve ( self , net_rxn : ComputedReaction , max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , filter_interdependent : bool = True , ): \"\"\" Args: net_rxn: max_num_combos: find_intermediate_rxns: intermediate_rxn_energy_cutoff: filter_interdependent: Returns: \"\"\" entries = self . entries . entries_list precursors = net_rxn . reactant_entries targets = net_rxn . product_entries reactions = self . reactions . copy () costs = self . costs . copy () if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) self . logger . info ( f \"NET RXN: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( precursors , targets , intermediate_rxn_energy_cutoff ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = self . _build_idx_vector ( net_rxn ) if net_rxn in reactions : reactions . remove ( net_rxn ) paths = [] for n in range ( 1 , max_num_combos + 1 ): total = int ( comb ( len ( reactions ), n ) / self . BATCH_SIZE ) + 1 groups = grouper ( combinations ( range ( len ( reactions )), n ), self . BATCH_SIZE ) pbar = groups if n >= 4 : self . logger . info ( f \"Solving for balanced pathways of size { n } ...\" ) pbar = tqdm ( groups , total = total , desc = \"PathwaySolver\" ) all_c_mats , all_m_mats = [], [] for idx , combos in enumerate ( pbar ): if n >= 4 : pbar . set_description ( f \" { self . BATCH_SIZE * idx } / { total * self . BATCH_SIZE } \" ) comp_matrices = np . stack ( [ np . vstack ([ self . _build_idx_vector ( reactions [ r ]) for r in combo ]) for combo in combos if combo ] ) c_mats , m_mats = balance_path_arrays ( comp_matrices , net_rxn_vector ) all_c_mats . extend ( c_mats ) all_m_mats . extend ( m_mats ) for c_mat , m_mat in zip ( all_c_mats , all_m_mats ): path_rxns = [] path_costs = [] for rxn_mat in c_mat : entries , coeffs = zip ( * [( entries [ idx ], c ) for idx , c in enumerate ( rxn_mat )] ) rxn = ComputedReaction ( entries = entries , coefficients = coeffs ) try : path_rxns . append ( rxn ) path_costs . append ( costs [ reactions . index ( rxn )]) except Exception as e : print ( e ) continue p = BalancedPathway ( path_rxns , m_mat . flatten (), path_costs , balanced = True ) paths . append ( p ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return filtered_paths","title":"Solver"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver","text":"","title":"PathwaySolver"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver.__init__","text":"Parameters: Name Type Description Default entries GibbsEntrySet required pathways List[rxn_network.core.pathway.Pathway] required cost_function CostFunction required open_elem str None chempot float None Source code in rxn_network/pathways/solver.py def __init__ ( self , entries : GibbsEntrySet , pathways : List [ Pathway ], cost_function : CostFunction , open_elem : str = None , chempot : float = None , ): \"\"\" Args: entries: pathways: cost_function: open_elem: chempot: \"\"\" super () . __init__ ( entries = entries , pathways = pathways ) self . cost_function = cost_function self . open_elem = open_elem self . chempot = chempot","title":"__init__()"},{"location":"reference/pathways/solver/#rxn_network.pathways.solver.PathwaySolver.solve","text":"Parameters: Name Type Description Default net_rxn ComputedReaction required max_num_combos int 4 find_intermediate_rxns bool True intermediate_rxn_energy_cutoff float 0.0 filter_interdependent bool True Source code in rxn_network/pathways/solver.py def solve ( self , net_rxn : ComputedReaction , max_num_combos : int = 4 , find_intermediate_rxns : bool = True , intermediate_rxn_energy_cutoff : float = 0.0 , filter_interdependent : bool = True , ): \"\"\" Args: net_rxn: max_num_combos: find_intermediate_rxns: intermediate_rxn_energy_cutoff: filter_interdependent: Returns: \"\"\" entries = self . entries . entries_list precursors = net_rxn . reactant_entries targets = net_rxn . product_entries reactions = self . reactions . copy () costs = self . costs . copy () if not net_rxn . balanced : raise ValueError ( \"Net reaction must be balanceable to find all reaction pathways.\" ) self . logger . info ( f \"NET RXN: { net_rxn } \\n \" ) if find_intermediate_rxns : self . logger . info ( \"Identifying reactions between intermediates...\" ) intermediate_rxns = self . _find_intermediate_rxns ( precursors , targets , intermediate_rxn_energy_cutoff ) intermediate_costs = [ self . cost_function . evaluate ( r ) for r in intermediate_rxns ] for r , c in zip ( intermediate_rxns , intermediate_costs ): if r not in reactions : reactions . append ( r ) costs . append ( c ) net_rxn_vector = self . _build_idx_vector ( net_rxn ) if net_rxn in reactions : reactions . remove ( net_rxn ) paths = [] for n in range ( 1 , max_num_combos + 1 ): total = int ( comb ( len ( reactions ), n ) / self . BATCH_SIZE ) + 1 groups = grouper ( combinations ( range ( len ( reactions )), n ), self . BATCH_SIZE ) pbar = groups if n >= 4 : self . logger . info ( f \"Solving for balanced pathways of size { n } ...\" ) pbar = tqdm ( groups , total = total , desc = \"PathwaySolver\" ) all_c_mats , all_m_mats = [], [] for idx , combos in enumerate ( pbar ): if n >= 4 : pbar . set_description ( f \" { self . BATCH_SIZE * idx } / { total * self . BATCH_SIZE } \" ) comp_matrices = np . stack ( [ np . vstack ([ self . _build_idx_vector ( reactions [ r ]) for r in combo ]) for combo in combos if combo ] ) c_mats , m_mats = balance_path_arrays ( comp_matrices , net_rxn_vector ) all_c_mats . extend ( c_mats ) all_m_mats . extend ( m_mats ) for c_mat , m_mat in zip ( all_c_mats , all_m_mats ): path_rxns = [] path_costs = [] for rxn_mat in c_mat : entries , coeffs = zip ( * [( entries [ idx ], c ) for idx , c in enumerate ( rxn_mat )] ) rxn = ComputedReaction ( entries = entries , coefficients = coeffs ) try : path_rxns . append ( rxn ) path_costs . append ( costs [ reactions . index ( rxn )]) except Exception as e : print ( e ) continue p = BalancedPathway ( path_rxns , m_mat . flatten (), path_costs , balanced = True ) paths . append ( p ) filtered_paths = [] if filter_interdependent : precursor_comps = [ p . composition for p in precursors ] for p in paths : interdependent = p . contains_interdependent_rxns ( precursor_comps ) if not interdependent : filtered_paths . append ( p ) else : filtered_paths = paths filtered_paths = sorted ( list ( set ( filtered_paths )), key = lambda p : p . average_cost ) return filtered_paths","title":"solve()"},{"location":"reference/pathways/utils/","text":"Utility functions used in reaction pathway balancing. balance_path_arrays ( comp_matrices , net_coeffs , tol = 1e-06 ) \u00b6 Fast solution for reaction multiplicities via mass balance stochiometric constraints. Parallelized using Numba. Parameters: Name Type Description Default comp_matrices ndarray Array containing stoichiometric coefficients of all compositions in all reactions, for each trial combination. required net_coeffs ndarray Array containing stoichiometric coefficients of net reaction. required tol float numerical tolerance for determining if a multiplicity is zero (reaction was removed). 1e-06 Source code in rxn_network/pathways/utils.py @njit ( parallel = True ) def balance_path_arrays ( comp_matrices : np . ndarray , net_coeffs : np . ndarray , tol : float = 1e-6 , ): \"\"\" Fast solution for reaction multiplicities via mass balance stochiometric constraints. Parallelized using Numba. Args: comp_matrices: Array containing stoichiometric coefficients of all compositions in all reactions, for each trial combination. net_coeffs: Array containing stoichiometric coefficients of net reaction. tol: numerical tolerance for determining if a multiplicity is zero (reaction was removed). \"\"\" shape = comp_matrices . shape net_coeff_filter = np . argwhere ( net_coeffs != 0 ) . flatten () len_net_coeff_filter = len ( net_coeff_filter ) all_multiplicities = np . zeros (( shape [ 0 ], shape [ 1 ]), np . float64 ) indices = np . full ( shape [ 0 ], False ) for i in prange ( shape [ 0 ]): correct = True for j in range ( len_net_coeff_filter ): idx = net_coeff_filter [ j ] if not comp_matrices [ i ][:, idx ] . any (): correct = False break if not correct : continue comp_pinv = np . linalg . pinv ( comp_matrices [ i ]) . T multiplicities = comp_pinv @ net_coeffs solved_coeffs = comp_matrices [ i ] . T @ multiplicities if ( multiplicities < tol ) . any (): continue elif not ( np . abs ( solved_coeffs - net_coeffs ) <= ( 1e-08 + 1e-05 * np . abs ( net_coeffs )) ) . all (): continue all_multiplicities [ i ] = multiplicities indices [ i ] = True filtered_indices = np . argwhere ( indices != 0 ) . flatten () length = filtered_indices . shape [ 0 ] filtered_comp_matrices = np . empty (( length , shape [ 1 ], shape [ 2 ]), np . float64 ) filtered_multiplicities = np . empty (( length , shape [ 1 ]), np . float64 ) for i in range ( length ): idx = filtered_indices [ i ] filtered_comp_matrices [ i ] = comp_matrices [ idx ] filtered_multiplicities [ i ] = all_multiplicities [ idx ] return filtered_comp_matrices , filtered_multiplicities","title":"Utils"},{"location":"reference/pathways/utils/#rxn_network.pathways.utils.balance_path_arrays","text":"Fast solution for reaction multiplicities via mass balance stochiometric constraints. Parallelized using Numba. Parameters: Name Type Description Default comp_matrices ndarray Array containing stoichiometric coefficients of all compositions in all reactions, for each trial combination. required net_coeffs ndarray Array containing stoichiometric coefficients of net reaction. required tol float numerical tolerance for determining if a multiplicity is zero (reaction was removed). 1e-06 Source code in rxn_network/pathways/utils.py @njit ( parallel = True ) def balance_path_arrays ( comp_matrices : np . ndarray , net_coeffs : np . ndarray , tol : float = 1e-6 , ): \"\"\" Fast solution for reaction multiplicities via mass balance stochiometric constraints. Parallelized using Numba. Args: comp_matrices: Array containing stoichiometric coefficients of all compositions in all reactions, for each trial combination. net_coeffs: Array containing stoichiometric coefficients of net reaction. tol: numerical tolerance for determining if a multiplicity is zero (reaction was removed). \"\"\" shape = comp_matrices . shape net_coeff_filter = np . argwhere ( net_coeffs != 0 ) . flatten () len_net_coeff_filter = len ( net_coeff_filter ) all_multiplicities = np . zeros (( shape [ 0 ], shape [ 1 ]), np . float64 ) indices = np . full ( shape [ 0 ], False ) for i in prange ( shape [ 0 ]): correct = True for j in range ( len_net_coeff_filter ): idx = net_coeff_filter [ j ] if not comp_matrices [ i ][:, idx ] . any (): correct = False break if not correct : continue comp_pinv = np . linalg . pinv ( comp_matrices [ i ]) . T multiplicities = comp_pinv @ net_coeffs solved_coeffs = comp_matrices [ i ] . T @ multiplicities if ( multiplicities < tol ) . any (): continue elif not ( np . abs ( solved_coeffs - net_coeffs ) <= ( 1e-08 + 1e-05 * np . abs ( net_coeffs )) ) . all (): continue all_multiplicities [ i ] = multiplicities indices [ i ] = True filtered_indices = np . argwhere ( indices != 0 ) . flatten () length = filtered_indices . shape [ 0 ] filtered_comp_matrices = np . empty (( length , shape [ 1 ], shape [ 2 ]), np . float64 ) filtered_multiplicities = np . empty (( length , shape [ 1 ]), np . float64 ) for i in range ( length ): idx = filtered_indices [ i ] filtered_comp_matrices [ i ] = comp_matrices [ idx ] filtered_multiplicities [ i ] = all_multiplicities [ idx ] return filtered_comp_matrices , filtered_multiplicities","title":"balance_path_arrays()"},{"location":"reference/reactions/basic/","text":"This module for defining chemical reaction objects was originally sourced from pymatgen and streamlined for the reaction-network code. BasicReaction \u00b6 An object representing a basic chemical reaction: compositions and their coefficients. chemical_system property readonly \u00b6 Returns the chemical system as string in the form of A-B-C-... coefficients : ndarray property readonly \u00b6 Array of reaction coefficients compositions : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of composition objects for this reaction energy : float property readonly \u00b6 The energy of this reaction energy_per_atom : float property readonly \u00b6 The energy per atom of this reaction is_identity property readonly \u00b6 Returns True if the reaction has identical reactants and products normalized_repr property readonly \u00b6 A normalized representation of the reaction. All factors are converted to lowest common factors. products : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of products for this reaction reactants : List [ pymatgen . core . composition . Composition ] property readonly \u00b6 List of reactants for this reaction __init__ ( self , compositions , coefficients , balanced = None , data = None , lowest_num_errors = 0 ) special \u00b6 A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Parameters: Name Type Description Default compositions List[pymatgen.core.composition.Composition] List of composition objects (pymatgen). required coefficients Union[List[float], numpy.ndarray] List of coefficients, where negative coeff distinguishes a reactant. required balanced Optional[bool] Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). None data Optional[Dict] Optional corresponding data in dictionary format; often used to store various calculated parameters. None lowest_num_errors Union[int, float] the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors = 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). 0 Source code in rxn_network/reactions/basic.py def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = self . TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data self . lowest_num_errors = lowest_num_errors balance ( reactants , products , data = None ) classmethod \u00b6 Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactants List[pymatgen.core.composition.Composition] List of reactants. required products List[pymatgen.core.composition.Composition] List of products. required data Optional[Dict] Optional dictionary containing extra data about the reaction. None Source code in rxn_network/reactions/basic.py @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = reactants + products coeffs , lowest_num_errors = cls . _balance_coeffs ( reactants , products ) balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , ) copy ( self ) \u00b6 Returns a copy of the BasicReaction object Source code in rxn_network/reactions/basic.py def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients , balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , ) from_formulas ( reactants , products ) classmethod \u00b6 Parameters: Name Type Description Default reactants List[str] required products List[str] required Returns: Type Description BasicReaction Source code in rxn_network/reactions/basic.py @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Args: reactants: products: Returns: \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn from_string ( rxn_string ) classmethod \u00b6 Generates a balanced reaction from a string. The reaction must already be balanced. Parameters: Name Type Description Default rxn_string The reaction string. For example, \"4 Li + O2-> 2Li2O\" required Returns: Type Description BasicReaction BalancedReaction Source code in rxn_network/reactions/basic.py @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs ) get_coeff ( self , comp ) \u00b6 Returns coefficient for a particular composition Source code in rxn_network/reactions/basic.py def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )] get_el_amount ( self , element ) \u00b6 Returns the amount of the element in the reaction. Parameters: Name Type Description Default element Element Element in the reaction required Returns: Type Description float Amount of that element in the reaction. Source code in rxn_network/reactions/basic.py def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( [ self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ] ) / 2 ) normalize_to ( self , comp , factor = 1 ) \u00b6 Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) normalize_to_element ( self , element , factor = 1 ) \u00b6 Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients current_el_amount = ( sum ([ all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))]) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs ) normalized_repr_and_factor ( self ) \u00b6 Normalized representation for a reaction For example, 4 Li + 2 O -> 2Li2O becomes 2 Li + O -> Li2O Source code in rxn_network/reactions/basic.py def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True ) reverse ( self ) \u00b6 Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. Source code in rxn_network/reactions/basic.py def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients , balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"Basic"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction","text":"An object representing a basic chemical reaction: compositions and their coefficients.","title":"BasicReaction"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.chemical_system","text":"Returns the chemical system as string in the form of A-B-C-...","title":"chemical_system"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.coefficients","text":"Array of reaction coefficients","title":"coefficients"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.compositions","text":"List of composition objects for this reaction","title":"compositions"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.energy","text":"The energy of this reaction","title":"energy"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.energy_per_atom","text":"The energy per atom of this reaction","title":"energy_per_atom"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.is_identity","text":"Returns True if the reaction has identical reactants and products","title":"is_identity"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalized_repr","text":"A normalized representation of the reaction. All factors are converted to lowest common factors.","title":"normalized_repr"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.products","text":"List of products for this reaction","title":"products"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reactants","text":"List of reactants for this reaction","title":"reactants"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.__init__","text":"A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Parameters: Name Type Description Default compositions List[pymatgen.core.composition.Composition] List of composition objects (pymatgen). required coefficients Union[List[float], numpy.ndarray] List of coefficients, where negative coeff distinguishes a reactant. required balanced Optional[bool] Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). None data Optional[Dict] Optional corresponding data in dictionary format; often used to store various calculated parameters. None lowest_num_errors Union[int, float] the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors = 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). 0 Source code in rxn_network/reactions/basic.py def __init__ ( self , compositions : List [ Composition ], coefficients : Union [ List [ float ], np . ndarray ], balanced : Optional [ bool ] = None , data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" A BasicReaction object is defined by a list of compositions and their corresponding coefficients, where a negative coefficient refers to a reactant, and a positive coefficient refers to a product. Args: compositions: List of composition objects (pymatgen). coefficients: List of coefficients, where negative coeff distinguishes a reactant. balanced: Whether the reaction is stoichiometricaly balanced or not (see construction via balance() method). data: Optional corresponding data in dictionary format; often used to store various calculated parameters. lowest_num_errors: the minimum number of errors reported by the reaction balancing algorithm (see the balance() method). A number of errors >= 1 means that the reaction may be different than intended (some phases may be shuffled or removed entirely). \"\"\" self . _compositions = [ Composition ( c ) for c in compositions ] self . _coefficients = np . array ( coefficients ) self . reactant_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff < 0 } self . product_coeffs = { comp : coeff for comp , coeff in zip ( self . _compositions , self . _coefficients ) if coeff > 0 } if balanced is not None : self . balanced = balanced else : sum_reactants = sum ( [ k * abs ( v ) for k , v in self . reactant_coeffs . items ()], Composition ({}) ) sum_products = sum ( [ k * abs ( v ) for k , v in self . product_coeffs . items ()], Composition ({}) ) if not sum_reactants . almost_equals ( sum_products , rtol = 0 , atol = self . TOLERANCE ): self . balanced = False else : self . balanced = True self . data = data self . lowest_num_errors = lowest_num_errors","title":"__init__()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.balance","text":"Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactants List[pymatgen.core.composition.Composition] List of reactants. required products List[pymatgen.core.composition.Composition] List of products. required data Optional[Dict] Optional dictionary containing extra data about the reaction. None Source code in rxn_network/reactions/basic.py @classmethod def balance ( cls , reactants : List [ Composition ], products : List [ Composition ], data : Optional [ Dict ] = None , ) -> \"BasicReaction\" : \"\"\" Reactants and products to be specified as list of pymatgen.core.Composition. e.g., [comp1, comp2] Args: reactants: List of reactants. products: List of products. data: Optional dictionary containing extra data about the reaction. \"\"\" compositions = reactants + products coeffs , lowest_num_errors = cls . _balance_coeffs ( reactants , products ) balanced = True if coeffs is None or lowest_num_errors == np . inf : balanced = False coeffs = np . zeros ( len ( compositions )) return cls ( compositions = compositions , coefficients = coeffs , balanced = balanced , data = data , lowest_num_errors = lowest_num_errors , )","title":"balance()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.copy","text":"Returns a copy of the BasicReaction object Source code in rxn_network/reactions/basic.py def copy ( self ) -> \"BasicReaction\" : \"\"\"Returns a copy of the BasicReaction object\"\"\" return BasicReaction ( compositions = self . compositions , coefficients = self . coefficients , balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"copy()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.from_formulas","text":"Parameters: Name Type Description Default reactants List[str] required products List[str] required Returns: Type Description BasicReaction Source code in rxn_network/reactions/basic.py @classmethod def from_formulas ( cls , reactants : List [ str ], products : List [ str ] ) -> \"BasicReaction\" : \"\"\" Args: reactants: products: Returns: \"\"\" reactant_comps = [ Composition ( r ) for r in reactants ] product_comps = [ Composition ( p ) for p in products ] rxn = cls . balance ( reactants = reactant_comps , products = product_comps ) return rxn","title":"from_formulas()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.from_string","text":"Generates a balanced reaction from a string. The reaction must already be balanced. Parameters: Name Type Description Default rxn_string The reaction string. For example, \"4 Li + O2-> 2Li2O\" required Returns: Type Description BasicReaction BalancedReaction Source code in rxn_network/reactions/basic.py @classmethod def from_string ( cls , rxn_string ) -> \"BasicReaction\" : \"\"\" Generates a balanced reaction from a string. The reaction must already be balanced. Args: rxn_string: The reaction string. For example, \"4 Li + O2-> 2Li2O\" Returns: BalancedReaction \"\"\" rct_str , prod_str = rxn_string . split ( \"->\" ) def get_comp_amt ( comp_str ): return { Composition ( m . group ( 2 )): float ( m . group ( 1 ) or 1 ) for m in re . finditer ( r \"([\\d\\.]*(?:[eE]-?[\\d\\.]+)?)\\s*([A-Z][\\w\\.\\(\\)]*)\" , comp_str ) } reactant_coeffs = get_comp_amt ( rct_str ) product_coeffs = get_comp_amt ( prod_str ) return cls . _from_coeff_dicts ( reactant_coeffs , product_coeffs )","title":"from_string()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.get_coeff","text":"Returns coefficient for a particular composition Source code in rxn_network/reactions/basic.py def get_coeff ( self , comp : Composition ): \"\"\" Returns coefficient for a particular composition \"\"\" return self . coefficients [ self . compositions . index ( comp )]","title":"get_coeff()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.get_el_amount","text":"Returns the amount of the element in the reaction. Parameters: Name Type Description Default element Element Element in the reaction required Returns: Type Description float Amount of that element in the reaction. Source code in rxn_network/reactions/basic.py def get_el_amount ( self , element : Element ) -> float : \"\"\" Returns the amount of the element in the reaction. Args: element (Element/Species): Element in the reaction Returns: Amount of that element in the reaction. \"\"\" return ( sum ( [ self . compositions [ i ][ element ] * abs ( self . coefficients [ i ]) for i in range ( len ( self . compositions )) ] ) / 2 )","title":"get_el_amount()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalize_to","text":"Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Parameters: Name Type Description Default comp Composition Composition object to normalize to required factor float factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py def normalize_to ( self , comp : Composition , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the compositions via the provided factor. By default, normalizes such that the composition given has a coefficient of 1. Args: comp: Composition object to normalize to factor: factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients scale_factor = abs ( 1 / coeffs [ self . compositions . index ( comp )] * factor ) coeffs *= scale_factor return BasicReaction ( all_comp , coeffs )","title":"normalize_to()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalize_to_element","text":"Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Parameters: Name Type Description Default element Element Element to normalize to. required factor float Factor to normalize to. Defaults to 1. 1 Source code in rxn_network/reactions/basic.py def normalize_to_element ( self , element : Element , factor : float = 1 ) -> \"BasicReaction\" : \"\"\" Normalizes the reaction to one of the elements. By default, normalizes such that the amount of the element is 1. Another factor can be specified. Args: element (Element/Species): Element to normalize to. factor (float): Factor to normalize to. Defaults to 1. \"\"\" all_comp = self . compositions coeffs = self . coefficients current_el_amount = ( sum ([ all_comp [ i ][ element ] * abs ( coeffs [ i ]) for i in range ( len ( all_comp ))]) / 2 ) scale_factor = factor / current_el_amount coeffs *= scale_factor return BasicReaction ( all_comp , coeffs )","title":"normalize_to_element()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.normalized_repr_and_factor","text":"Normalized representation for a reaction For example, 4 Li + 2 O -> 2Li2O becomes 2 Li + O -> Li2O Source code in rxn_network/reactions/basic.py def normalized_repr_and_factor ( self ): \"\"\" Normalized representation for a reaction For example, ``4 Li + 2 O -> 2Li2O`` becomes ``2 Li + O -> Li2O`` \"\"\" return self . _str_from_comp ( self . coefficients , self . compositions , True )","title":"normalized_repr_and_factor()"},{"location":"reference/reactions/basic/#rxn_network.reactions.basic.BasicReaction.reverse","text":"Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. Source code in rxn_network/reactions/basic.py def reverse ( self ) -> \"BasicReaction\" : \"\"\" Returns a copy of the original BasicReaction object where original reactants are new products, and vice versa. \"\"\" return BasicReaction ( compositions = self . compositions , coefficients =- 1 * self . coefficients , balanced = self . balanced , data = self . data , lowest_num_errors = self . lowest_num_errors , )","title":"reverse()"},{"location":"reference/reactions/computed/","text":"A reaction class that builds reactions based on ComputedEntry objects and provides information about reaction thermodynamics. ComputedReaction \u00b6 Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction. energy : float property readonly \u00b6 Returns (float): The calculated reaction energy. energy_per_atom : float property readonly \u00b6 Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction. energy_uncertainty property readonly \u00b6 Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products entries property readonly \u00b6 Returns a copy of the entries __init__ ( self , entries , coefficients , data = None , lowest_num_errors = 0 ) special \u00b6 Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects. required coefficients Union[numpy.ndarray, List[float]] List of reaction coefficients. required data Optional[Dict] Optional dict of data None lowest_num_errors Union[int, float] number of \"errors\" encountered during reaction balancing 0 Source code in rxn_network/reactions/computed.py def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors ) balance ( reactant_entries , product_entries , data = None ) classmethod \u00b6 Balances and returns a new ComputedReaction. Reactants and products to be specified as list of pymatgen.core.structure.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactant_entries List[pymatgen.entries.computed_entries.ComputedEntry] List of reactant entries required product_entries List[pymatgen.entries.computed_entries.ComputedEntry] List of product entries required data Optional[Dict] Optional dict of data None Source code in rxn_network/reactions/computed.py @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ): # pylint: disable = W0221 \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as list of pymatgen.core.structure.Composition. e.g., [comp1, comp2] Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors = cls . _balance_coeffs ( reactant_comps , product_comps ) return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) copy ( self ) \u00b6 Returns a copy of the Reaction object Source code in rxn_network/reactions/computed.py def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors ) reverse ( self ) \u00b6 Returns a reversed reaction (i.e. sides flipped) Source code in rxn_network/reactions/computed.py def reverse ( self ): \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors )","title":"Computed"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction","text":"Convenience class to generate a reaction from ComputedEntry objects, with some additional attributes, such as a reaction energy based on computed energies. This class also balances the reaction.","title":"ComputedReaction"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy","text":"Returns (float): The calculated reaction energy.","title":"energy"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy_per_atom","text":"Returns (float): The calculated reaction energy in eV, divided by the total number of atoms in the reaction.","title":"energy_per_atom"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.energy_uncertainty","text":"Calculates the uncertainty in the reaction energy based on the uncertainty in the energies of the reactants/products","title":"energy_uncertainty"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.entries","text":"Returns a copy of the entries","title":"entries"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.__init__","text":"Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects. required coefficients Union[numpy.ndarray, List[float]] List of reaction coefficients. required data Optional[Dict] Optional dict of data None lowest_num_errors Union[int, float] number of \"errors\" encountered during reaction balancing 0 Source code in rxn_network/reactions/computed.py def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], data : Optional [ Dict ] = None , lowest_num_errors : Union [ int , float ] = 0 , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" self . _entries = list ( entries ) self . reactant_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff < 0 ] self . product_entries = [ entry for entry , coeff in zip ( entries , coefficients ) if coeff > 0 ] compositions = [ e . composition . reduced_composition for e in entries ] super () . __init__ ( compositions , coefficients , data = data , lowest_num_errors = lowest_num_errors )","title":"__init__()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.balance","text":"Balances and returns a new ComputedReaction. Reactants and products to be specified as list of pymatgen.core.structure.Composition. e.g., [comp1, comp2] Parameters: Name Type Description Default reactant_entries List[pymatgen.entries.computed_entries.ComputedEntry] List of reactant entries required product_entries List[pymatgen.entries.computed_entries.ComputedEntry] List of product entries required data Optional[Dict] Optional dict of data None Source code in rxn_network/reactions/computed.py @classmethod def balance ( cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], data : Optional [ Dict ] = None , ): # pylint: disable = W0221 \"\"\" Balances and returns a new ComputedReaction. Reactants and products to be specified as list of pymatgen.core.structure.Composition. e.g., [comp1, comp2] Args: reactant_entries: List of reactant entries product_entries: List of product entries data: Optional dict of data \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors = cls . _balance_coeffs ( reactant_comps , product_comps ) return cls ( entries = list ( reactant_entries ) + list ( product_entries ), coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , )","title":"balance()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.copy","text":"Returns a copy of the Reaction object Source code in rxn_network/reactions/computed.py def copy ( self ) -> \"ComputedReaction\" : \"\"\" Returns a copy of the Reaction object \"\"\" return ComputedReaction ( self . entries , self . coefficients , self . data , self . lowest_num_errors )","title":"copy()"},{"location":"reference/reactions/computed/#rxn_network.reactions.computed.ComputedReaction.reverse","text":"Returns a reversed reaction (i.e. sides flipped) Source code in rxn_network/reactions/computed.py def reverse ( self ): \"\"\" Returns a reversed reaction (i.e. sides flipped) \"\"\" return ComputedReaction ( self . entries , - 1 * self . coefficients , self . data , self . lowest_num_errors )","title":"reverse()"},{"location":"reference/reactions/open/","text":"A reaction class that builds reactions based on ComputedEntry objects under the presence of an open entry (e.g. O2), and provides information about reaction thermodynamics computed as changes in grand potential. OpenComputedReaction \u00b6 Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential. elements : List [ pymatgen . core . periodic_table . Element ] property readonly \u00b6 List of elements in the reaction energy : float property readonly \u00b6 Returns (float): The calculated reaction energy. total_chemical_system : str property readonly \u00b6 Chemical system string, including open elements __init__ ( self , entries , coefficients , chempots , data = None , lowest_num_errors = None ) special \u00b6 Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects. required coefficients Union[numpy.ndarray, List[float]] List of reaction coefficients. required chempots Dict[pymatgen.core.periodic_table.Element, float] Dict of chemical potentials corresponding to open elements required data Optional[Dict] Optional dict of data None lowest_num_errors number of \"errors\" encountered during reaction balancing None Source code in rxn_network/reactions/open.py def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries balance ( reactant_entries , product_entries , chempots = None , data = None ) classmethod \u00b6 Parameters: Name Type Description Default reactant_entries List[pymatgen.entries.computed_entries.ComputedEntry] required product_entries List[pymatgen.entries.computed_entries.ComputedEntry] required chempots Dict[pymatgen.core.periodic_table.Element, float] None data Optional[Dict] None Source code in rxn_network/reactions/open.py @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ] = None , data : Optional [ Dict ] = None , ): # pylint: disable = W0221 \"\"\" Args: reactant_entries: product_entries: chempots: data: Returns: \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors = cls . _balance_coeffs ( reactant_comps , product_comps ) entries = list ( reactant_entries ) + list ( product_entries ) args = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** args ) # type: ignore else : rxn = cls ( chempots = chempots , ** args ) # type: ignore return rxn copy ( self ) \u00b6 Returns a copy of the OpenComputedReaction object. Source code in rxn_network/reactions/open.py def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , ) reverse ( self ) \u00b6 Returns a copy of reaction with reactants/products swapped Source code in rxn_network/reactions/open.py def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , )","title":"Open"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction","text":"Extends the ComputedReaction class to add support for \"open\" reactions, where the reaction energy is calculated as a change in grand potential.","title":"OpenComputedReaction"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.elements","text":"List of elements in the reaction","title":"elements"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.energy","text":"Returns (float): The calculated reaction energy.","title":"energy"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.total_chemical_system","text":"Chemical system string, including open elements","title":"total_chemical_system"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.__init__","text":"Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects. required coefficients Union[numpy.ndarray, List[float]] List of reaction coefficients. required chempots Dict[pymatgen.core.periodic_table.Element, float] Dict of chemical potentials corresponding to open elements required data Optional[Dict] Optional dict of data None lowest_num_errors number of \"errors\" encountered during reaction balancing None Source code in rxn_network/reactions/open.py def __init__ ( self , entries : List [ ComputedEntry ], coefficients : Union [ np . ndarray , List [ float ]], chempots : Dict [ Element , float ], data : Optional [ Dict ] = None , lowest_num_errors = None , ): \"\"\" Args: entries: List of ComputedEntry objects. coefficients: List of reaction coefficients. chempots: Dict of chemical potentials corresponding to open elements data: Optional dict of data lowest_num_errors: number of \"errors\" encountered during reaction balancing \"\"\" super () . __init__ ( entries = entries , coefficients = coefficients , data = data , lowest_num_errors = lowest_num_errors , ) self . chempots = chempots self . open_elems = list ( chempots . keys ()) grand_entries = [] for e in entries : comp = e . composition . reduced_composition if len ( comp . elements ) == 1 and comp . elements [ 0 ] in self . open_elems : grand_entries . append ( e ) else : grand_entries . append ( GrandPotPDEntry ( e , chempots )) self . grand_entries = grand_entries","title":"__init__()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.balance","text":"Parameters: Name Type Description Default reactant_entries List[pymatgen.entries.computed_entries.ComputedEntry] required product_entries List[pymatgen.entries.computed_entries.ComputedEntry] required chempots Dict[pymatgen.core.periodic_table.Element, float] None data Optional[Dict] None Source code in rxn_network/reactions/open.py @classmethod def balance ( # type: ignore cls , reactant_entries : List [ ComputedEntry ], product_entries : List [ ComputedEntry ], chempots : Dict [ Element , float ] = None , data : Optional [ Dict ] = None , ): # pylint: disable = W0221 \"\"\" Args: reactant_entries: product_entries: chempots: data: Returns: \"\"\" reactant_comps = [ e . composition . reduced_composition for e in reactant_entries ] product_comps = [ e . composition . reduced_composition for e in product_entries ] coefficients , lowest_num_errors = cls . _balance_coeffs ( reactant_comps , product_comps ) entries = list ( reactant_entries ) + list ( product_entries ) args = { \"entries\" : entries , \"coefficients\" : coefficients , \"data\" : data , \"lowest_num_errors\" : lowest_num_errors , } if not chempots : rxn = ComputedReaction ( ** args ) # type: ignore else : rxn = cls ( chempots = chempots , ** args ) # type: ignore return rxn","title":"balance()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.copy","text":"Returns a copy of the OpenComputedReaction object. Source code in rxn_network/reactions/open.py def copy ( self ) -> \"OpenComputedReaction\" : \"\"\" Returns a copy of the OpenComputedReaction object. \"\"\" return OpenComputedReaction ( self . entries , self . coefficients , self . chempots , self . data , self . lowest_num_errors , )","title":"copy()"},{"location":"reference/reactions/open/#rxn_network.reactions.open.OpenComputedReaction.reverse","text":"Returns a copy of reaction with reactants/products swapped Source code in rxn_network/reactions/open.py def reverse ( self ): \"\"\" Returns a copy of reaction with reactants/products swapped \"\"\" return OpenComputedReaction ( self . entries , - 1 * self . coefficients , self . chempots , self . data , self . lowest_num_errors , )","title":"reverse()"},{"location":"reference/reactions/reaction_set/","text":"Implements a class for conveniently and efficiently storing sets of ComputedReaction objects which share entries. ReactionSet \u00b6 A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries. __init__ ( self , entries , indices , coeffs , all_data = None ) special \u00b6 Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects shared by reactions required indices Union[numpy.ndarray, List[List[int]]] Array indexing the entry list; gets entries used by each reaction object required coeffs Union[numpy.ndarray, List[List[float]]] Array of all reaction coefficients required all_data Optional[List] Optional list of data for each reaction None Source code in rxn_network/reactions/reaction_set.py def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . all_data = all_data if all_data else [] calculate_costs ( self , cf , open_elem = None , chempot = 0 ) \u00b6 Evaluate a cost function on an acquired set of reactions. Parameters: Name Type Description Default cf CostFunction CostFunction object, e.g. Softplus() required open_elem Union[str, pymatgen.core.periodic_table.Element] Open element, e.g. \"O2\" None chempot Optional[float] Chemical potential (mu) of open element in equation: Phi = G - mu*N 0 Source code in rxn_network/reactions/reaction_set.py def calculate_costs ( self , cf : CostFunction , open_elem : Optional [ Union [ str , Element ]] = None , chempot : Optional [ float ] = 0 , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ( open_elem = open_elem , chempot = chempot ) ] from_rxns ( rxns , entries = None ) classmethod \u00b6 Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default rxns List[Union[rxn_network.reactions.computed.ComputedReaction, rxn_network.reactions.open.OpenComputedReaction]] List of ComputedReaction-like objects. required entries Optional[Iterable[pymatgen.entries.computed_entries.ComputedEntry]] Optional list of ComputedEntry objects None Source code in rxn_network/reactions/reaction_set.py @classmethod def from_rxns ( cls , rxns : List [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Iterable [ ComputedEntry ]] = None , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_indices , all_coeffs , all_data = [], [], [] for rxn in rxns : all_indices . append ([ entries . index ( e ) for e in rxn . entries ]) all_coeffs . append ( list ( rxn . coefficients )) all_data . append ( rxn . data ) return cls ( entries = entries , indices = all_indices , coeffs = all_coeffs , all_data = all_data , ) get_rxns ( self , open_elem = None , chempot = 0.0 ) \u00b6 Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Parameters: Name Type Description Default open_elem Optional[str] Open element, e.g. \"O2\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 Source code in rxn_network/reactions/reaction_set.py @lru_cache ( 1 ) def get_rxns ( self , open_elem : Optional [ str ] = None , chempot : float = 0.0 , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Args: open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" rxns = [] chempots = None if open_elem : chempots = { Element ( open_elem ): chempot } for indices , coeffs , data in zip ( self . indices , self . coeffs , self . all_data ): entries = [ self . entries [ i ] for i in indices ] if chempots : rxn = OpenComputedReaction ( entries = entries , coefficients = coeffs , data = data , chempots = chempots ) else : rxn = ComputedReaction ( entries = entries , coefficients = coeffs , data = data ) rxns . append ( rxn ) return rxns","title":"Reaction Set"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet","text":"A lightweight class for storing large sets of ComputedReaction objects. Automatically represents a set of reactions as an array of coefficients with a second array linking to a corresponding list of shared entries.","title":"ReactionSet"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.__init__","text":"Parameters: Name Type Description Default entries List[pymatgen.entries.computed_entries.ComputedEntry] List of ComputedEntry objects shared by reactions required indices Union[numpy.ndarray, List[List[int]]] Array indexing the entry list; gets entries used by each reaction object required coeffs Union[numpy.ndarray, List[List[float]]] Array of all reaction coefficients required all_data Optional[List] Optional list of data for each reaction None Source code in rxn_network/reactions/reaction_set.py def __init__ ( self , entries : List [ ComputedEntry ], indices : Union [ np . ndarray , List [ List [ int ]]], coeffs : Union [ np . ndarray , List [ List [ float ]]], all_data : Optional [ List ] = None , ): \"\"\" Args: entries: List of ComputedEntry objects shared by reactions indices: Array indexing the entry list; gets entries used by each reaction object coeffs: Array of all reaction coefficients all_data: Optional list of data for each reaction \"\"\" self . entries = entries self . indices = indices self . coeffs = coeffs self . all_data = all_data if all_data else []","title":"__init__()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.calculate_costs","text":"Evaluate a cost function on an acquired set of reactions. Parameters: Name Type Description Default cf CostFunction CostFunction object, e.g. Softplus() required open_elem Union[str, pymatgen.core.periodic_table.Element] Open element, e.g. \"O2\" None chempot Optional[float] Chemical potential (mu) of open element in equation: Phi = G - mu*N 0 Source code in rxn_network/reactions/reaction_set.py def calculate_costs ( self , cf : CostFunction , open_elem : Optional [ Union [ str , Element ]] = None , chempot : Optional [ float ] = 0 , ) -> List [ float ]: \"\"\" Evaluate a cost function on an acquired set of reactions. Args: cf: CostFunction object, e.g. Softplus() open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" return [ cf . evaluate ( rxn ) for rxn in self . get_rxns ( open_elem = open_elem , chempot = chempot ) ]","title":"calculate_costs()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.from_rxns","text":"Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Parameters: Name Type Description Default rxns List[Union[rxn_network.reactions.computed.ComputedReaction, rxn_network.reactions.open.OpenComputedReaction]] List of ComputedReaction-like objects. required entries Optional[Iterable[pymatgen.entries.computed_entries.ComputedEntry]] Optional list of ComputedEntry objects None Source code in rxn_network/reactions/reaction_set.py @classmethod def from_rxns ( cls , rxns : List [ Union [ ComputedReaction , OpenComputedReaction ]], entries : Optional [ Iterable [ ComputedEntry ]] = None , ) -> \"ReactionSet\" : \"\"\" Initiate a ReactionSet object from a list of reactions. Including a list of unique entries saves some computation time. Args: rxns: List of ComputedReaction-like objects. entries: Optional list of ComputedEntry objects \"\"\" if not entries : entries = cls . _get_unique_entries ( rxns ) entries = sorted ( list ( set ( entries )), key = lambda r : r . composition ) all_indices , all_coeffs , all_data = [], [], [] for rxn in rxns : all_indices . append ([ entries . index ( e ) for e in rxn . entries ]) all_coeffs . append ( list ( rxn . coefficients )) all_data . append ( rxn . data ) return cls ( entries = entries , indices = all_indices , coeffs = all_coeffs , all_data = all_data , )","title":"from_rxns()"},{"location":"reference/reactions/reaction_set/#rxn_network.reactions.reaction_set.ReactionSet.get_rxns","text":"Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Parameters: Name Type Description Default open_elem Optional[str] Open element, e.g. \"O2\" None chempot float Chemical potential (mu) of open element in equation: Phi = G - mu*N 0.0 Source code in rxn_network/reactions/reaction_set.py @lru_cache ( 1 ) def get_rxns ( self , open_elem : Optional [ str ] = None , chempot : float = 0.0 , ) -> List [ Union [ ComputedReaction , OpenComputedReaction ]]: \"\"\" Returns list of ComputedReaction objects or OpenComputedReaction objects (when open element and chempot are specified) for the reaction set. Args: open_elem: Open element, e.g. \"O2\" chempot: Chemical potential (mu) of open element in equation: Phi = G - mu*N \"\"\" rxns = [] chempots = None if open_elem : chempots = { Element ( open_elem ): chempot } for indices , coeffs , data in zip ( self . indices , self . coeffs , self . all_data ): entries = [ self . entries [ i ] for i in indices ] if chempots : rxn = OpenComputedReaction ( entries = entries , coefficients = coeffs , data = data , chempots = chempots ) else : rxn = ComputedReaction ( entries = entries , coefficients = coeffs , data = data ) rxns . append ( rxn ) return rxns","title":"get_rxns()"},{"location":"reference/reactions/utils/","text":"Utility functions used in the reaction classes. is_separable_rxn ( rxn , target_comp , added_elems ) \u00b6 Parameters: Name Type Description Default rxn required target_comp required added_elems required Source code in rxn_network/reactions/utils.py def is_separable_rxn ( rxn , target_comp , added_elems ): \"\"\" Args: rxn: target_comp: added_elems: Returns: \"\"\" added_elems = [ Element ( e ) for e in added_elems . split ( \"-\" )] products = rxn . products . copy () products . remove ( target_comp ) separable = np . array ( [ set ( comp . elements ) . issubset ( added_elems ) for comp in products ] ) found = False if separable . all (): found = True return found","title":"Utils"},{"location":"reference/reactions/utils/#rxn_network.reactions.utils.is_separable_rxn","text":"Parameters: Name Type Description Default rxn required target_comp required added_elems required Source code in rxn_network/reactions/utils.py def is_separable_rxn ( rxn , target_comp , added_elems ): \"\"\" Args: rxn: target_comp: added_elems: Returns: \"\"\" added_elems = [ Element ( e ) for e in added_elems . split ( \"-\" )] products = rxn . products . copy () products . remove ( target_comp ) separable = np . array ( [ set ( comp . elements ) . issubset ( added_elems ) for comp in products ] ) found = False if separable . all (): found = True return found","title":"is_separable_rxn()"},{"location":"reference/thermo/chempot_diagram/","text":"This module implements added features to the ChemicalPotentialDiagram class from pymatgen. ChemicalPotentialDiagram \u00b6 shortest_domain_distance ( self , f1 , f2 ) \u00b6 Parameters: Name Type Description Default f1 str chemical formula (1) required f2 str chemical formula (2) required Returns: Type Description float Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. Source code in rxn_network/thermo/chempot_diagram.py def shortest_domain_distance ( self , f1 : str , f2 : str ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" pts1 = self . domains [ Composition ( f1 ) . reduced_formula ] pts2 = self . domains [ Composition ( f2 ) . reduced_formula ] tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ]) shortest_elemental_domain_distances ( self , f1 , f2 ) \u00b6 TODO: Use with caution; this function may not yet make sense geometrically! Source code in rxn_network/thermo/chempot_diagram.py def shortest_elemental_domain_distances ( self , f1 , f2 ) -> float : \"\"\" TODO: Use with caution; this function may not yet make sense geometrically! \"\"\" pts1 = self . domains [ f1 ] pts2 = self . domains [ f2 ] pts1 = pts1 [ ~ np . isclose ( pts1 , self . default_min_limit ) . any ( axis = 1 )] pts2 = pts2 [ ~ np . isclose ( pts2 , self . default_min_limit ) . any ( axis = 1 )] num_elems = pts1 . shape [ 1 ] mesh = np . meshgrid ( pts1 , pts2 ) diff = abs ( mesh [ 0 ] - mesh [ 1 ]) diff = diff . reshape ( - 1 , num_elems ) return diff . min ( axis = 0 )","title":"Chempot Diagram"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram","text":"","title":"ChemicalPotentialDiagram"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.shortest_domain_distance","text":"Parameters: Name Type Description Default f1 str chemical formula (1) required f2 str chemical formula (2) required Returns: Type Description float Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. Source code in rxn_network/thermo/chempot_diagram.py def shortest_domain_distance ( self , f1 : str , f2 : str ) -> float : \"\"\" Args: f1: chemical formula (1) f2: chemical formula (2) Returns: Shortest distance between domain boundaries in the full (hyper)dimensional space, calculated using KDTree. \"\"\" pts1 = self . domains [ Composition ( f1 ) . reduced_formula ] pts2 = self . domains [ Composition ( f2 ) . reduced_formula ] tree = KDTree ( pts1 ) return min ( tree . query ( pts2 )[ 0 ])","title":"shortest_domain_distance()"},{"location":"reference/thermo/chempot_diagram/#rxn_network.thermo.chempot_diagram.ChemicalPotentialDiagram.shortest_elemental_domain_distances","text":"TODO: Use with caution; this function may not yet make sense geometrically! Source code in rxn_network/thermo/chempot_diagram.py def shortest_elemental_domain_distances ( self , f1 , f2 ) -> float : \"\"\" TODO: Use with caution; this function may not yet make sense geometrically! \"\"\" pts1 = self . domains [ f1 ] pts2 = self . domains [ f2 ] pts1 = pts1 [ ~ np . isclose ( pts1 , self . default_min_limit ) . any ( axis = 1 )] pts2 = pts2 [ ~ np . isclose ( pts2 , self . default_min_limit ) . any ( axis = 1 )] num_elems = pts1 . shape [ 1 ] mesh = np . meshgrid ( pts1 , pts2 ) diff = abs ( mesh [ 0 ] - mesh [ 1 ]) diff = diff . reshape ( - 1 , num_elems ) return diff . min ( axis = 0 )","title":"shortest_elemental_domain_distances()"},{"location":"reference/thermo/utils/","text":"Utility functions used in the thermodynamic analysis classes. expand_pd ( entries ) \u00b6 Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic staiblity in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] list of Entry objects for building phase diagram. required Returns: Type Description Dict[str, pymatgen.analysis.phase_diagram.PhaseDiagram] Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": , \"C-Y\": , ...} Source code in rxn_network/thermo/utils.py def expand_pd ( entries : List [ Entry ]) -> Dict [ str , PhaseDiagram ]: \"\"\" Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic staiblity in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Args: entries ([Entry]): list of Entry objects for building phase diagram. Returns: Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": <PhaseDiagram object>, \"C-Y\": <PhaseDiagram object>, ...} \"\"\" pd_dict : Dict [ str , PhaseDiagram ] = dict () sorted_entries = sorted ( entries , key = lambda x : len ( x . composition . elements ), reverse = True ) for e in sorted_entries : for chemsys in pd_dict . keys (): if set ( e . composition . chemical_system . split ( \"-\" )) . issubset ( chemsys . split ( \"-\" ) ): break else : pd_dict [ e . composition . chemical_system ] = PhaseDiagram ( list ( filter ( lambda x : set ( x . composition . elements ) . issubset ( e . composition . elements ), entries , ) ) ) return pd_dict","title":"Utils"},{"location":"reference/thermo/utils/#rxn_network.thermo.utils.expand_pd","text":"Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic staiblity in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Parameters: Name Type Description Default entries List[pymatgen.entries.Entry] list of Entry objects for building phase diagram. required Returns: Type Description Dict[str, pymatgen.analysis.phase_diagram.PhaseDiagram] Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": , \"C-Y\": , ...} Source code in rxn_network/thermo/utils.py def expand_pd ( entries : List [ Entry ]) -> Dict [ str , PhaseDiagram ]: \"\"\" Helper method for generating a set of smaller phase diagrams for analyzing thermodynamic staiblity in large chemical systems. This is necessary when considering chemical systems which contain 10 or more elements, due to dimensional limitations of the Qhull algorithm. Args: entries ([Entry]): list of Entry objects for building phase diagram. Returns: Dictionary of PhaseDiagram objects indexed by chemical subsystem string; e.g. {\"Li-Mn-O\": <PhaseDiagram object>, \"C-Y\": <PhaseDiagram object>, ...} \"\"\" pd_dict : Dict [ str , PhaseDiagram ] = dict () sorted_entries = sorted ( entries , key = lambda x : len ( x . composition . elements ), reverse = True ) for e in sorted_entries : for chemsys in pd_dict . keys (): if set ( e . composition . chemical_system . split ( \"-\" )) . issubset ( chemsys . split ( \"-\" ) ): break else : pd_dict [ e . composition . chemical_system ] = PhaseDiagram ( list ( filter ( lambda x : set ( x . composition . elements ) . issubset ( e . composition . elements ), entries , ) ) ) return pd_dict","title":"expand_pd()"}]}